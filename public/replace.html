<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>replace</title>
</head>
<body>
  <script type="importmap"> 
    {
 "imports": {
  "lz-string": "https://cdn.jsdelivr.net/npm/lz-string@1.5.0/+esm"
 }
}
  </script>
<script type="module"> 
    let global = {};
async function app_context_initialize(fn) {
  const root = html_document_body();
  await app_context_initialize_root(root, fn);
}
async function app_context_initialize_root(root, fn) {
  let context = {
    root
  };
  await fn(context);
}
function html_document_body() {
  let body_element = document.body;
  let body = html_component_wrap(body_element);
  return body;
}
function html_component_wrap(element) {
  let c = {
    element
  };
  return c;
}
async function app_replace_main(context) {
  let app_fn = app_replace;
  let screens = app_replace_screens();
  html_meta_viewport();
  html_font_sans_serif_set_html();
  object_merge(context, {
    app_fn,
    screens
  });
  app_shared_refresh(context);
  app_replace_font_size_refresh(context);
}
function html_font_sans_serif_set_html() {
  let html2 = html_document_root();
  html_roboto_include();
  let style_value = html_font_sans_serif_value();
  html_font_set(html2, style_value);
  const style = ":font-family: " + html_font_sans_serif_value();
  html_style_button(style);
}
function html_style_button(style) {
  html_style_head("button { " + style + " }");
}
function html_style_head(style_text) {
  let parent = html_document_head();
  let component = html_element(parent, "style");
  html_text_set(component, style_text);
}
function html_text_set(component, text) {
  let element = html_component_element_get(component);
  element.innerHTML = text;
}
function html_component_element_get(component) {
  let element = property_get(component, "element");
  return element;
}
function property_get(object, property_name) {
  let value = object[property_name];
  undefined_not_is_assert_lambda(value, object_get);
  function object_get() {
    let v = {
      object,
      property_name
    };
    return v;
  }
  return value;
}
function undefined_not_is_assert_lambda(value, lambda) {
  if (undefined_is(value)) {
    const object = lambda();
    let message = json_to(object);
    error(message);
  }
}
function error(message) {
  throw new Error(message);
}
function json_to(object) {
  let json = JSON.stringify(object);
  return json;
}
function undefined_is(value) {
  let v = typeof value === "undefined";
  return v;
}
function html_element(parent, tag_name) {
  const e = document.createElement(tag_name);
  let component = html_component_wrap(e);
  html_parent_append(parent, component);
  html_style_set(component, "box-sizing", "border-box");
  return component;
}
function html_parent_append(parent, child) {
  let parent_element = html_component_element_get(parent);
  let child_element = html_component_element_get(child);
  parent_element.appendChild(child_element);
}
function html_style_set(b, style_key, style_value) {
  let b_element = html_component_element_get(b);
  b_element.style[style_key] = style_value;
}
function html_document_head() {
  let head_e = document.head;
  let head = html_component_wrap(head_e);
  return head;
}
function html_roboto_include() {
  const href = "https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap";
  let fn = html_roboto_include;
  html_font_include(fn, href);
}
function html_font_include(fn, href) {
  global_function_once(lambda, fn);
  function lambda() {
    html_stylesheet(href);
  }
}
function html_stylesheet(href) {
  let l = html_link();
  html_attribute_set(l, "href", href);
  html_attribute_set(l, "rel", "stylesheet");
}
function html_attribute_set(component, key, value) {
  let element = html_component_element_get(component);
  element.setAttribute(key, value);
}
function html_link() {
  let head = html_document_head();
  let link = html_element(head, "link");
  return link;
}
function global_function_once(lambda, fn) {
  function value_get() {
    lambda();
    let v = true;
    return v;
  }
  global_function_initialize_lambda(fn, value_get);
}
function global_function_initialize_lambda(fn, lambda) {
  assert_arguments(arguments, 2);
  let global = global_get();
  let value = property_initialize_lambda(global, fn.name, lambda);
  return value;
}
function property_initialize_lambda(object, property_name, lambda) {
  const exists = property_exists(object, property_name);
  if (not(exists)) {
    let value_set = lambda();
    property_set(object, property_name, value_set);
  }
  let value = property_get(object, property_name);
  return value;
}
function not(b) {
  let n = !b;
  return n;
}
function property_set(object, property_name, value) {
  object[property_name] = value;
}
function property_exists(object, property_name) {
  const exists = object && Object.hasOwn(object, property_name);
  return exists;
}
function assert_arguments(args, count) {
  let length = property_get(args, "length");
  equal_assert(length, count);
}
function equal_assert(left, right) {
  let eq = equal(left, right);
  assert(eq);
}
function assert(b) {
  if (not(b)) {
    error();
  }
}
function equal(left, right) {
  let eq = left === right;
  return eq;
}
function global_get() {
  let exists = property_exists(global, global_alternate_set.name);
  if (exists) {
    let value = property_get(global, global_alternate_set.name);
    return value;
  }
  return global;
}
function global_alternate_set(global_alternate) {
  let global = global_get();
  global_function_set(global_alternate_set, global_alternate);
  let unset = function lambda() {
    property_delete(global, global_alternate_set.name);
  };
  return unset;
}
function property_delete(object, property_name) {
  property_exists_assert(object, property_name);
  delete object[property_name];
}
function property_exists_assert(object, property_name) {
  let result = property_exists(object, property_name);
  function lambda() {
    let v = {
      object,
      property_name
    };
    return v;
  }
  assert_json_get(result, lambda);
}
function assert_json_get(b, lambda) {
  function json_get() {
    let object = lambda();
    let json = json_to(object);
    return json;
  }
  assert_message_get(b, json_get);
}
function assert_message_get(b, lambda) {
  if (not(b)) {
    let message = lambda();
    error(message);
  }
}
function global_function_set(fn, value) {
  let global = global_get();
  property_set(global, fn.name, value);
}
function html_font_set(html, value) {
  html_style_set(html, "font-family", value);
}
function html_font_sans_serif_value() {
  let v = '"Roboto", Arial, Helvetica, sans-serif';
  return v;
}
function html_document_root() {
  let html_element = document.documentElement;
  let html = html_component_wrap(html_element);
  return html;
}
function object_merge(to, from) {
  let strict = true;
  object_merge_generic(strict, to, from);
  return to;
}
function object_merge_generic(strict, to, from) {
  function lambda(property_name) {
    if (strict) {
      if (property_exists(to, property_name)) {
        error_json({
          to,
          from,
          property_name
        });
      }
    }
    let value = property_get(from, property_name);
    property_set(to, property_name, value);
  }
  let list = properties_get(from);
  each(list, lambda);
}
function each(list, lambda$item) {
  for (let item of list) {
    if (lambda$item(item) === true) {
      return;
    }
  }
}
function properties_get(obj) {
  const properties = Object.getOwnPropertyNames(obj);
  return properties;
}
function error_json(o) {
  let message = json_format_to_truncated(o);
  error(message);
}
function json_format_to_truncated(object) {
  let j = json_format_to(object);
  let taken = text_take(j, 10000);
  return taken;
}
function json_format_to(object) {
  let r = JSON.stringify(object, null, 1);
  return r;
}
function text_take(s, count) {
  let taken = text_slice(s, 0, count);
  return taken;
}
function text_slice(s, from, to) {
  let sliced = s.slice(from, to);
  return sliced;
}
function app_replace_font_size_refresh(context) {
  let root = property_get(context, "root");
  let value = app_replace_font_size(context);
  html_style_font_size(root, value + "px");
}
function app_replace_font_size(context) {
  let value2 = storage_local_initialize_context(context, "font_size", 20);
  return value2;
}
function storage_local_initialize_context(context, key, value_initial) {
  let app_fn = property_get(context, "app_fn");
  let value = storage_local_initialize(app_fn, key, value_initial);
  return value;
}
function storage_local_initialize(app_fn, key, value_initial) {
  let value = storage_local_get(app_fn, key);
  let n = null_is(value);
  if (n) {
    log({
      value_initial
    });
    storage_local_set(app_fn, key, value_initial);
    value = storage_local_get(app_fn, key);
  }
  return value;
}
function log(message) {
  log_keep(message);
  let a = 1;
}
function log_keep(message) {
  console.log(message);
}
function storage_local_set(app_fn, key, value) {
  let storage_local_key = storage_local_key_get(app_fn, key);
  if (storage_local_enabled()) {
    storage_local_specify_set(storage_local_key, value);
    return;
  }
  global_function_property_set(storage_local_set, storage_local_key, value);
}
function global_function_property_set(fn, property_name, value) {
  let fn_object = global_function_initialize(fn, {});
  property_set(fn_object, property_name, value);
}
function global_function_initialize(fn, initial) {
  assert_arguments(arguments, 2);
  let value_get = lambda_get(initial);
  let value = global_function_initialize_lambda(fn, value_get);
  return value;
}
function lambda_get(value) {
  function value_get() {
    return value;
  }
  return value_get;
}
function storage_local_specify_set(storage_local_key, value) {
  value = undefined_is_if_null(value);
  let j = json_to({
    value
  });
  localStorage.setItem(storage_local_key, j);
}
function undefined_is_if_null(result) {
  if (undefined_is(result)) {
    result = null;
  }
  return result;
}
function storage_local_key_get(app_fn, key) {
  let ley = app_fn.name + " " + key;
  return ley;
}
function storage_local_enabled() {
  let set = global_function_exists(storage_local_enabled);
  let enabled = not(set) || global_function_get(storage_local_enabled) === true;
  return enabled;
}
function global_function_get(fn) {
  let global = global_get();
  let value = property_get(global, fn.name);
  return value;
}
function global_function_exists(fn) {
  let global = global_get();
  let exists = property_exists(global, fn.name);
  return exists;
}
function null_is(value) {
  const n = value === null;
  return n;
}
function storage_local_get(app_fn, key) {
  let storage_local_key = storage_local_key_get(app_fn, key);
  if (storage_local_enabled()) {
    let result = storage_local_specify_get(storage_local_key);
    return result;
  }
  let value = storage_local_get_global(storage_local_key);
  return value;
}
function storage_local_get_global(storage_local_key) {
  let exists = storage_local_exists_global(storage_local_key);
  "localStorage has this behavior of null if not exists, so the in-memory version also mirrors api";
  let value = null;
  if (exists) {
    value = global_function_property_get(storage_local_set, storage_local_key);
  }
  return value;
}
function storage_local_exists_global(storage_local_key) {
  let exists2 = global_function_property_exists(storage_local_set, storage_local_key);
  return exists2;
}
function global_function_property_exists(fn, property_name) {
  let fn_object = global_function_initialize_object(fn);
  let exists = property_exists(fn_object, property_name);
  return exists;
}
function global_function_initialize_object(fn) {
  let value = global_function_initialize(fn, {});
  return value;
}
function global_function_property_get(fn, property_name) {
  let fn_object = global_function_initialize(fn, {});
  let value = property_get(fn_object, property_name);
  return value;
}
function storage_local_specify_get(storage_local_key) {
  let json = storage_local_specify_get_json(storage_local_key);
  let nn = null_not_is(json);
  let result = null;
  if (nn) {
    let r = json_from(json);
    result = property_get(r, "value");
  }
  return result;
}
function null_not_is(value) {
  let nn = value !== null;
  return nn;
}
function storage_local_specify_get_json(storage_local_key) {
  let r = localStorage.getItem(storage_local_key);
  return r;
}
function json_from(json) {
  let v = JSON.parse(json);
  return v;
}
function html_style_font_size(html, value) {
  html_style_set(html, "font-size", value);
}
function html_meta_viewport() {
  const head = html_document_head();
  let component = html_element(head, "meta");
  html_attribute_set(component, "name", "viewport");
  html_attribute_set(component, "content", "width=device-width, initial-scale=1.0");
}
function app_shared_refresh(context) {
  let screens = property_get(context, "screens");
  let app_fn = property_get(context, "app_fn");
  let body = html_document_body();
  html_clear(body);
  let value = property_get(app_fn, "name");
  let combined = function_name_combine(value, "home");
  let screen_name = storage_local_initialize_context(context, "screen", combined);
  let screen = list_find_property(screens, "name", screen_name);
  screen(context);
}
function function_name_combine(left, right) {
  const combined = function_name_combine_multiple([left, right]);
  return combined;
}
function function_name_combine_multiple(parts) {
  let separator = function_name_separator();
  const combined = list_join(parts, separator);
  return combined;
}
function function_name_separator() {
  const separator = "_";
  return separator;
}
function list_join(list, separator) {
  let l = list_is(list);
  if (not(l)) {
    error_json({
      list
    });
  }
  let joined = list.join(separator);
  return joined;
}
function list_is(value) {
  const l = Array.isArray(value);
  return l;
}
function html_clear(element) {
  html_text_set(element, "");
}
function list_find_property(list, property_name, property_value) {
  let filter = property_equals_lambda(property_name, property_value);
  let item = list_find(list, filter);
  return item;
}
function property_equals_lambda(property_name, property_value) {
  let v2 = function object_property_equals_lambda_result(item) {
    let v = property_equals(item, property_name, property_value);
    return v;
  };
  return v2;
}
function property_equals(item, property_name, property_value) {
  let left = property_get(item, property_name);
  let eq = equal(left, property_value);
  return eq;
}
function list_find(list, lambda$item) {
  let filtered = list_filter(list, lambda$item);
  let found = list_single(filtered);
  return found;
}
function list_filter(list, lambda$item) {
  list_is_assert(list);
  function list_filter_lambda(item) {
    let match = lambda$item(item);
    return match;
  }
  let filtered = list.filter(list_filter_lambda);
  return filtered;
}
function list_is_assert(list) {
  function lambda() {
    let v = {
      list
    };
    return v;
  }
  list_is_assert_json(list, lambda);
}
function list_is_assert_json(list, lambda) {
  let result = list_is(list);
  assert_json_get(result, lambda);
}
function list_single(list) {
  list_size_1_assert(list);
  let only = list_first(list);
  return only;
}
function list_size_1_assert(list) {
  list_size_1_assert_message(list, {});
}
function list_size_1_assert_message(list, message) {
  list_size_assert_message(list, 1, message);
}
function list_size_assert_message(list, size, message) {
  let a = list_size(list) === size;
  if (not(a)) {
    error_json({
      message,
      list,
      size
    });
  }
}
function list_size(list) {
  list_is_assert(list);
  let size = list.length;
  return size;
}
function list_first(list) {
  const index = 0;
  const first = list_get(list, index);
  return first;
}
function list_get(list, index) {
  integer_is_assert(index);
  let item = list[index];
  undefined_not_is_assert_lambda(item, object_get);
  function object_get() {
    let v = {
      list,
      index
    };
    return v;
  }
  return item;
}
function integer_is_assert(index) {
  let ii = integer_is(index);
  assert_json(ii, {
    index
  });
}
function assert_json(b, o) {
  let message = json_to(o);
  assert_message(b, message);
}
function assert_message(b, message) {
  if (not(b)) {
    error(message);
  }
}
function integer_is(value) {
  let ii = Number.isInteger(value);
  return ii;
}
function app_replace_screens() {
  let s = [app_replace_home, app_replace_rule_set, app_replace_settings, app_replace_goals];
  return s;
}
function app_replace_goals(context) {
  let root = property_get(context, "root");
  app_replace_button_home(root, context);
  let item = app_replace_rule_set_get(context);
  let rule_name = property_get(item, "name");
  html_p_text(root, "Rule set: " + rule_name);
  let goals = property_get(item, "goals");
  let completed_previous = true;
  let d = app_replace_rule_sets_data_initialize(context);
  function each_item(goal, index) {
    let g = app_replace_rule_sets_data_goal(d, rule_name, goal);
    let completed = app_replace_goal_completed_initialize(g);
    let start = property_get(goal, "start");
    let left = text_split_empty(start);
    let end = property_get(goal, "end");
    let right = text_split_empty(end);
    let title = app_replace_goals_generic(root, completed, completed_previous, index, lambda);
    let r2 = app_replace_button_rule_content(title, left, right);
    app_replace_lefts_rights_style(r2, completed);
    function lambda() {
      on_click(index);
    }
    completed_previous = completed;
  }
  each_index(goals, each_item);
  function on_click(index) {
    storage_local_set_context(context, "goal_index", index);
    app_shared_screen_set(context, app_replace_rule_set);
  }
}
function app_replace_goals_generic(root, completed, completed_previous, index, lambda) {
  const choose_this_next = not(completed) && completed_previous;
  let text = add_1(index) + ".";
  if (completed) {
    let e = emoji_check();
    text += string_pad_left_space(e);
  } else {
    if (choose_this_next) {
      let e = emoji_point_right();
      text += string_pad_left_space(e);
    }
  }
  let b = app_replace_button_wide(root, "", lambda);
  app_replace_button_rule_style(b);
  let r = html_style_text_left_centered(b, text, "");
  let title = property_get(r, "title");
  html_style_set(title, "line-height", 1.5);
  let background = app_replace_rule_set_highlight();
  html_style_background_color_set_if(choose_this_next, b, background);
  return title;
}
function html_style_background_color_set_if(condition, component, background) {
  if (condition) {
    html_style_background_color_set(component, background);
  }
}
function html_style_background_color_set(component, background) {
  html_style_assign(component, {
    "background-color": background
  });
}
function html_style_assign(b, s) {
  let b_element = html_component_element_get(b);
  object_assign(b_element.style, s);
}
function object_assign(to, from) {
  Object.assign(to, from);
}
function app_replace_rule_set_highlight() {
  let r2 = "lightgreen";
  return r2;
}
function html_style_text_left_centered(component, text_left, text_centered) {
  html_style_assign(component, {
    display: "flex",
    "align-items": "center"
  });
  let n = html_span_text(component, text_left);
  let title = html_span_text(component, text_centered);
  html_style_assign(title, {
    "flex-grow": "1",
    "text-align": "center"
  });
  let r = {
    title
  };
  return r;
}
function html_span_text(parent, text) {
  let span = html_span(parent);
  html_text_set(span, text);
  return span;
}
function html_span(parent) {
  let component = html_element(parent, "span");
  return component;
}
function app_replace_button_rule_style(b) {
  app_replace_button_symbol_style(b);
  html_style_padding_y(b, "0.3em");
  html_border_none(b);
}
function html_border_none(b) {
  html_style_set(b, "border", "none");
}
function html_style_padding_y(component, value) {
  html_style_assign(component, {
    "padding-top": value,
    "padding-bottom": value
  });
}
function app_replace_button_symbol_style(b) {
  app_replace_button_symbol_style_inner(b);
  html_display_inline_block(b);
  html_style_assign(b, {
    "line-height": 1
  });
}
function app_replace_button_symbol_style_inner(b) {
  html_border_radius_em(b, 0.5);
  html_margin_em(b, 0.09);
  html_border_none(b);
  html_style_padding_x(b, "0.37em");
  html_style_padding_y(b, "0.1em");
}
function html_style_padding_x(component, value) {
  html_style_assign(component, {
    "padding-left": value,
    "padding-right": value
  });
}
function html_margin_em(component, margin) {
  let margin_em = margin + "em";
  html_margin(component, margin_em);
}
function html_margin(b, value) {
  html_style_margin_x(b, value);
  html_style_margin_y(b, value);
}
function html_style_margin_y(component, value) {
  html_style_assign(component, {
    "margin-top": value,
    "margin-bottom": value
  });
}
function html_style_margin_x(component, value) {
  html_style_assign(component, {
    "margin-left": value,
    "margin-right": value
  });
}
function html_border_radius_em(component, border_radius) {
  const border_radius_em = border_radius + "em";
  html_border_radius(component, border_radius_em);
}
function html_border_radius(component, border_radius) {
  html_style_assign(component, {
    "border-radius": border_radius
  });
}
function html_display_inline_block(item) {
  html_style_set(item, "display", "inline-block");
}
function app_replace_button_wide(root, name2, lambda) {
  let b = app_replace_button(root, name2, lambda);
  html_width_full(b);
  return b;
}
function html_width_full(component) {
  html_style_assign(component, {
    width: "100%"
  });
}
function app_replace_button(parent, text, lambda) {
  let b = html_button(parent, text, lambda);
  app_replace_button_style(b);
  html_style_padding_em(b, "0.3");
  return b;
}
function html_style_padding_em(p, value_em) {
  html_style_padding(p, value_em + "em");
}
function html_style_padding(component, value) {
  html_style_assign(component, {
    padding: value
  });
}
function app_replace_button_style(b) {
  app_replace_button_symbol_style(b);
  let c = app_replace_button_rule_background_color();
  html_style_background_color_set(b, c);
}
function app_replace_button_rule_background_color() {
  let c = "#dadadaff";
  return c;
}
function html_button(parent, text, lambda) {
  assert_arguments(arguments, 3);
  let component = html_button_notext(parent, lambda);
  html_text_set(component, text);
  return component;
}
function html_button_notext(parent, lambda) {
  let component = html_button_element(parent);
  html_on_click(component, lambda);
  return component;
}
function html_on_click(component, lambda) {
  const name_event = "click";
  html_on(component, name_event, lambda);
}
function html_on(component, name_event, lambda) {
  function_is_assert(lambda);
  let element = html_component_element_get(component);
  element.addEventListener(name_event, lambda);
}
function function_is_assert(lambda) {
  let fi = function_is(lambda);
  assert_json(fi, {
    lambda
  });
}
function function_is(f) {
  let fi = typeof f === "function";
  return fi;
}
function html_button_element(parent) {
  const tag_name = "button";
  let b = html_element(parent, tag_name);
  html_style_font_size_inherit(b);
  return b;
}
function html_style_font_size_inherit(component) {
  html_style_font_size(component, "inherit");
}
function emoji_point_right() {
  let r = "üëâ";
  return r;
}
function string_pad_left_space(e) {
  let r3 = " " + e;
  return r3;
}
function emoji_check() {
  let e = "‚úÖ";
  return e;
}
function add_1(left) {
  let a = add(left, 1);
  return a;
}
function add(left, right) {
  const sum = left + right;
  return sum;
}
function app_replace_goal_completed_initialize(g) {
  let value = property_get_or(g, "completed", false);
  return value;
}
function property_get_or(obj, key, value_not) {
  let value = value_not;
  let exists = property_exists(obj, key);
  if (exists) {
    value = property_get(obj, key);
  }
  return value;
}
function app_replace_rule_sets_data_initialize(context) {
  let value = storage_local_initialize_context(context, "rule_sets_data", {});
  return value;
}
function app_replace_button_home(root, context) {
  let b = app_replace_button_screen(context, app_replace_home, root, emoji_home() + " Home");
}
function app_replace_home(context) {
  let root = property_get(context, "root");
  function lambda4() {
    app_shared_screen_set(context, app_replace_settings);
  }
  app_replace_button_wide(root, emoji_gear() + " Settings", lambda4);
  let d = app_replace_rule_sets_data_initialize(context);
  let rule_sets = app_replace_rule_sets();
  let completed_previous = true;
  function each_item(item, index2) {
    let rule_name = property_get(item, "name");
    let goals = property_get(item, "goals");
    function lambda2(goal) {
      let g = app_replace_rule_sets_data_goal(d, rule_name, goal);
      let value = app_replace_goal_completed_initialize(g);
      return value;
    }
    let completed_all = list_all(goals, lambda2);
    let title = app_replace_goals_generic(root, completed_all, completed_previous, index2, lambda);
    html_text_set(title, rule_name);
    function lambda() {
      on_click(index2);
    }
    completed_previous = completed_all;
  }
  each_index(rule_sets, each_item);
  function on_click(index) {
    storage_local_set_context(context, "rule_set_index", index);
    app_shared_screen_set(context, app_replace_goals);
  }
}
function app_replace_rule_sets_data_goal(value, rule_name, goal) {
  let r = property_initialize_empty(value, rule_name);
  let json = json_to(goal);
  let g = property_initialize_empty(r, json);
  return g;
}
function property_initialize_empty(object, property_name) {
  let value2 = property_initialize(object, property_name, {});
  return value2;
}
function property_initialize(object, property_name, value_initial) {
  const exists = property_exists(object, property_name);
  if (not(exists)) {
    property_set(object, property_name, value_initial);
  }
  let value = property_get(object, property_name);
  return value;
}
function list_all(list, lambda$item) {
  let list2 = list_filter(list, lambda$item);
  let a = list_size(list2) === list_size(list);
  return a;
}
function each_index(list, lambda$item$index) {
  let index = 0;
  function lambda_each_index(item) {
    lambda$item$index(item, index);
    index++;
  }
  each(list, lambda_each_index);
}
function app_replace_settings(context) {
  let root = property_get(context, "root");
  app_replace_button_home(root, context);
  const factor = app_replace_font_size_factor();
  let value_get_multiply = multiply_curried_right(factor);
  let value_get_divide = divide_curried_right(factor);
  let c = app_replace_font_size_adjust_curried(context);
  async function lambda2() {
    await c(value_get_multiply);
  }
  html_button(root, emoji_font_larger() + " Font size larger", lambda2);
  async function lambda3() {
    await c(value_get_divide);
  }
  let component = html_button(root, emoji_font_smaller() + " Font size smaller", lambda3);
}
function app_replace_font_size_adjust_curried(context) {
  let r2 = async function app_replace_font_size_adjust_curried_result(value_get) {
    let r = await app_replace_font_size_adjust(context, value_get);
    return r;
  };
  return r2;
}
async function app_replace_font_size_adjust(context, value_get) {
  let value = await app_replace_font_size(context);
  value = value_get(value);
  storage_local_set_context(context, "font_size", value);
  app_replace_font_size_refresh(context);
}
function storage_local_set_context(context, key, value) {
  let {app_fn} = context;
  storage_local_set(app_fn, key, value);
}
function multiply_curried_right(right) {
  let r = function multiply_curried_right_result(left) {
    let p = multiply(left, right);
    return p;
  };
  return r;
}
function multiply(left, right) {
  const p = left * right;
  return p;
}
function divide_curried_right(bottom) {
  let r = function divide_curried_right_result(top) {
    let r2 = divide(top, bottom);
    return r2;
  };
  return r;
}
function divide(top, bottom) {
  let r2 = top / bottom;
  return r2;
}
function app_replace_font_size_factor() {
  let v = 1.1;
  return v;
}
function emoji_font_smaller() {
  let v = "üóõ";
  return v;
}
function emoji_font_larger() {
  let v = "üóö";
  return v;
}
function emoji_gear() {
  let v = "‚öôÔ∏è";
  return v;
}
function app_shared_screen_set(context, fn) {
  let fn_name = property_get(fn, "name");
  app_shared_refresh_screen(context, fn_name);
}
function fn_name(f_name) {
  return f_name;
}
function app_shared_refresh_screen(context, without) {
  storage_local_set_context(context, "screen", without);
  app_shared_refresh(context);
}
function app_replace_rule_sets() {
  let r = app_replace_rule_sets_fns();
  let mapped = invoke_multiple(r);
  return mapped;
}
function invoke_multiple(list_fns) {
  let mapped = list_map(list_fns, invoke);
  return mapped;
}
function list_map(list, lambda$item) {
  list_is_assert(list);
  let mapped = list.map(lambda$item);
  return mapped;
}
function invoke(lambda) {
  let r = lambda();
  return r;
}
function app_replace_rule_sets_fns() {
  let r2 = [app_replace_rule_set_replace, app_replace_rule_set_grow_different, app_replace_rule_set_shrink_different, app_replace_rule_set_double, app_replace_rule_set_half, app_replace_rule_set_grow_right, app_replace_rule_set_grow_left, app_replace_rule_set_shrink_right, app_replace_rule_set_shrink_left, app_replace_rule_set_swap, app_replace_rule_set_same_replace_right, app_replace_rule_set_same_replace_left, app_replace_rule_set_replace_right_same, app_replace_rule_set_replace_left_same, app_replace_rule_set_right_change, app_replace_rule_set_swap_change_right, app_replace_rule_set_swap_change_left, app_replace_rule_set_grow_triple, app_replace_rule_set_shrink_triple, app_replace_rule_set_unary_equations, app_replace_rule_set_shrink_both_same, app_replace_rule_set_grow_between, app_replace_rule_set_shrink_between, app_replace_rule_set_replace_2, app_replace_rule_set_replace_flow, app_replace_rule_set_grow_different_2, app_replace_rule_set_shrink_different_2, app_replace_rule_set_expand_collapse, app_replace_rule_set_grow_left_pair_change_right, app_replace_rule_set_shrink_left_pair_replace_right_same, app_replace_rule_set_unary_equations_adding, app_replace_rule_set_binary_counting_prepare_1, app_replace_rule_set_binary_counting_prepare_2, app_replace_rule_set_binary_counting, app_replace_rule_set_three_different_grow_same, app_replace_rule_set_shrink_same_three_different, app_replace_rule_set_two_different_grow_same, app_replace_rule_set_grow_same_three_different, app_replace_rule_set_unary_to_binary_equations_preparation, app_replace_rule_set_unary_to_binary_equations];
  return r2;
}
function app_replace_rule_set_unary_to_binary_equations() {
  let r = {
    name: "Unary to Binary Equations",
    rules: ["e = b > c e = b c", "c c > c + b c", "d b > b d", "d c > a d", "d e = > = d", "d + > + d", "0 a > 1", "1 a > a 0", "b a > b 1"],
    goals: [{
      start: "dbce=bc",
      end: "bdce=bc"
    }, {
      start: "dbce=bc",
      end: "bade=bc"
    }, {
      start: "dbce=bc",
      end: "b1de=bc"
    }, {
      start: "dbce=bc",
      end: "b1=dbc"
    }, {
      start: "dbce=bc",
      end: "b1=bdc"
    }, {
      start: "dbce=bc",
      end: "b1=bad"
    }, {
      start: "dbce=bc",
      end: "b1=b1d"
    }]
  };
  return r;
}
function app_replace_rule_set_unary_to_binary_equations_preparation() {
  let r = {
    name: "Unary to Binary Equations Preparation",
    rules: ["d e = > = d", "= d > d f =", "d > d d", "d d > d e d", "e d > e ="],
    goals: [{
      start: "d",
      end: "dd"
    }, {
      start: "d",
      end: "ded"
    }, {
      start: "d",
      end: "de="
    }, {
      start: "de=",
      end: "=d"
    }, {
      start: "de=",
      end: "df="
    }, {
      start: "de=",
      end: "ddf="
    }, {
      start: "de=",
      end: "dedf="
    }, {
      start: "de=",
      end: "df=f="
    }]
  };
  return r;
}
function app_replace_rule_set_grow_same_three_different() {
  let r = {
    name: "Grow Same Three Different",
    rules: ["c e b c > e b"],
    goals: [{
      start: "cce=bcc",
      end: "e=b"
    }, {
      start: "cccce=bcccc",
      end: "e=b"
    }]
  };
  return r;
}
function app_replace_rule_set_two_different_grow_same() {
  let r = {
    name: "Two Different Grow Same",
    rules: ["e b > c e b c"],
    goals: [{
      start: "eb",
      end: "ccebcc"
    }, {
      start: "eb",
      end: "ccccebcccc"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_same_three_different() {
  let r = {
    name: "Shrink Same Three Different",
    rules: ["c e = b c > e = b"],
    goals: [{
      start: "cce=bcc",
      end: "e=b"
    }, {
      start: "cccce=bcccc",
      end: "e=b"
    }]
  };
  return r;
}
function app_replace_rule_set_three_different_grow_same() {
  let r = {
    name: "Three Different Grow Same",
    rules: ["e = b > c e = b c"],
    goals: [{
      start: "e=b",
      end: "cce=bcc"
    }, {
      start: "e=b",
      end: "cccce=bcccc"
    }]
  };
  return r;
}
function app_replace_rule_set_binary_counting() {
  let r = {
    name: "Binary Counting",
    rules: ["0 a > 1", "1 a > a 0", "c > a c", "b a > b 1"],
    goals: [{
      start: "b0c",
      end: "b0ac"
    }, {
      start: "b0c",
      end: "b1c"
    }, {
      start: "b0c",
      end: "b10c"
    }, {
      start: "b0c",
      end: "b11c"
    }, {
      start: "b0c",
      end: "b101c"
    }, {
      start: "b0c",
      end: "b111c"
    }, {
      start: "b0c",
      end: "b1010c"
    }]
  };
  return r;
}
function app_replace_rule_set_binary_counting_prepare_2() {
  let r = {
    name: "Binary Counting Prepare 2",
    rules: ["0 a > 1", "1 a > a 0", "1 > 1 1"],
    goals: [{
      start: "01a",
      end: "10"
    }, {
      start: "01a",
      end: "100"
    }, {
      start: "01a",
      end: "10000"
    }]
  };
  return r;
}
function app_replace_rule_set_binary_counting_prepare_1() {
  let r = {
    name: "Binary Counting Prepare 1",
    rules: ["1 a > a 0", "1 > 1 1"],
    goals: [{
      start: "1a",
      end: "1a0"
    }, {
      start: "1a",
      end: "a000"
    }]
  };
  return r;
}
function app_replace_rule_set_unary_equations_adding() {
  let r = {
    name: "Unary Equations Adding",
    rules: ["= > 1 = 1", "1 1 > 1 + 1"],
    goals: [{
      start: "1=1",
      end: "11=11"
    }, {
      start: "1=1",
      end: "11=1+1"
    }, {
      start: "1=1",
      end: "1+1=11"
    }, {
      start: "1=1",
      end: "1+11=111"
    }, {
      start: "1=1",
      end: "1+11=11+1"
    }, {
      start: "1=1",
      end: "1+1+111=11111"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_left_pair_replace_right_same() {
  let r = {
    name: "Shrink Left Pair Replace Right Same",
    rules: ["b a > a", "b c > b b"],
    goals: [{
      start: "baba",
      end: "aa"
    }, {
      start: "bba",
      end: "a"
    }, {
      start: "cca",
      end: "bba"
    }, {
      start: "bbba",
      end: "a"
    }, {
      start: "bcbca",
      end: "a"
    }, {
      start: "bcbabcba",
      end: "aa"
    }]
  };
  return r;
}
function app_replace_rule_set_grow_left_pair_change_right() {
  let r = {
    name: "Grow Left Pair Change Right",
    rules: ["a > b a", "b b > b c"],
    goals: [{
      start: "aa",
      end: "baba"
    }, {
      start: "a",
      end: "bba"
    }, {
      start: "bba",
      end: "cca"
    }, {
      start: "a",
      end: "bbba"
    }, {
      start: "a",
      end: "bcbca"
    }, {
      start: "aa",
      end: "bcbabcba"
    }]
  };
  return r;
}
function app_replace_rule_set_expand_collapse() {
  let r = {
    name: "Expand Collapse",
    rules: ["a > b b", "b b > c"],
    goals: [{
      start: "a",
      end: "c"
    }, {
      start: "aa",
      end: "cc"
    }, {
      start: "bab",
      end: "cc"
    }, {
      start: "aa",
      end: "bcb"
    }, {
      start: "aaa",
      end: "bccb"
    }, {
      start: "aaaaa",
      end: "acbbca"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_different_2() {
  let r = {
    name: "Shrink Different 2",
    rules: ["b c > a", "d e > b"],
    goals: [{
      start: "dec",
      end: "a"
    }, {
      start: "decdec",
      end: "aa"
    }, {
      start: "decbcbcdec",
      end: "aaaa"
    }]
  };
  return r;
}
function app_replace_rule_set_grow_different_2() {
  let r = {
    name: "Grow Different 2",
    rules: ["a > b c", "b > d e"],
    goals: [{
      start: "a",
      end: "dec"
    }, {
      start: "aa",
      end: "decdec"
    }, {
      start: "aaaa",
      end: "decbcbcdec"
    }]
  };
  return r;
}
function app_replace_rule_set_replace_flow() {
  let r = {
    name: "Replace Flow",
    rules: ["a > b", "b > c"],
    goals: [{
      start: "ab",
      end: "cc"
    }, {
      start: "acb",
      end: "ccc"
    }, {
      start: "cabadc",
      end: "ccbcdc"
    }, {
      start: "caaaaac",
      end: "ccabccc"
    }]
  };
  return r;
}
function app_replace_rule_set_replace_2() {
  let r = {
    name: "Replace 2",
    rules: ["a > b", "c > d"],
    goals: [{
      start: "ac",
      end: "bd"
    }, {
      start: "aca",
      end: "bdb"
    }, {
      start: "cabacd",
      end: "dbbbdd"
    }, {
      start: "caaaaac",
      end: "dbababd"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_between() {
  let r = {
    name: "Shrink Between",
    rules: ["a b a > a a"],
    goals: [{
      start: "aaaba",
      end: "aaa"
    }, {
      start: "abaaaba",
      end: "aaaa"
    }, {
      start: "abaabaaba",
      end: "aaaaaa"
    }]
  };
  return r;
}
function app_replace_rule_set_grow_between() {
  let r = {
    name: "Grow Between",
    rules: ["a a > a b a"],
    goals: [{
      start: "aaa",
      end: "aaaba"
    }, {
      start: "aaaa",
      end: "abaaaba"
    }, {
      start: "aaaaaa",
      end: "abaabaaba"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_both_same() {
  let r = {
    name: "Shrink Both Same",
    rules: ["a b a > b"],
    goals: [{
      end: "cabac",
      start: "cbc"
    }, {
      end: "aaabaaa",
      start: "aba"
    }, {
      end: "aaaaabaaaaa",
      start: "aba"
    }]
  };
  return r;
}
function app_replace_rule_set_unary_equations() {
  let r = {
    name: "Unary Equations",
    rules: ["= > 1 = 1"],
    goals: [{
      start: "1=1",
      end: "11=11"
    }, {
      start: "1=1",
      end: "111=111"
    }, {
      start: "1=1",
      end: "11111=11111"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_triple() {
  let r = {
    name: "Shrink Triple",
    rules: ["a a a > a"],
    goals: [{
      start: "aaa",
      end: "a"
    }, {
      start: "aaaaa",
      end: "a"
    }, {
      start: "aaaaaaa",
      end: "a"
    }]
  };
  return r;
}
function app_replace_rule_set_grow_triple() {
  let r = {
    name: "Grow Triple",
    rules: ["a > a a a"],
    goals: [{
      start: "a",
      end: "aaa"
    }, {
      start: "a",
      end: "aaaaa"
    }, {
      start: "a",
      end: "aaaaaaa"
    }]
  };
  return r;
}
function app_replace_rule_set_swap_change_left() {
  let r = {
    name: "Swap Change Left",
    rules: ["b c > a b"],
    goals: [{
      start: "bcc",
      end: "aab"
    }, {
      start: "bcbcbc",
      end: "bcbcab"
    }, {
      start: "bcbcabbc",
      end: "abababab"
    }, {
      start: "bcccc",
      end: "aaaab"
    }, {
      start: "abbcabbcbcbc",
      end: "abababababab"
    }]
  };
  return r;
}
function app_replace_rule_set_swap_change_right() {
  let r = {
    name: "Swap Change Right",
    rules: ["a b > b c"],
    goals: [{
      start: "aab",
      end: "bcc"
    }, {
      start: "ababab",
      end: "ababbc"
    }, {
      start: "abababab",
      end: "bcbcabbc"
    }, {
      start: "aaaab",
      end: "bcccc"
    }, {
      start: "abababababab",
      end: "abbcabbcbcbc"
    }]
  };
  return r;
}
function app_replace_rule_set_right_change() {
  let r = {
    name: "Right Change",
    rules: ["a b > a c"],
    goals: [{
      start: "ababab",
      end: "ababac"
    }, {
      start: "ababab",
      end: "acabac"
    }, {
      start: "abaabaaabaaaab",
      end: "acaacaaacaaaac"
    }]
  };
  return r;
}
function app_replace_rule_set_replace_left_same() {
  let r = {
    name: "Replace Left Same",
    rules: ["b a > a a"],
    goals: [{
      start: "bababa",
      end: "baaaba"
    }, {
      start: "baba",
      end: "aaaa"
    }, {
      start: "baabaaba",
      end: "aaaaaaaa"
    }]
  };
  return r;
}
function app_replace_rule_set_replace_right_same() {
  let r = {
    name: "Replace Right Same",
    rules: ["a b > a a"],
    goals: [{
      start: "ababab",
      end: "abaaab"
    }, {
      start: "abab",
      end: "aaaa"
    }, {
      start: "abaabaab",
      end: "aaaaaaaa"
    }]
  };
  return r;
}
function app_replace_rule_set_same_replace_left() {
  let r = {
    name: "Same Replace Left",
    rules: ["a a > b a"],
    goals: [{
      start: "aaaa",
      end: "abaa"
    }, {
      start: "aaaa",
      end: "baba"
    }, {
      start: "aaaaaaaa",
      end: "baabaaba"
    }]
  };
  return r;
}
function app_replace_rule_set_same_replace_right() {
  let r = {
    name: "Same Replace Right",
    rules: ["a a > a b"],
    goals: [{
      start: "aaaa",
      end: "aaba"
    }, {
      start: "aaaa",
      end: "abab"
    }, {
      start: "aaaaaaaa",
      end: "abaabaab"
    }]
  };
  return r;
}
function app_replace_rule_set_swap() {
  let r = {
    name: "Swap",
    rules: ["a b > b a"],
    goals: [{
      start: "abb",
      end: "bba"
    }, {
      start: "abbbb",
      end: "bbbba"
    }, {
      start: "abbabb",
      end: "bbbbaa"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_left() {
  let r = {
    name: "Shrink left",
    rules: ["b a > a"],
    goals: [{
      start: "bba",
      end: "a"
    }, {
      start: "babba",
      end: "aa"
    }, {
      start: "bbbabba",
      end: "aa"
    }, {
      start: "bbbabbaba",
      end: "aaa"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_right() {
  let r = {
    name: "Shrink right",
    rules: ["a b > a"],
    goals: [{
      start: "abb",
      end: "a"
    }, {
      start: "abbab",
      end: "aa"
    }, {
      start: "abbabbb",
      end: "aa"
    }, {
      start: "ababbabbb",
      end: "aaa"
    }]
  };
  return r;
}
function app_replace_rule_set_grow_left() {
  let r = {
    name: "Grow left",
    rules: ["a > b a"],
    goals: [{
      start: "a",
      end: "bba"
    }, {
      start: "aa",
      end: "babba"
    }, {
      start: "aa",
      end: "bbbabba"
    }, {
      start: "aaa",
      end: "bbbabbaba"
    }]
  };
  return r;
}
function app_replace_rule_set_grow_right() {
  let r = {
    name: "Grow right",
    rules: ["a > a b"],
    goals: [{
      start: "a",
      end: "abb"
    }, {
      start: "aa",
      end: "abbab"
    }, {
      start: "aa",
      end: "abbabbb"
    }, {
      start: "aaa",
      end: "ababbabbb"
    }]
  };
  return r;
}
function app_replace_rule_set_half() {
  let r = {
    name: "Half",
    rules: ["a a > a"],
    goals: [{
      start: "aa",
      end: "a"
    }, {
      start: "aaa",
      end: "a"
    }, {
      start: "aaaaa",
      end: "a"
    }]
  };
  return r;
}
function app_replace_rule_set_double() {
  let r = {
    name: "Double",
    rules: ["a > a a"],
    goals: [{
      start: "a",
      end: "aa"
    }, {
      start: "a",
      end: "aaa"
    }, {
      start: "a",
      end: "aaaaa"
    }]
  };
  return r;
}
function app_replace_rule_set_shrink_different() {
  let r = {
    name: "Shrink Different",
    rules: ["b c > a"],
    goals: [{
      start: "bc",
      end: "a"
    }, {
      start: "bcbc",
      end: "aa"
    }, {
      start: "bcbcbcbc",
      end: "aaaa"
    }]
  };
  return r;
}
function app_replace_rule_set_grow_different() {
  let r = {
    name: "Grow Different",
    rules: ["a > b c"],
    goals: [{
      start: "a",
      end: "bc"
    }, {
      start: "aa",
      end: "bcbc"
    }, {
      start: "aaaa",
      end: "bcbcbcbc"
    }]
  };
  return r;
}
function app_replace_rule_set_replace() {
  let r = {
    name: "Replace",
    rules: ["a > b"],
    goals: [{
      start: "a",
      end: "b"
    }, {
      start: "aa",
      end: "bb"
    }, {
      start: "aaa",
      end: "bbb"
    }, {
      start: "aaaa",
      end: "abba"
    }, {
      start: "aaaaaaa",
      end: "abababa"
    }]
  };
  return r;
}
function emoji_home() {
  let v = "üè†";
  return v;
}
function app_replace_button_screen(context, screen_fn, parent, text) {
  function lambda2() {
    app_shared_screen_set(context, screen_fn);
  }
  let b2 = app_replace_button(parent, text, lambda2);
}
function app_replace_lefts_rights_style(rb, enabled) {
  let properties = ["rights", "lefts"];
  let list = list_map_property_get(properties, rb);
  let lambda4 = app_replace_button_symbol_style_valid_if_curried_right(enabled);
  each_nested(list, lambda4);
}
function each_nested(list, lambda$item) {
  let r2 = each_curried_right(lambda$item);
  each(list, r2);
}
function each_curried_right(lambda$item) {
  let r2 = function each_curried_right_result(list) {
    let r = each(list, lambda$item);
    return r;
  };
  return r2;
}
function app_replace_button_symbol_style_valid_if_curried_right(valid) {
  let lambda = function app_replace_button_symbol_style_valid_curried_result(sb) {
    let r = app_replace_button_symbol_style_valid_if(sb, valid);
    return r;
  };
  return lambda;
}
function app_replace_button_symbol_style_valid_if(sb, valid) {
  html_enable_if(sb, valid);
  html_style_background_color_set_if_else(valid, sb, "#00b400ff", "#1e6c1eff");
  html_style_font_color_set_if(valid, sb, "white", "#b9fcb9ff");
  let h = app_replace_rule_set_highlight();
  app_replace_button_symbol_style_box_shadow(valid, sb, h);
}
function app_replace_button_symbol_style_box_shadow(valid, sb, h) {
  html_style_set_or_remove(valid, sb, "box-shadow", " 0 0 0 " + "0.1em" + " " + h);
}
function html_style_set_or_remove(condition, component, style_key, style_value) {
  if (condition) {
    html_style_set(component, style_key, style_value);
  } else {
    html_style_remove(component, style_key);
  }
}
function html_style_remove(b, style_key) {
  let b_element = html_component_element_get(b);
  b_element.style.removeProperty(style_key);
}
function html_style_background_color_set_if_else(condition, component, color_if, color_else) {
  let c = ternary(condition, color_if, color_else);
  html_style_background_color_set(component, c);
}
function ternary(condition, on_true, on_false) {
  let result = null;
  if (condition) {
    result = on_true;
  } else {
    result = on_false;
  }
  return result;
}
function html_style_font_color_set_if(condition, component, color_if, color_else) {
  let c = ternary(condition, color_if, color_else);
  html_font_color_set(component, c);
}
function html_font_color_set(component, color) {
  html_style_set(component, "color", color);
}
function html_enable_if(component, condition) {
  let fn = null;
  fn = ternary(condition, html_enable, html_disable);
  fn(component);
}
function html_disable(b) {
  const disabled = true;
  html_disable_set(b, disabled);
}
function html_disable_set(b, disabled) {
  let b_element = html_component_element_get(b);
  property_set(b_element, "disabled", disabled);
}
function html_enable(b) {
  const disabled = false;
  html_disable_set(b, disabled);
}
function list_map_property_get(lilst, object) {
  let c = property_get_curried(object);
  let mapped = list_map(lilst, c);
  return mapped;
}
function property_get_curried(object) {
  let r = function property_get_curried_result(property_name) {
    let value = property_get(object, property_name);
    return value;
  };
  return r;
}
function app_replace_button_rule_content(parent, left, right) {
  let lefts = app_replace_button_side(parent, left);
  let s = text_arrow();
  let text = text_pad_space(s);
  let arrow = html_span_text(parent, text);
  html_bold(arrow);
  let rights = app_replace_button_side(parent, right);
  let r = {
    lefts,
    rights,
    arrow
  };
  return r;
}
function html_bold(b) {
  html_style_set(b, "font-weight", "bold");
}
function text_pad_space(s) {
  let padded = text_pad(s, " ");
  return padded;
}
function text_pad(s, padding) {
  const padded = padding + s + padding;
  return padded;
}
function text_arrow() {
  let r2 = "‚ûú";
  return r2;
}
function app_replace_button_side(parent, list_symbols) {
  function symbol_each(symbol) {
    let span = html_span_text(parent, symbol);
    app_replace_button_symbol_style(span);
    return span;
  }
  let mapped = list_map(list_symbols, symbol_each);
  return mapped;
}
async function app_replace_rule_set(context) {
  let root = property_get(context, "root");
  app_replace_button_home(root, context);
  app_replace_button_screen(context, app_replace_goals, root, "Goals");
  app_replace_button_screen(context, app_replace_rule_set, root, "Start over");
  let rule = app_replace_rule_set_get(context);
  let rule_name = property_get(rule, "name");
  html_p_text(root, "Rule set: " + rule_name);
  let goal_index = storage_local_get_context(context, "goal_index");
  let goals = property_get(rule, "goals");
  let goal = list_get(goals, goal_index);
  let start = property_get(goal, "start");
  if (false) {
    "not sure if this is needed or not";
    let current = storage_local_initialize_context(context, "rule_set_start", start);
  }
  let index_selected = null;
  let label_rules = html_p(root);
  let rules = property_get(rule, "rules");
  let rules_parsed = list_map(rules, app_replace_rule_parse);
  let symbols_invalid_chosen = {};
  let div_rules_buttons = html_div(root);
  let label_symbols = html_p(root);
  let div_refresh = html_div(root);
  let current_list = text_split_empty(start);
  let label_goal = html_p_text(root, "Goal:");
  let end = property_get(goal, "end");
  let goal_list = text_split_empty(end);
  let p_goal = html_p(root);
  let goal_list_symbols = app_replace_button_side(p_goal, goal_list);
  let lambda4 = app_replace_button_symbol_style_valid_if_curried_right(false);
  each(goal_list_symbols, lambda4);
  let highlight = app_replace_rule_set_highlight();
  let div_below = html_div(root);
  let success = false;
  const duration = 555;
  refresh();
  async function refresh() {
    html_clear(div_rules_buttons);
    function each_rule(rule, index) {
      let left = property_get(rule, "left");
      let right = property_get(rule, "right");
      function lambda3() {
        symbols_invalid_chosen = {};
        index_selected = ternary(index_selected === index, null, index);
        refresh();
        return;
      }
      let r2 = app_replace_button_rule(div_rules_buttons, left, right, lambda3);
      let arrow = property_get(r2, "arrow");
      let rights = property_get(r2, "rights");
      let lefts = property_get(r2, "lefts");
      let rb = property_get(r2, "b");
      html_disable(rb);
      object_merge(rb, {
        rule,
        lefts,
        rights,
        arrow
      });
      return rb;
    }
    let rules_buttons = list_map_index(rules_parsed, each_rule);
    function each_button_rule_refresh(rb, index2) {
      let rule2 = property_get(rb, "rule");
      let size2 = list_size(current_list);
      let r = range(size2);
      let lambda7 = app_replace_rule_valid_curried(rule2, current_list);
      let enabled = list_any(r, lambda7);
      const selected = index2 === index_selected;
      enabled = index_selected === null || selected;
      enabled = true;
      html_enable_if(rb, enabled);
      app_replace_lefts_rights_style(rb, enabled);
      let on_b = app_replace_button_rule_background_color();
      let c = ternary_nested(selected, highlight, enabled, on_b, "#a8a8a8ff");
      html_style_background_color_set(rb, c);
      let arrow2 = property_get(rb, "arrow");
      html_style_font_color_set_if(enabled, arrow2, "black", "#6a6a6a");
    }
    each_index(rules_buttons, each_button_rule_refresh);
    html_clear(div_refresh);
    let div_symbols = html_div(div_refresh);
    let sbs = null;
    function symbols_mapper(symbol, index) {
      let sb = null;
      async function symbol_on_click() {
        let rule2 = list_get(rules_parsed, index_selected);
        let eq = app_replace_rule_valid(rule2, index, current_list);
        if (eq) {
          symbols_invalid_chosen = {};
          app_replace_button_symbol_style_valid_if_multiple(sbs, true);
          let right = property_get(rule2, "right");
          let left = property_get(rule2, "left");
          let before = list_take(current_list, index);
          let size = list_size(left);
          let after = list_skip(current_list, index + size);
          current_list = list_concat_multiple([before, right, after]);
          let rb = list_get(rules_buttons, index_selected);
          let lefts2 = property_get(rb, "lefts");
          let rights2 = property_get(rb, "rights");
          let size3 = list_size(lefts2);
          let sliced2 = list_slice_count(sbs, index, size3);
          const sum = index + size3;
          let skipped = list_skip(sbs, sum);
          let rects_before = list_map(skipped, html_bounding_client_rect);
          await html_move_animate_multiple_parent_remove(sliced2, lefts2, duration);
          await html_request_animation_frame();
          let rights_cloned = list_map(rights2, html_clone);
          function lambda8(item, index5) {
            html_visibility_hidden(item);
            html_insert(div_symbols, item, index + index5);
          }
          each_index(rights_cloned, lambda8);
          let rects_after = list_map(skipped, html_bounding_client_rect);
          async function lambda9([el, rect_before, rect_after]) {
            await html_move_animate_rect(el, rect_before, rect_after, 0);
            el.offsetWidth;
            await html_request_animation_frame();
            await html_move_animate_translate(el, 0, 0, duration);
            await sleep(duration);
            html_translation_transition_clear(el);
          }
          let mapped2 = lists_map([skipped, rects_after, rects_before], lambda9);
          await list_wait(mapped2);
          await html_move_animate_multiple(rights2, rights_cloned, duration);
          if (false) {
            let rights_cloneds2 = list_map(rights2, html_clone);
            html_display_none_multiple(rights_cloneds2);
            html_parent_append_multiple(div_refresh, rights_cloneds2);
            html_display_inline_block_multiple(rights_cloneds2);
            let rights_cloned2_rects = list_map_html_bounding_client_rect(rights_cloneds2);
            let rights2_rects = list_map_html_bounding_client_rect(rights2);
            return;
            async function lambda6([rights_cloned2, rights_cloned2_rect, rights2_rect]) {
              await html_move_animate_rect(rights_cloned2, rights_cloned2_rect, rights2_rect, duration);
            }
            let mapped3 = lists_map([rights_cloneds2, rights_cloned2_rects, rights2_rects], lambda6);
            await list_wait(mapped3);
            log({
              rights_cloned2: rights_cloneds2
            });
            return;
            await html_move_animate_multiple(rights_cloneds2, rights_cloned, duration);
          }
          index_selected = null;
        } else {
          property_set(symbols_invalid_chosen, index, true);
        }
        refresh();
      }
      sb = html_button(div_symbols, symbol, symbol_on_click);
      app_replace_button_symbol_style(sb);
      property_set_exists_not(sb, "index", index);
      let valid = false;
      let nn2 = null_not_is(index_selected);
      if (nn2) {
        let index3 = property_get(sb, "index");
        let rule2 = list_get(rules_parsed, index_selected);
        valid = app_replace_rule_valid(rule2, index3, current_list);
      }
      app_replace_button_symbol_style_valid_if(sb, index_selected !== null);
      let exists = property_exists(symbols_invalid_chosen, index);
      if (exists) {
        app_replace_button_symbol_style_invalid(sb);
      }
      return sb;
    }
    sbs = list_map_index(current_list, symbols_mapper);
    "no success yet?";
    if (not(success)) {
      "goal satisfied?";
      let eq2 = json_equal(current_list, goal_list);
      if (eq2) {
        success = true;
        function lambda5(value) {
          let g = app_replace_rule_sets_data_goal(value, rule_name, goal);
          property_set(g, "completed", true);
          return value;
        }
        storage_local_transform_empty_context(context, "rule_sets_data", lambda5);
        const list = [goal_list_symbols, sbs];
        app_replace_button_symbol_style_valid_multiple_nested(list);
        await html_move_animate_multiple(sbs, goal_list_symbols, duration);
        symbols_hide_on_success();
        let choices = [emoji_trophy, emoji_100, emoji_clap, emoji_medal_star, emoji_medal_1, emoji_party_popper, emoji_party_face];
        const taken_count = 3;
        let taken = list_shuffle_take(choices, taken_count);
        list_add_first(taken, emoji_check);
        let mapped = list_invoke(taken);
        let joined = list_join_empty(mapped);
        let p = html_p(div_below);
        html_style_background_color_set(p, highlight);
        app_replace_button_symbol_style_inner(p);
        const value_em = "0.3";
        html_style_padding_em(p, value_em);
        html_centered(p);
        let p_emojis = html_div(p);
        html_span_text(p_emojis, joined);
        html_style_font_size(p_emojis, "1.5em");
        let p_encouragement = html_div(p);
        const encouragements_choices = ["Congratulations", "Success", "Good job", "Great job", "Well done", "Keep it up", "Amazing", "Way to go", "Awesome"];
        let encouragements = list_shuffle_take(encouragements_choices, 2);
        html_bold(p_encouragement);
        function lambda(encouragement) {
          html_span_text(p_encouragement, encouragement + "! ");
        }
        each(encouragements, lambda);
        let p_next = html_p(div_below);
        let goal_index_next = goal_index + 1;
        let ii = list_index_is(goals, goal_index_next);
        let rule_set_index = storage_local_get_context(context, "rule_set_index");
        let rule_sets = app_replace_rule_sets();
        let rule_set_index_next = rule_set_index + 1;
        let ii2 = list_index_is(rule_sets, rule_set_index_next);
        let next = true;
        if (not(ii) && not(ii2)) {
          html_p_text_centered(p_next, "You have completed all goals that are available at this time!");
        }
        function lambda2() {
          if (ii) {
            storage_local_set_context(context, "goal_index", goal_index_next);
          } else {
            if (ii2) {
              storage_local_set_context(context, "rule_set_index", rule_set_index_next);
              storage_local_set_context(context, "goal_index", 0);
            } else {
              next = false;
            }
          }
          app_shared_screen_set(context, app_replace_rule_set);
        }
        let text = app_karate_button_next_text();
        let bn = app_replace_button(p_next, text, lambda2);
        html_width_full(bn);
      }
      let nn = null_not_is(index_selected);
      html_text_set_if(nn, "Rules:", "Choose a rule:", label_rules);
      html_text_set_if(nn, "Choose a symbol:", "Symbols:", label_symbols);
    }
    if (success) {
      symbols_hide_on_success();
      return;
    }
    function symbols_hide_on_success() {
      html_visibility_hidden(div_symbols);
    }
  }
  refresh();
}
function list_invoke(taken) {
  let mapped = list_map(taken, invoke);
  return mapped;
}
function app_replace_button_symbol_style_valid_if_multiple(lists, valid) {
  let lambda4 = app_replace_button_symbol_style_valid_if_curried_right(valid);
  each(lists, lambda4);
}
function app_replace_button_symbol_style_valid_multiple_nested(list) {
  app_replace_button_symbol_style_valid_if_multiple_nested(list, true);
}
function app_replace_button_symbol_style_valid_if_multiple_nested(lists, valid) {
  let lambda4 = app_replace_button_symbol_style_valid_if_curried_right(valid);
  each_nested(lists, lambda4);
}
function app_replace_button_symbol_style_invalid(sb) {
  html_style_background_color_set(sb, "#D10000");
  app_replace_button_symbol_style_box_shadow(true, sb, "#FF8A8A");
}
function storage_local_transform_empty_context(context, key, lambda$value) {
  storage_local_transform_context(context, key, {}, lambda$value);
}
function storage_local_transform_context(context, key, value_initial, lambda$value) {
  assert_arguments(arguments, 4);
  let value = storage_local_initialize_context(context, key, value_initial);
  let value_new = lambda$value(value);
  undefined_not_is_assert(value_new);
  storage_local_set_context(context, key, value_new);
}
function undefined_not_is_assert(value) {
  function lambda2() {
    let v2 = {};
    return v2;
  }
  undefined_not_is_assert_lambda(value, lambda2);
}
function list_map_html_bounding_client_rect(rights_cloned2) {
  let mapped3 = list_map(rights_cloned2, html_bounding_client_rect);
  return mapped3;
}
function html_bounding_client_rect(component) {
  let e = html_component_element_get(component);
  let r = e.getBoundingClientRect();
  return r;
}
function html_translation_transition_clear(el) {
  html_style_set(el, "transition", "");
  html_style_set(el, "transform", "");
}
function html_display_inline_block_multiple(list) {
  each(list, html_display_inline_block);
}
function html_display_none_multiple(list) {
  each(list, html_display_none);
}
function html_display_none(element) {
  html_style_set(element, "display", "none");
}
async function html_move_animate_multiple(froms, tos, duration) {
  let r2 = await html_move_animate_curried_right(duration);
  await list_map_pairs_wait(froms, tos, r2);
}
async function list_map_pairs_wait(lefts, rights, lambda$left$right) {
  let mapped = list_map_pairs(lefts, rights, lambda$left$right);
  let waited = await list_wait(mapped);
  return waited;
}
async function list_wait(list) {
  let v = await Promise.all(list);
  return v;
}
function list_map_pairs(list_a, list_b, mapper) {
  function lambda_list_adder(la) {
    function lambda_each_pair(a, b) {
      const m = mapper(a, b);
      la(m);
    }
    each_pair(list_a, list_b, lambda_each_pair);
  }
  let mapped = list_adder(lambda_list_adder);
  return mapped;
}
function list_adder(lambda$la) {
  let fn = list_add;
  let list = list_adder_generic(lambda$la, fn);
  return list;
}
function list_adder_generic(lambda, fn) {
  let list = [];
  function list_adder_inner(item) {
    fn(list, item);
  }
  lambda(list_adder_inner);
  return list;
}
function list_add(list, item) {
  list.push(item);
}
function each_pair(list_a, list_b, lambda$a$b) {
  let each_fn = each_multiple;
  each_pair_generic(list_a, list_b, each_fn, lambda$a$b);
}
function each_pair_generic(list_a, list_b, each_fn, lambda$a$b) {
  let lists = [list_a, list_b];
  each_fn(lists, lambda);
  function lambda(items) {
    let [a, b] = items;
    lambda$a$b(a, b);
  }
}
function each_multiple(lists, lambda) {
  let getter = lists_get;
  each_multiple_generic(lists, getter, lambda);
}
function lists_get(lists, index) {
  let getter = list_get;
  const items = lists_get_generic(getter, index, lists);
  return items;
}
function lists_get_generic(getter, index, lists) {
  function lambda(list) {
    let item = getter(list, index);
    return item;
  }
  const items = list_map(lists, lambda);
  return items;
}
function each_multiple_generic(lists, getter, lambda) {
  let max = lists_size_max(lists);
  function lambda_each_range(index) {
    let items = getter(lists, index);
    lambda(items);
  }
  each_range(max, lambda_each_range);
}
function lists_size_max(lists) {
  let mapped = list_map(lists, list_size);
  let max = list_max(mapped);
  return max;
}
function list_max(list) {
  function lambda(a, b) {
    let v = a > b ? a : b;
    return v;
  }
  const max = list.reduce(lambda, -Infinity);
  return max;
}
function reduce(start, list, lambda$before$current) {
  let reduced = start;
  function lambda(current) {
    reduced = lambda$before$current(reduced, current);
  }
  each(list, lambda);
  return reduced;
}
function each_range(count, lambda$i) {
  let list = range(count);
  each(list, lambda$i);
}
function range(count) {
  let r = [];
  for (let i = 0; i < count; i++) {
    list_add(r, i);
  }
  return r;
}
async function html_move_animate_curried_right(duration) {
  let r2 = async function html_move_animate_curried_right_result(component_from, component_to) {
    let r = await html_move_animate(component_from, component_to, duration);
    return r;
  };
  return r2;
}
async function html_move_animate(component_from, component_to, duration) {
  const rect_from = html_bounding_client_rect(component_from);
  const rect_to = html_bounding_client_rect(component_to);
  await html_move_animate_rect(component_from, rect_from, rect_to, duration);
}
async function html_move_animate_rect(component, rect_from, rect_to, duration) {
  const offsetX = rect_to.left - rect_from.left;
  const offsetY = rect_to.top - rect_from.top;
  await html_move_animate_translate(component, offsetX, offsetY, duration);
}
async function html_move_animate_translate(component, offsetX, offsetY, duration) {
  html_style_set(component, "transition", `transform ${duration}ms`);
  let e = html_component_element_get(component);
  const u = `translate(${offsetX}px, ${offsetY}px)`;
  e.style.transform = u;
  await sleep(duration);
}
async function sleep(ms) {
  await new Promise(function lambda5(resolve) {
    let v = setTimeout(resolve, ms);
    return v;
  });
}
function html_parent_append_multiple(body, rights_cloned2) {
  let r22 = html_parent_append_curried(body);
  each(rights_cloned2, r22);
}
function html_parent_append_curried(parent) {
  let r2 = function html_parent_append_curried_result(e) {
    let r = html_parent_append(parent, e);
    return r;
  };
  return r2;
}
async function html_move_animate_multiple_parent_remove(froms, tos, duration) {
  await html_move_animate_multiple(froms, tos, duration);
  html_parent_remove_multiple(froms);
}
function html_parent_remove_multiple(froms) {
  each(froms, html_parent_remove);
}
function html_parent_remove(component) {
  let e = html_component_element_get(component);
  const parent = e.parentNode;
  parent.removeChild(e);
}
function lists_map(lists, mapper) {
  function lambda_list_adder(la) {
    function lambda_each(elements) {
      const m = mapper(elements);
      la(m);
    }
    each_multiple(lists, lambda_each);
  }
  let mapped = list_adder(lambda_list_adder);
  return mapped;
}
async function html_request_animation_frame() {
  await new Promise(function lambda(r) {
    let v = requestAnimationFrame(r);
    return v;
  });
}
function html_visibility_hidden(i) {
  html_style_assign(i, {
    visibility: "hidden"
  });
}
function html_insert(parent, child, index) {
  let parent_e = html_component_element_get(parent);
  let child_e = html_component_element_get(child);
  let pcl = parent_e.children.length;
  less_than_equal_assert(index, pcl);
  if (index === pcl) {
    html_parent_append(parent, child);
  } else {
    parent_e.insertBefore(child_e, parent_e.children[index]);
  }
}
function less_than_equal_assert(a, b) {
  let le = less_than_equal(a, b);
  assert(le);
}
function less_than_equal(a, b) {
  let le = a <= b;
  return le;
}
function html_clone(component) {
  let element = html_component_element_get(component);
  let cloned = element.cloneNode(true);
  let c = html_component_wrap(cloned);
  return c;
}
function list_slice_count(list, index, count) {
  let sliced2 = list_slice(list, index, index + count);
  return sliced2;
}
function list_slice(list, index_a, index_b) {
  let sliced = list.slice(index_a, index_b);
  return sliced;
}
function html_p_text_centered(p_next, text) {
  let p = html_p_text(p_next, text);
  html_centered(p);
  return p;
}
function html_centered(div) {
  html_style_set(div, "text-align", "center");
}
function html_p_text(root, text) {
  let p = html_p(root);
  html_text_set(p, text);
  return p;
}
function html_p(root) {
  let p = html_element(root, "p");
  return p;
}
function list_index_is(list, index) {
  assert_arguments(arguments, 2);
  let e = list_empty_is(list);
  let v = false;
  if (e) {
    return v;
  }
  if (index < 0) {
    return v;
  }
  let index_last = list_index_last(list);
  if (index > index_last) {
    return v;
  }
  let ii = true;
  return ii;
}
function list_index_last(list) {
  const index_last = list_index_end(list, 0);
  return index_last;
}
function list_index_end(list, index_from_end) {
  let v = list_size(list) - 1 - index_from_end;
  return v;
}
function list_empty_is(list) {
  const e = list_size(list) === 0;
  return e;
}
function app_karate_button_next_text() {
  let r = emoji_arrow_right() + " Next";
  return r;
}
function emoji_arrow_right() {
  let e = "‚û°Ô∏è";
  return e;
}
function list_add_first(list, item) {
  list_insert(list, 0, item);
}
function list_insert(list, index, value) {
  const delete_count = 0;
  list_insert_generic(index, list, delete_count, value);
}
function list_insert_generic(index, list, delete_count, value) {
  let b = number_is(index);
  assert(b);
  list_splice(list, index, delete_count, value);
}
function list_splice(list, index, delete_count, value) {
  list.splice(index, delete_count, value);
}
function number_is(value) {
  let v = typeof value === "number" && isFinite(value);
  return v;
}
function list_join_empty(list) {
  const e = text_empty();
  let joined = list_join(list, e);
  return joined;
}
function text_empty() {
  let v = "";
  return v;
}
function list_shuffle_take(list, count) {
  list_shuffle(list);
  let taken = list_take(list, count);
  return taken;
}
function list_take(list, count) {
  let taken = list_slice(list, 0, count);
  return taken;
}
function list_shuffle(list) {
  for (let i = list.length - 1; i > 0; i--) {
    const j = floor(random() * (i + 1));
    [list[i], list[j]] = [list[j], list[i]];
  }
}
function random() {
  let v = Math.random();
  return v;
}
function floor(p) {
  let floored = Math.floor(p);
  return floored;
}
function emoji_party_face() {
  let r4 = "ü•≥";
  return r4;
}
function emoji_party_popper() {
  let r = "üéâ";
  return r;
}
function emoji_clap() {
  let r = "üëè";
  return r;
}
function emoji_100() {
  let v = "üíØ";
  return v;
}
function emoji_medal_star() {
  let r = "üèÖ";
  return r;
}
function emoji_medal_1() {
  let r = "ü•á";
  return r;
}
function emoji_trophy() {
  let r3 = "üèÜ";
  return r3;
}
function json_equal(left, right) {
  let eq2 = equal_by(left, right, json_to);
  return eq2;
}
function equal_by(a, b, lambda$item) {
  const left = lambda$item(a);
  const right = lambda$item(b);
  let eq = equal(left, right);
  return eq;
}
function storage_local_get_context(context, key) {
  let app_fn = property_get(context, "app_fn");
  let value = storage_local_get(app_fn, key);
  return value;
}
function app_replace_button_rule(root, left, right, on_click) {
  let b = html_button_notext(root, on_click);
  app_replace_button_rule_style(b);
  let r2 = app_replace_button_rule_content(b, left, right);
  let arrow = property_get(r2, "arrow");
  let rights = property_get(r2, "rights");
  let lefts = property_get(r2, "lefts");
  let r = {
    b,
    lefts,
    rights,
    arrow
  };
  return r;
}
function app_replace_rule_set_get(context) {
  let rule_set_index = storage_local_get_context(context, "rule_set_index");
  let rule_sets = app_replace_rule_sets();
  let item = list_get(rule_sets, rule_set_index);
  return item;
}
function ternary_nested(condition_a, on_a, condition_b, on_b, on_false) {
  let result = ternary_list([condition_a, condition_b], [on_a, on_b], on_false);
  return result;
}
function ternary_list(conditions, on_matches, on_else) {
  let result = on_else;
  function lambda(c, m) {
    result = ternary(c, m, result);
  }
  each_pair_reverse(conditions, on_matches, lambda);
  return result;
}
function each_pair_reverse(list_a, list_b, lambda$a$b) {
  let ra = list_copy_reverse(list_a);
  let rb = list_copy_reverse(list_b);
  let r = each_pair(ra, rb, lambda$a$b);
  return r;
}
function list_copy_reverse(previous) {
  let copy = list_copy(previous);
  list_reverse(copy);
  return copy;
}
function list_reverse(list) {
  list.reverse();
}
function list_copy(original) {
  const copy = [...original];
  return copy;
}
function app_replace_rule_valid_curried(rule, current_list) {
  let r = function app_replace_rule_valid_curried_result(index_selected) {
    let eq = app_replace_rule_valid(rule, index_selected, current_list);
    return eq;
  };
  return r;
}
function app_replace_rule_valid(rule, index_selected, current_list) {
  let left = property_get(rule, "left");
  let size = list_size(left);
  let sliced = list_slice_count(current_list, index_selected, size);
  let eq = json_equal(left, sliced);
  return eq;
}
function property_set_exists_not(object, property_name, value) {
  property_exists_not_assert(object, property_name);
  property_set(object, property_name, value);
}
function property_exists_not_assert(object, property_name) {
  let e = property_exists(object, property_name);
  if (e) {
    let value = property_get(object, property_name);
    log_keep(property_name);
    error_json({
      object,
      property_name,
      value
    });
  }
}
function list_any(list, lambda$item) {
  let filtered = list_filter(list, lambda$item);
  let any = list_empty_not_is(filtered);
  return any;
}
function list_empty_not_is(list) {
  let a = list_empty_is(list);
  const ne = not(a);
  return ne;
}
function html_div(root) {
  let div = html_element(root, "div");
  return div;
}
function list_concat_multiple(lists) {
  let combined = [];
  function lambda(item) {
    combined = list_concat(combined, item);
  }
  each(lists, lambda);
  return combined;
}
function list_concat(a, b) {
  let l = list_is(a);
  assert(l);
  let concated = a.concat(b);
  return concated;
}
function list_skip(list, skip_count) {
  let b = list_size(list);
  const skipped = list_slice(list, skip_count, b);
  return skipped;
}
function html_text_set_if(condition, on_true, on_false, component) {
  let label_rules_text = ternary(condition, on_true, on_false);
  html_text_set(component, label_rules_text);
}
function list_map_index(list, lambda$item$index) {
  let index = 0;
  function lambda(item) {
    let value = lambda$item$index(item, index);
    index++;
    return value;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function text_split_empty(s) {
  let split = text_split(s, "");
  return split;
}
function text_split(s, separator) {
  const split = s.split(separator);
  return split;
}
function app_replace_rule_parse(rule) {
  let split = text_split_space(rule);
  let middle = list_index_of(split, ">");
  let left = list_take(split, middle);
  let right = list_skip(split, middle + 1);
  let v = {
    left,
    right
  };
  return v;
}
function list_index_of(list, item) {
  let index = list.indexOf(item);
  if (index <= -1) {
    error_json({
      list,
      item,
      index
    });
  }
  return index;
}
function text_split_space(s) {
  let split = text_split(s, " ");
  return split;
}
async function app_replace() {
  await app_main_production("app_replace_main", "jared-grace");
}
async function app_main_production(f_name, firebase_name_value) {
  let v = await app_main(f_name, firebase_name_value, firebase_deploy_function_destination_production);
  return v;
}
function firebase_deploy_function_destination_production(f_name) {
  let destination2 = firebase_deploy_function_destination_json("version_production", f_name);
  return destination2;
}
function firebase_deploy_function_destination_json(name, f_name) {
  let file_name = file_name_json(name);
  let destination = firebase_deploy_function_destination(f_name, file_name);
  return destination;
}
function firebase_deploy_function_destination(f_name, file_name) {
  const list = ["function", f_name, file_name];
  let destination = list_join_slash_forward(list);
  return destination;
}
function list_join_slash_forward(list) {
  let joined = list_join(list, "/");
  return joined;
}
function file_name_json(name) {
  let file_name = name + json_extension();
  return file_name;
}
function json_extension() {
  let ext_j = ".json";
  return ext_j;
}
async function app_main(f_name, firebase_name_value, version_get) {
  global_function_initialize(firebase_name, firebase_name_value);
  let call = js_code_call_app_context_initialize(f_name);
  await firebase_storage_function_run_generic(version_get, f_name, call);
}
function js_code_call_app_context_initialize(name_prefixed) {
  let result = js_code_call_args_statement(app_context_initialize.name, [name_prefixed]);
  return result;
}
function js_code_call_args_statement(f_name, args) {
  let code = js_code_call_args(f_name, args);
  let result = js_code_statement(code);
  return result;
}
function js_code_call_args(fn_name, args) {
  assert_arguments(arguments, 2);
  let joined = list_join_comma_space(args);
  let code = fn_name + js_code_wrap_parenthesis(joined);
  return code;
}
function js_code_wrap_parenthesis(inside) {
  const inside_larger = " " + inside + " ";
  let v = text_wrap_parenthesis(inside_larger);
  return v;
}
function text_wrap_parenthesis(inside) {
  let v2 = js_code_parenthesis_left() + inside + js_code_parenthesis_right();
  return v2;
}
function js_code_parenthesis_right() {
  let v2 = ")";
  return v2;
}
function js_code_parenthesis_left() {
  let v3 = "(";
  return v3;
}
function list_join_comma_space(args) {
  let v = list_join(args, ", ");
  return v;
}
function js_code_statement(code) {
  let v = code + js_code_semicolon();
  return v;
}
function js_code_semicolon() {
  let v2 = ";";
  return v2;
}
async function firebase_storage_function_run_generic(version_get, f_name, call) {
  let destination_version = version_get(f_name);
  let destination = await firebase_storage_download_property(destination_version, "destination");
  let code = await firebase_storage_download_property(destination, "code");
  let global_init = js_code_global_init();
  let joined = list_join_newline([global_init, code, call]);
  if (browser_is()) {
    let body = html_document_body();
    let component = html_element(body, "script");
    html_attribute_set(component, "type", "module");
    html_text_set(component, joined);
  } else {
    eval(joined);
  }
}
function browser_is() {
  let b = typeof window !== "undefined" && typeof window.document !== "undefined";
  return b;
}
function list_join_newline(list) {
  let separator = newline();
  let joined = list_join(list, separator);
  return joined;
}
function newline() {
  let v = "\n";
  return v;
}
function js_code_global_init() {
  let right = js_code_braces_empty();
  let left = global_name();
  let code_assign = js_code_let_assign(left, right);
  return code_assign;
}
function global_name() {
  let global = "global";
  return global;
}
function js_code_let_assign(left, right) {
  let code_assign = js_keyword_let() + " " + js_code_assign(left, right) + ";";
  return code_assign;
}
function js_code_assign(left, right) {
  const code = left + js_code_equals_padded() + right;
  return code;
}
function js_code_equals_padded() {
  let v = " = ";
  return v;
}
function js_keyword_let() {
  let v = "let";
  return v;
}
function js_code_braces_empty() {
  let v = js_code_wrap_braces("");
  return v;
}
function js_code_wrap_braces(inside) {
  let w = js_code_brace_left() + inside + js_code_brace_right();
  return w;
}
function js_code_brace_right() {
  let v2 = "}";
  return v2;
}
function js_code_brace_left() {
  let v2 = "{";
  return v2;
}
async function firebase_storage_download_property(storage_path, property_name) {
  let buffer = await firebase_storage_download(storage_path);
  const json = buffer_text_to(buffer);
  let o = json_from(json);
  let value = property_get(o, property_name);
  return value;
}
function buffer_text_to(buffer) {
  let s = null;
  let b = browser_is();
  if (b) {
    if (buffer instanceof ArrayBuffer) {
      s = new TextDecoder("utf-8").decode(new Uint8Array(buffer));
    } else if (buffer instanceof Uint8Array) {
      s = new TextDecoder("utf-8").decode(buffer);
    } else {
      throw new Error("Unsupported buffer type");
    }
  } else {
    s = buffer.toString("utf8");
  }
  return s;
}
async function firebase_storage_download(destination) {
  destination = firebase_path_fix(destination);
  let b = browser_is();
  if (b) {
    async function lambda2() {
      let url = await firebase_storage_url(destination);
      let buffer = await http(url);
      return buffer;
    }
    let result = await html_loading(lambda2);
    return result;
  }
  const bucket = await firebase_bucket();
  let [buffer] = await bucket.file(destination).download();
  return buffer;
}
async function html_loading(lambda) {
  let div = null;
  let b2 = browser_is();
  if (b2) {
    let body = html_document_body();
    div = html_div(body);
    let s = {
      position: "fixed",
      top: "0",
      left: "0",
      width: "100vw",
      height: "100vh",
      background: "rgba(0, 0, 0, 0.6)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      zIndex: "1000"
    };
    html_style_assign(div, s);
  }
  let result = null;
  try {
    result = await lambda();
  } catch (e) {
    throw e;
  } finally {
    if (b2) {
      html_remove(div);
    }
  }
  return result;
}
function html_remove(component) {
  let element = html_component_element_get(component);
  element.remove();
}
async function http(url) {
  let options = http_get_options();
  let v = await http_generic(url, options);
  return v;
}
function http_get_options() {
  let v2 = {
    method: "GET"
  };
  return v2;
}
async function http_generic(url, options) {
  const method = options.method || "GET";
  const body = options.body || null;
  const b = browser_is();
  if (b) {
    async function lambda3() {
      const r = {
        method
      };
      let exists = property_exists(options, "body");
      if (exists) {
        object_assign(r, {
          headers: {
            "Content-Type": "application/json",
            ...options.headers || ({})
          },
          body: json_to(body)
        });
      }
      const response = await fetch(url, r);
      if (not(response.ok)) {
        error("Failed to fetch file");
      }
      const buf = await response.arrayBuffer();
      return buf;
    }
    let v = await html_loading(lambda3);
    return v;
  }
  let sleep = true;
  let e = property_exists(options, "sleep");
  if (e) {
    sleep = property_get(options, "sleep");
  }
  if (sleep) {
    await http_sleep();
  }
  let swHttps = text_starts_with(url, "https://");
  let h_name = ternary(swHttps, "s", "");
  let h = await import("http" + h_name);
  let buffer = await promise_wrap(lambda);
  function lambda(resolve, reject) {
    const urlObj = new URL(url);
    function lambda5(res) {
      const chunks = [];
      function lambda2(chunk) {
        chunks.push(chunk);
      }
      let i = catch_call(reject, lambda2);
      res.on("data", i);
      function on_end() {
        let statusCode = property_get(res, "statusCode");
        const d = statusCode / 100;
        const rounded = round(d);
        assert_json(rounded === 2, {
          url,
          statusCode
        });
        let v2 = Buffer.concat(chunks);
        resolve(v2);
      }
      let i2 = catch_call(reject, on_end);
      res.on("end", i2);
    }
    const a = {
      hostname: urlObj.hostname,
      port: urlObj.port || (swHttps ? 443 : 80),
      path: urlObj.pathname + urlObj.search,
      method,
      headers: {
        ...options.headers || ({}),
        ...body ? {
          "Content-Type": "application/json"
        } : {}
      }
    };
    const req = h.request(a, lambda5);
    req.on("error", reject);
    if (body) {
      let json = json_to(body);
      req.write(json);
    }
    req.end();
  }
  return buffer;
}
function round(n) {
  let rounded = Math.round(n);
  return rounded;
}
function catch_call(reject, lambda) {
  let i = function inner() {
    let result = null;
    try {
      result = lambda(...arguments);
    } catch (e) {
      reject(e);
    }
    return result;
  };
  return i;
}
async function promise_wrap(lambda$resolve$reject) {
  let p = await new Promise(function promise_wrap_inner(resolve, reject) {
    try {
      lambda$resolve$reject(resolve, reject);
    } catch (e) {
      reject(e);
    }
  });
  return p;
}
function text_starts_with(t, prefix) {
  let sw = t.startsWith(prefix);
  return sw;
}
async function http_sleep() {
  await sleep(integer_random(5, 8) * 1000);
}
function integer_random(min, max) {
  let list = [min, max];
  assert_multiple(integer_is, list);
  let r = floor(random() * (max - min + 1)) + min;
  return r;
}
function assert_multiple(fn, list) {
  function lambda(l) {
    let ii = fn(l);
    assert(ii);
  }
  each(list, lambda);
}
async function firebase_bucket() {
  const admin = await firebase_admin();
  const bucket = admin.storage().bucket();
  return bucket;
}
async function firebase_admin() {
  let admin = await global_function_async(firebase_admin, firebase_admin_get);
  return admin;
}
async function global_function_async(fn, lambda) {
  let global = global_get();
  let value = property_initialize_lambda(global, fn.name, lambda);
  let awaited = await value;
  return awaited;
}
async function firebase_admin_get() {
  const admin = (await import("firebase-admin")).default;
  let service_account = await firebase_service_account();
  const sb = await firebase_storage_url_project();
  admin.initializeApp({
    credential: admin.credential.cert(service_account),
    storageBucket: sb
  });
  return admin;
}
async function firebase_storage_url_project() {
  const prefix = await firebase_name();
  let url = prefix + ".firebasestorage.app";
  return url;
}
async function firebase_name() {
  if (browser_is()) {
    let value = global_function_get(firebase_name);
    return value;
  }
  let repo_name = await user_repo_get();
  let default2 = await firebase_name_repo(repo_name);
  return default2;
}
async function firebase_name_repo(repo_name) {
  const f_path = ".firebaserc";
  let combined = repo_path_combine(repo_name, f_path);
  let f = await file_read_json(combined);
  let projects = property_get(f, "projects");
  let default2 = property_get(projects, "default");
  return default2;
}
async function file_read_json(file_path) {
  let json = await file_read(file_path);
  let data = json_from(json);
  return data;
}
async function file_read(file_path) {
  let exists = global_function_property_exists(file_read_cached, file_path);
  if (exists) {
    let c = await global_function_property_get(file_read_cached, file_path);
    return c;
  }
  if (browser_is()) {
    file_path = file_path_normalize(file_path);
    await app_a_file_system_initialize();
    let store = app_a_file_system_store();
    let item = await indexeddb_get(app_a_indexeddb_initialize, store, file_path);
    let compressed = property_get(item, "compressed");
    let f = await json_decompress(compressed);
    let versions = property_get(f, "versions");
    let last = list_last(versions);
    return last;
  }
  let fs = await import("fs");
  let contents = await fs.promises.readFile(file_path, "utf-8");
  return contents;
}
async function file_read_cached(f_path) {
  let exists = global_function_property_exists(file_read_cached, f_path);
  if (exists) {
    let v2 = false;
    return v2;
  }
  assert_not(exists);
  let contents = await file_read(f_path);
  global_function_property_set(file_read_cached, f_path, contents);
  let v = true;
  return v;
}
function assert_not(b) {
  if (b) {
    error();
  }
}
async function json_decompress(compressed) {
  let json = await text_decompress(compressed);
  let text = json_from(json);
  return text;
}
async function text_decompress(compressed) {
  let lz = null;
  let condition = browser_is();
  let result = null;
  if (condition) {
    result = (await import("lz-string")).default;
  } else {
    result = LZString;
  }
  lz = result;
  let v = lz.decompressFromUTF16(compressed);
  return v;
}
function list_last(list) {
  list_empty_not_is_assert(list);
  let last = list_get_end(list, 0);
  return last;
}
function list_empty_not_is_assert(list) {
  let ne = list_empty_not_is(list);
  assert(ne);
}
function list_get_end(list, index_from_end) {
  const difference = list_index_end(list, index_from_end);
  const item = list_get(list, difference);
  return item;
}
function file_path_normalize(file_path) {
  file_path = path_normalize(file_path);
  const prefix = "../";
  let n = text_starts_with_not(file_path, prefix);
  if (n) {
    file_path = prefix + "love/" + file_path;
  }
  return file_path;
}
function text_starts_with_not(item, book_code) {
  let a = text_starts_with(item, book_code);
  let sw = not(a);
  return sw;
}
function path_normalize(path) {
  let n = path.replace(/\\/g, "/").replace(/\/+/g, "/").replace(/\/\.\//g, "/").replace(/\/$/, "").replace(/^\.\/+/, "");
  return n;
}
async function app_a_indexeddb_initialize() {
  const db_name = app_a.name;
  const version = 1;
  const store_files = "files";
  const db = await new Promise(function lambda4(resolve, reject) {
    const req = indexedDB.open(db_name, version);
    req.onupgradeneeded = function lambda() {
      const db = req.result;
      let b = db.objectStoreNames.contains(store_files);
      if (not(b)) {
        db.createObjectStore(store_files, {
          keyPath: app_a_indexeddb_path_key()
        });
      }
    };
    req.onsuccess = function lambda2() {
      let v = resolve(req.result);
      return v;
    };
    req.onerror = function lambda3() {
      let v2 = reject(req.error);
      return v2;
    };
  });
  return db;
}
function app_a_indexeddb_path_key() {
  let v3 = "key";
  return v3;
}
async function app_a() {
  await app_main_production("app_a_main", "jared-grace");
}
function app_a_file_system_store() {
  let v = "files";
  return v;
}
async function indexeddb_get(db_get, store, key) {
  let all = await indexeddb_get_all(db_get, store);
  let f = list_find_property(all, "key", key);
  return f;
}
async function indexeddb_get_all(db_get, store) {
  let exists = global_function_property_exists(indexeddb_get_all, store);
  if (not(exists)) {
    let all = await indexeddb_get_all_backend(db_get, store);
    global_function_property_set(indexeddb_get_all, store, all);
  }
  let list = global_function_property_get(indexeddb_get_all, store);
  return list;
}
async function indexeddb_get_all_backend(db_get, store) {
  const db = await db_get();
  const tx = db.transaction(store, "readonly");
  const s = tx.objectStore(store);
  let all = await new Promise(function lambda3(resolve, reject) {
    const req = s.getAll();
    req.onsuccess = function lambda() {
      let v = resolve(req.result);
      return v;
    };
    req.onerror = function lambda2() {
      let v2 = reject(req.error);
      return v2;
    };
  });
  return all;
}
async function app_a_file_system_initialize() {
  let value = storage_local_exists(app_a, app_a_file_system_initialize.name);
  if (value) {
    return;
  }
  async function lambda2() {
    await app_a_file_system_initialize_download();
    let v = true;
    return v;
  }
  let value2 = await global_function_initialize_lambda_async(app_a_file_system_initialize, lambda2);
}
async function app_a_file_system_initialize_download() {
  let db = await app_a_indexeddb_initialize();
  let db_get = lambda_get(db);
  let r = await app_api_fn({
    fn: app_a_download
  });
  list_property_exists_not_error(r, "key");
  let dictionary = list_to_dictionary_property(r, "key");
  let store = app_a_file_system_store();
  await indexeddb_put_multiple(db_get, store, dictionary);
  storage_local_set(app_a, app_a_file_system_initialize.name, true);
  let all = await indexeddb_get_all(db_get, store);
  list_property_exists_not_error(all, "key");
}
async function app_api_fn(a) {
  let fn = property_get(a, "fn");
  let f_name = fn.name;
  property_set_exists_not(a, "f_name", f_name);
  let r = await app_api(a);
  return r;
}
async function app_api(a) {
  assert_arguments(arguments, 1);
  let f_name = property_get(a, "f_name");
  text_is_assert(f_name);
  let fn_http = http_post_json;
  property_set_exists_not(a, "fn_http", fn_http);
  let result = await app_api_generic(a);
  return result;
}
function text_is_assert(value) {
  let b = text_is(value);
  assert(b);
}
function text_is(value) {
  let ti = typeof value === "string";
  return ti;
}
async function app_api_generic(a) {
  assert_arguments(arguments, 1);
  let f_name = property_get(a, "f_name");
  let args = property_initialize(a, "args", []);
  let fn_http = property_get(a, "fn_http");
  var v = app_api_generic_url_body(f_name, args);
  let body = property_get(v, "body");
  let url = property_get(v, "url");
  let o = await fn_http(url, body);
  let result = property_get(o, "result");
  return result;
}
function app_api_generic_url_body(f_name, args) {
  let body = app_api_generic_f_name_args(f_name, args);
  let url = server_url_get();
  let v = {
    url,
    body
  };
  return v;
}
function server_url_get() {
  let url = null;
  url = ternary(browser_is(), "", server_url());
  url += server_url_api();
  return url;
}
function server_url_api() {
  let a = "/api";
  return a;
}
function server_url() {
  const port = server_port();
  let url = "http://localhost:" + port;
  return url;
}
function server_port() {
  let v4 = 8080;
  return v4;
}
function app_api_generic_f_name_args(f_name, args) {
  let args_list = list_to(args);
  let v2 = {
    f_name: f_name,
    args: args_list
  };
  return v2;
}
function list_to(a) {
  let l = Array.from(a);
  return l;
}
async function http_post_json(url, body) {
  let buffer = await http_post(url, body);
  let o = buffer_to_json(buffer);
  return o;
}
async function http_post(url, body) {
  const options_extra = {};
  let v = await http_post_options(url, body, options_extra);
  return v;
}
async function http_post_options(url, body, options_extra) {
  const options = {
    method: "POST",
    body: body
  };
  object_merge(options, options_extra);
  let v = await http_generic(url, options);
  return v;
}
function buffer_to_json(buffer) {
  let text = buffer_text_to(buffer);
  let parsed = json_from(text);
  return parsed;
}
function list_property_exists_not_error(all, property) {
  function lambda(item, index) {
    let n = property_exists_not(item, property);
    if (n) {
      error({
        index
      });
    }
  }
  each_index(all, lambda);
}
function property_exists_not(object, property_name) {
  let e = property_exists(object, property_name);
  let ne = not(e);
  return ne;
}
function list_to_dictionary_property(list, property) {
  function key_get(item) {
    let key = property_get(item, property);
    return key;
  }
  let dictionary = list_to_dictionary_key(list, key_get);
  return dictionary;
}
function list_to_dictionary_key(list, lambda$item) {
  let value_get = identity;
  let dictionary = list_to_dictionary(list, value_get, lambda$item);
  return dictionary;
}
function list_to_dictionary(list, lambda$item2v, lambda$item2k) {
  "if each key has one value, then " + list_to_dictionary.name + " but if each key corresponds to a list of values, then " + list_to_lookup.name;
  let dictionary = {};
  function lambda(item) {
    let key = lambda$item2k(item);
    let value = lambda$item2v(item);
    property_set_exists_not(dictionary, key, value);
  }
  each(list, lambda);
  return dictionary;
}
function list_to_lookup(list, property_key) {
  "if each key has one value, then " + list_to_dictionary.name + " but if each key corresponds to a list of values, then " + list_to_lookup.name;
  let lookup = {};
  function lambda(item) {
    let n = property_exists_not(item, property_key);
    if (n) {
      return;
    }
    let value = property_get(item, property_key);
    let key_list = property_initialize_list(lookup, value);
    list_add(key_list, item);
  }
  each(list, lambda);
  return lookup;
}
function property_initialize_list(object, property_name) {
  let value2 = property_initialize(object, property_name, []);
  return value2;
}
function identity(a) {
  return a;
}
async function indexeddb_put_multiple(db_get, store, lookup) {
  'at time of writing, indexeddb code only uses key value of "key" therefore this function could be made general to receive key name as param';
  let key = "key";
  let v = object_values(lookup);
  let keys = list_map_property(v, key);
  let existing = await indexeddb_get_all(db_get, store);
  function lambda(item) {
    let k = property_get(item, key);
    let includes = list_includes(keys, k);
    return includes;
  }
  let filtered = list_filter(existing, lambda);
  list_remove_multiple(existing, filtered);
  list_add_multiple(existing, v);
  async function lambda_async() {
    await indexeddb_put_multiple_backend(db_get, store, lookup);
  }
  indexeddb_next(lambda_async);
}
function list_add_multiple(list, items) {
  list.push(...items);
}
function list_remove_multiple(list, removals) {
  function lambda(r) {
    list_remove(list, r);
  }
  each(removals, lambda);
}
function list_remove(list, item) {
  const index = list_index_of(list, item);
  list_remove_at(list, index);
}
function list_remove_at(list, index) {
  let e = list_remove_at_count(list, index, 1);
  let only = list_single(e);
  return only;
}
function list_remove_at_count(list, index, count) {
  let e = list.splice(index, count);
  return e;
}
function list_includes(list, item) {
  const includes = list.includes(item);
  return includes;
}
function list_map_property(list, property_name) {
  let r = property_get_curried_right(property_name);
  let mapped = list_map(list, r);
  return mapped;
}
function property_get_curried_right(property_name) {
  let r = function property_get_curried_right_result(object) {
    let value = property_get(object, property_name);
    return value;
  };
  return r;
}
function object_values(o) {
  let v = Object.values(o);
  return v;
}
async function indexeddb_put_multiple_backend(db_get, store, nexts) {
  const tx = await db_get().transaction(store, "readwrite");
  const s = tx.objectStore(store);
  function lambda2(n) {
    s.put(n);
  }
  each_object_values(nexts, lambda2);
  await new Promise(function lambda6(resolve, reject) {
    tx.oncomplete = resolve;
    tx.onerror = function lambda4() {
      let v3 = reject(tx.error);
      return v3;
    };
    tx.onabort = function lambda5() {
      let v4 = reject(tx.error);
      return v4;
    };
  });
}
function each_object_values(object, lambda$item) {
  function lambda(value, property) {
    lambda$item(value);
  }
  each_object(object, lambda);
}
function each_object(object, lambda$value$property) {
  function lambda2(property) {
    let value = property_get(object, property);
    lambda$value$property(value, property);
  }
  let properties = properties_get(object);
  each(properties, lambda2);
}
function indexeddb_next(lambda_async) {
  let initial = promise_resolved();
  let previous = global_function_initialize(indexeddb_next, initial);
  let promise = invoke(lambda_async);
  previous = previous.then(promise);
  global_function_set(indexeddb_next, previous);
}
function promise_resolved() {
  let v = Promise.resolve(null);
  return v;
}
async function app_a_download() {
  let filtered = await app_a_download_paths();
  async function lambda2(path) {
    let contents = await file_read(path);
    let data = {
      versions: [contents]
    };
    let c = await json_compress_object(data);
    object_merge(c, {
      key: path
    });
    return c;
  }
  let files = await list_map_unordered_async(filtered, lambda2);
  list_property_exists_not_error(files, "key");
  return files;
}
async function json_compress_object(data) {
  let compressed = await json_compress(data);
  let c = {
    compressed
  };
  return c;
}
async function json_compress(data) {
  let json = json_to(data);
  let compressed = await text_compress(json);
  return compressed;
}
async function text_compress(text) {
  const LZString = (await import("lz-string")).default;
  let v = LZString.compressToUTF16(text);
  return v;
}
async function list_map_unordered_async(list, lambda$item) {
  let mapped = list_map(list, lambda$item);
  let waited = await list_wait(mapped);
  return waited;
}
async function app_a_download_paths() {
  let path_folder = repos_folder();
  let combineds = await folder_read_recursive_skipped_paths_async(path_folder, ["node_modules", ".git"]);
  let ext_f = function_name_extension();
  let ext_h = html_extension();
  let ext_j = json_extension();
  let filtered = list_filter_ends_with_any(combineds, [ext_f, ext_h, ext_j]);
  return filtered;
}
async function folder_read_recursive_skipped_paths_async(path_folder, folders_skipped) {
  let result = await folder_read_recursive_skipped_async(path_folder, folders_skipped);
  let mapped = folder_read_recursive_paths_to(result, path_folder);
  return mapped;
}
function folder_read_recursive_paths_to(result, path_folder) {
  let combineds = list_map_path_join_left(result, path_folder);
  let mapped = list_map(combineds, path_normalize);
  return mapped;
}
function list_map_path_join_left(list, folder_prefix) {
  function lambda(item) {
    let joined = path_join([folder_prefix, item]);
    return joined;
  }
  let mapped2 = list_map(list, lambda);
  return mapped2;
}
function path_join(segments) {
  assert_arguments(arguments, 1);
  let parts = [];
  for (let seg of segments) {
    if (not(seg)) {
      continue;
    }
    let split = seg.split(/[\\/]+/);
    for (let s of split) {
      if (s === "" || s === ".") {
        continue;
      }
      if (s === folder_previous()) {
        if (parts.length > 0 && parts[parts.length - 1] !== folder_previous()) {
          parts.pop();
        } else {
          let previous = folder_previous();
          parts.push(previous);
        }
      } else {
        parts.push(s);
      }
    }
  }
  let joined = parts.join("/");
  return joined;
}
function folder_previous() {
  let previous = "..";
  return previous;
}
async function folder_read_recursive_skipped_async(path_folder, folders_skipped) {
  const fs = await import("fs/promises");
  const path = await import("path");
  let result = [];
  const entries = await fs.readdir(path_folder, {
    withFileTypes: true
  });
  for (const entry of entries) {
    let name = property_get(entry, "name");
    if (entry.isFile()) {
      result.push(name);
    } else if (entry.isDirectory()) {
      let n = list_includes_not(folders_skipped, name);
      if (n) {
        const fullPath = path.join(path_folder, name);
        const subFiles = await folder_read_recursive_skipped_async(fullPath, folders_skipped);
        function lambda(f) {
          let v = path.join(name, f);
          return v;
        }
        result.push(...subFiles.map(lambda));
      }
    }
  }
  return result;
}
function list_includes_not(list, item) {
  let b = list_includes(list, item);
  let n = not(b);
  return n;
}
function repos_folder() {
  let previous = folder_previous();
  return previous;
}
function list_filter_ends_with_any(list, suffixes) {
  function lambda(item) {
    function lambda3(suffix) {
      let ew = text_ends_with(item, suffix);
      return ew;
    }
    let any = list_any(suffixes, lambda3);
    return any;
  }
  let filtered = list_filter(list, lambda);
  return filtered;
}
function text_ends_with(s, suffix) {
  const ew = s.endsWith(suffix);
  return ew;
}
function html_extension() {
  let ext_h = ".html";
  return ext_h;
}
function function_name_extension() {
  const ext = ".mjs";
  return ext;
}
async function global_function_initialize_lambda_async(fn, lambda) {
  assert_arguments(arguments, 2);
  let global = global_get();
  let value = await property_initialize_lambda_async(global, fn.name, lambda);
  return value;
}
async function property_initialize_lambda_async(object, property_name, lambda) {
  const exists = property_exists(object, property_name);
  if (not(exists)) {
    let value_set = lambda();
    property_set(object, property_name, value_set);
  }
  let value = await property_get(object, property_name);
  return value;
}
function storage_local_exists(app_fn, key) {
  let storage_local_key = storage_local_key_get(app_fn, key);
  if (storage_local_enabled()) {
    let json = storage_local_specify_get_json(storage_local_key);
    let v = json !== null;
    return v;
  }
  let exists = storage_local_exists_global(storage_local_key);
  return exists;
}
function repo_path_combine(repo_name, f_path) {
  let folder_name = repo_path(repo_name);
  let combined = path_join([folder_name, f_path]);
  return combined;
}
function repo_path(repo_name) {
  let previous = repos_folder();
  let r_path = path_join([previous, repo_name]);
  return r_path;
}
async function user_repo_get() {
  let f_path = user_repo_path();
  let v = await data_get("repo_current", null, f_path);
  let repo_name = property_get(v, "value");
  await repo_exists_assert(repo_name);
  return repo_name;
}
async function repo_exists_assert(repo_name) {
  let all = await repos_names();
  list_includes_assert(all, repo_name);
}
function list_includes_assert(all, repo_name) {
  let includes = list_includes(all, repo_name);
  assert(includes);
}
async function repos_names() {
  let path_folder = repos_folder();
  let rns = await folder_read(path_folder);
  let v = folder_vscode();
  let ignores = [v];
  function lambda(r) {
    let n = list_includes_not(ignores, r);
    return n;
  }
  let f = list_filter(rns, lambda);
  return f;
}
function folder_vscode() {
  let vc = ".vscode";
  return vc;
}
async function folder_read(path_folder) {
  if (browser_is()) {
    let v = await folder_read_browser(path_folder);
    let unique = property_get(v, "unique");
    return unique;
  }
  let fs = await import("fs");
  const all = await fs.promises.readdir(path_folder);
  return all;
}
async function folder_read_browser(path_folder) {
  let files_paths = await app_a_files_paths();
  let r = global_function_property_cache(folder_read_browser, path_folder, files_paths, value_get);
  return r;
  function value_get() {
    let n = path_normalize(path_folder);
    let s = text_slash_forward();
    let prefix = "" + n + s;
    let filtered = list_filter_starts_with(files_paths, prefix);
    let mapped = list_map_prefix_without(filtered, prefix);
    function lambda(item) {
      let first = text_split_first(item, s);
      return first;
    }
    let mapped2 = list_map(mapped, lambda);
    let unique = list_unique(mapped2);
    let r = {
      unique,
      prefix,
      filtered
    };
    return r;
  }
}
function global_function_property_cache(fn, property_name, key, value_get) {
  let c = global_function_property_initialize(fn, property_name, {
    json: null,
    result: null
  });
  let result = global_function_cache_generic(key, c, value_get);
  return result;
}
function global_function_cache_generic(key, c, value_get) {
  let json = json_to(key);
  let json_existing = property_get(c, "json");
  if (equal_not(json, json_existing)) {
    let r = value_get();
    property_set(c, "result", r);
    property_set(c, "json", json);
  }
  let result = property_get(c, "result");
  return result;
}
function equal_not(left, right) {
  let a = equal(left, right);
  let ne = not(a);
  return ne;
}
function global_function_property_initialize(fn, property_name, value_initial) {
  let global = global_get();
  let fn_object = property_initialize(global, fn.name, {});
  let value = property_initialize(fn_object, property_name, value_initial);
  return value;
}
function list_unique(list) {
  let found = list_unique_set(list);
  let unique = [...found];
  return unique;
}
function list_unique_set(list) {
  let set = set_new();
  function lambda(item) {
    set_add(set, item);
  }
  each(list, lambda);
  return set;
}
function set_add(found, item) {
  found.add(item);
}
function set_new() {
  let v = new Set();
  return v;
}
function text_split_first(item, s) {
  let index = text_index_of_try(item, s);
  if (index < 0) {
    return item;
  }
  let taken = text_take(item, index);
  return taken;
}
function text_index_of_try(t, item) {
  let v = t.indexOf(item);
  return v;
}
function list_map_prefix_without(list, prefix) {
  function lambda(item) {
    let result = text_prefix_without(item, prefix);
    return result;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function text_prefix_without(s, prefix) {
  let a = text_starts_with(s, prefix);
  function lambda() {
    let r = {
      s,
      prefix
    };
    return r;
  }
  assert_json_get(a, lambda);
  if (not(a)) {
    error();
  }
  let without = text_prefix_without_inner(s, prefix);
  return without;
}
function text_prefix_without_inner(s, prefix) {
  let skipped = text_size(prefix);
  let without = text_skip(s, skipped);
  return without;
}
function text_skip(s, skip_count) {
  let b = text_size(s);
  const skipped = text_slice(s, skip_count, b);
  return skipped;
}
function text_size(s) {
  let size = s.length;
  return size;
}
function list_filter_starts_with(list, prefix) {
  function lambda(item) {
    let sw = text_starts_with(item, prefix);
    return sw;
  }
  let filtered = list_filter(list, lambda);
  return filtered;
}
async function app_a_files_paths() {
  let store = app_a_file_system_store();
  let all = await indexeddb_get_all(app_a_indexeddb_initialize, store);
  let filtered = list_filter_property_exclude_if_exists(all, "deleted", true);
  let property_name = app_a_indexeddb_path_key();
  let files_paths = list_map_property(filtered, property_name);
  return files_paths;
}
function list_filter_property_exclude_if_exists(list, property_name, value) {
  function lambda(item) {
    let exists = property_exists(item, property_name);
    if (exists) {
      let ne = property_get(item, property_name) !== value;
      return ne;
    }
    let v2 = true;
    return v2;
  }
  let filtered = list_filter(list, lambda);
  return filtered;
}
function text_slash_forward() {
  let s = "/";
  return s;
}
async function data_get(property_name, value_initial, d_path) {
  var d = await data_all(d_path);
  let file_path = property_get(d, "file_path");
  let data = property_get(d, "data");
  let value = property_initialize(data, property_name, value_initial);
  let r = {
    value,
    file_path,
    data
  };
  return r;
}
async function data_all(file_path) {
  let data = {};
  let d_path = data_path();
  if (equal(file_path, d_path)) {
    await data_generate(data);
  } else {
    await data_all_initialize(file_path);
    data = await file_read_json(file_path);
  }
  let v = {
    data,
    file_path
  };
  return v;
}
async function data_generate(data) {
  let f_paths = await functions_paths();
  let parseds = await list_map_unordered_async(f_paths, file_js_parse);
  let lambda = data_file_update_inner_curried_right(data);
  each(parseds, lambda);
  return;
}
function data_file_update_inner_curried_right(data) {
  let r2 = function data_file_update_inner_curried_right_result(parsed) {
    let r = data_file_update_inner(parsed, data);
    return r;
  };
  return r2;
}
function data_file_update_inner(parsed, data) {
  let f_path = property_get(parsed, "f_path");
  let f_name = function_path_to_name(f_path);
  let ast = property_get(parsed, "ast");
  let functions = property_initialize(data, "functions", {});
  let f_this = property_initialize(functions, f_name, {});
  let declaration = js_flo(ast);
  let async_is = property_get(declaration, "async");
  property_set(f_this, "async", async_is);
  function data_add(property_name, items) {
    let items_to_functions = property_initialize(data, property_name, {});
    function identifier_add(i_name) {
      let list = property_initialize(items_to_functions, i_name, []);
      list_add_if_not_includes(list, f_name);
    }
    each(items, identifier_add);
    let items_old = property_initialize(f_this, property_name, []);
    let removals = list_difference(items_old, items);
    function lambda(item) {
      let list = property_initialize(items_to_functions, item, []);
      list_remove_all(list, f_name);
      let e = list_empty_is(list);
      if (e) {
        property_delete(items_to_functions, item);
      }
      each(removals, lambda);
    }
    property_set(f_this, property_name, items);
  }
  let f_identifiers_new = js_identifiers_names(ast);
  data_add("identifiers", f_identifiers_new);
  let strings_new = js_strings(ast);
  data_add("strings", strings_new);
  function lambda2(la) {
    js_visit_calls_named(ast, fn_name.name, lambda4);
    function lambda4({args}) {
      let first = list_first(args);
      function lambda3() {
        let v = {
          msg: fn_name.name + " first argument should be a literal: " + f_name
        };
        return v;
      }
      js_literal_is_assert(first, lambda3);
      let value = property_get(first, "value");
      la(value);
    }
  }
  let identifiers_fn_names = list_adder(lambda2);
  data_add("identifiers_fn_names", identifiers_fn_names);
}
function js_strings(ast) {
  function lambda2(la) {
    function lambda(v) {
      let node = property_get(v, "node");
      let value = null;
      function lambda5() {
        let quasis = property_get(node, "quasis");
        let s1 = list_size_1(quasis);
        if (s1) {
          let expressions = property_get(node, "expressions");
          let e = list_empty_is(expressions);
          if (e) {
            let q = list_first(quasis);
            let v2 = property_get(q, "value");
            value = property_get(v2, "raw");
          }
        }
      }
      js_node_type_is_if(node, "TemplateLiteral", lambda5);
      function lambda4() {
        value = property_get(node, "value");
      }
      js_node_type_is_if(node, "Literal", lambda4);
      let si2 = text_is(value);
      if (si2) {
        la(value);
      }
    }
    js_visit_types(ast, ["Literal", "TemplateLiteral"], lambda);
  }
  const names = list_adder_unique(lambda2);
  return names;
}
function list_size_1(list) {
  const s1 = list_size(list) === 1;
  return s1;
}
function js_node_type_is_if(node, type, lambda) {
  let type_is = js_node_type_is(node, type);
  if (type_is) {
    lambda();
  }
}
function js_node_type_is(node, type) {
  const type_is = js_node_is(node) && js_node_type(node) === type;
  return type_is;
}
function js_node_is(n) {
  const ni = property_exists(n, "type");
  return ni;
}
function js_node_type(n) {
  const nt = property_get(n, "type");
  return nt;
}
function list_adder_unique(lambda$la) {
  let items = list_adder(lambda$la);
  let unique = list_unique(items);
  return unique;
}
function js_visit_types(ast, types, lambda$v) {
  function lambda(v) {
    let node = property_get(v, "node");
    if (js_node_is(node) && js_node_types_is(node, types)) {
      lambda$v(v);
    }
  }
  js_visit(ast, lambda);
}
function js_node_types_is(item, types) {
  function lambda2(type) {
    let type_is = js_node_type_is(item, type);
    return type_is;
  }
  const match = list_any(types, lambda2);
  return match;
}
function js_visit(ast, lambda$v) {
  let a = promise_not_is(ast);
  if (not(a)) {
    error();
  }
  visit_filter(ast, js_visit_children_get, js_visit_filter, lambda$v);
}
function promise_not_is(ast) {
  let a = promise_is(ast);
  let n = not(a);
  return n;
}
function promise_is(value) {
  let v = value !== null && typeof value === "object" && typeof value.then === "function" && typeof value.catch === "function";
  return v;
}
function visit_filter(node, children_get, filter, on_each) {
  visit_filter_recursive(node, children_get, filter, on_each, []);
}
function visit_filter_recursive(node, children_get, filter, on_each, stack) {
  let a = filter(node);
  if (not(a)) {
    return;
  }
  list_add(stack, node);
  let children = children_get(node);
  function lambda(c) {
    visit_filter_recursive(c, children_get, filter, on_each, stack);
  }
  each(children, lambda);
  let copy = list_copy(stack);
  on_each({
    node,
    stack: copy
  });
  let removed = list_pop(stack);
  if (removed !== node) {
    error();
  }
}
function list_pop(list) {
  let popped = list.pop();
  return popped;
}
function js_visit_children_get(n) {
  if (list_is(n)) {
    return n;
  }
  if (text_is(n)) {
    let v = [];
    return v;
  }
  function lambda(p) {
    let value = property_get(n, p);
    return value;
  }
  let list = properties_get(n);
  let mapped = list_map(list, lambda);
  return mapped;
}
function js_visit_filter(n) {
  let v = js_node_is(n) || list_is(n);
  return v;
}
function js_literal_is_assert(node) {
  let li = js_literal_is(node);
  assert(li);
}
function js_literal_is(node) {
  let li = js_node_type_is(node, "Literal");
  return li;
}
function js_visit_calls_named(ast, f_name, lambda) {
  function lambda_inner(v) {
    let node = property_get(v, "node");
    let name = js_call_callee_name(node);
    if (equal_not(name, f_name)) {
      return;
    }
    let args = property_get(node, "arguments");
    lambda({
      v,
      args
    });
  }
  js_visit_calls(ast, lambda_inner);
}
function js_visit_calls(ast, lambda_inner) {
  js_visit_type(ast, "CallExpression", lambda_inner);
}
function js_visit_type(ast, type, lambda$v) {
  js_visit_types(ast, [type], lambda$v);
}
function js_call_callee_name(expression) {
  let name = null;
  let jin2 = js_node_type_not_is(expression, "CallExpression");
  if (jin2) {
    return name;
  }
  let callee = property_get(expression, "callee");
  let jin = js_identifier_not_is(callee);
  if (jin) {
    return name;
  }
  name = property_get_name(callee);
  return name;
}
function js_node_type_not_is(node, type) {
  let type_is = js_node_type_is(node, type);
  let nti = not(type_is);
  return nti;
}
function js_identifier_not_is(id) {
  let jin = js_node_type_not_is(id, "Identifier");
  return jin;
}
function property_get_name(item) {
  let name = property_get(item, "name");
  return name;
}
function js_flo(ast) {
  function lambda2(la) {
    function lambda(v) {
      let node = property_get(v, "node");
      la(node);
    }
    js_visit_type(ast, "ExportNamedDeclaration", lambda);
  }
  let nameds = list_adder(lambda2);
  let r = list_single(nameds);
  let declaration = property_get(r, "declaration");
  return declaration;
}
function list_remove_all(list, item) {
  while (list_includes(list, item)) {
    list_remove(list, item);
  }
}
function list_difference(list, other) {
  function lambda2(la) {
    function lambda(l) {
      let a = list_includes(other, l);
      if (not(a)) {
        la(l);
      }
    }
    each(list, lambda);
  }
  let difference = list_adder(lambda2);
  return difference;
}
function list_add_if_not_includes(list, item) {
  "rename includes to exists todo";
  let exists = list_includes(list, item);
  if (not(exists)) {
    list_add(list, item);
  }
}
function js_identifiers_names(ast) {
  function lambda2(la) {
    function lambda(v) {
      let node = property_get(v, "node");
      let value = property_get(node, "name");
      la(value);
    }
    js_visit_type(ast, "Identifier", lambda);
  }
  const names = list_adder_unique(lambda2);
  return names;
}
function function_path_to_name(f_path) {
  let f_name = path_name(f_path);
  return f_name;
}
function path_name(file_path) {
  const filename = path_base(file_path);
  let v = filename.lastIndexOf(".");
  const name = filename.includes(".") ? filename.slice(0, v) : filename;
  return name;
}
function path_base(file_path) {
  const parts = file_path.split(/[/\\]/);
  const filename = parts.pop();
  return filename;
}
async function file_js_parse(f_path) {
  let code = await file_read(f_path);
  const ast = await js_parse_async(code);
  const parsed = {
    ast,
    code,
    f_path
  };
  return parsed;
}
async function js_parse_async(code) {
  const acorn = await import("acorn");
  let v = js_parse_generic(acorn, code);
  return v;
}
function js_parse_generic(acorn, code) {
  let ast = null;
  try {
    ast = acorn.parse(code, {
      ecmaVersion: 2020,
      sourceType: "module"
    });
  } catch (e) {
    log_keep(code);
    throw e;
  }
  return ast;
}
async function functions_paths() {
  async function mapper(folder) {
    let f_names = await functions_names_from_path(folder);
    function lambda2(f_name) {
      let v = function_name_folder_to_path(f_name, folder);
      return v;
    }
    let mapped = list_map(f_names, lambda2);
    return mapped;
  }
  let squashed = await repos_paths_map_unordered_combine_squash(mapper);
  return squashed;
}
async function repos_paths_map_unordered_combine_squash(mapper) {
  let path = functions_path();
  let result = await repos_paths_map_unordered_combine(path, mapper);
  let squashed = list_squash(result);
  return squashed;
}
function list_squash(lists) {
  function lambda2(la) {
    list_process(lists);
    function list_process(list) {
      function lambda(item) {
        let l = list_is(item);
        let fn = null;
        fn = ternary(l, list_process, la);
        fn(item);
      }
      each(list, lambda);
    }
  }
  let squashed = list_adder(lambda2);
  return squashed;
}
async function repos_paths_map_unordered_combine(path, mapper) {
  let result = await repos_paths_map_unordered(each_folder);
  async function each_folder(folder) {
    let joined = path_join([folder, path]);
    let f_names = mapper(joined);
    return f_names;
  }
  return result;
}
async function repos_paths_map_unordered(lambda$folder) {
  let all = await repos_names();
  async function lambda(repo_name) {
    let folder = repo_path(repo_name);
    let mapped = await lambda$folder(folder);
    return mapped;
  }
  let result = await list_map_unordered_async(all, lambda);
  return result;
}
function functions_path() {
  const second = folder_src();
  let joined = folder_public_combine(second);
  return joined;
}
function folder_src() {
  let src = "src";
  return src;
}
function folder_public_combine(f_path) {
  let result = folder_public();
  let combined = path_join([result, f_path]);
  return combined;
}
function folder_public() {
  let v = "public";
  return v;
}
async function functions_names_from_path(path) {
  let paths = await folder_read_files(path);
  function lambda(p) {
    let suffix = function_name_extension();
    let without = text_suffix_without(p, suffix);
    return without;
  }
  let f_names = list_map(paths, lambda);
  return f_names;
}
function text_suffix_without(t, suffix) {
  let a = text_ends_with(t, suffix);
  if (not(a)) {
    error();
  }
  const missing = text_size(suffix);
  const without = string_skip_end(t, missing);
  return without;
}
function string_skip_end(s, missing_count) {
  const from = text_size(s) - missing_count;
  const without = text_slice_0(s, from);
  return without;
}
function text_slice_0(s, from) {
  let sliced = text_slice(s, 0, from);
  return sliced;
}
async function folder_read_files(path_folder) {
  if (browser_is()) {
    path_folder = file_path_normalize(path_folder);
    let r = await folder_read_browser(path_folder);
    let filtered = property_get(r, "filtered");
    let prefix = property_get(r, "prefix");
    let unique = property_get(r, "unique");
    let combineds = list_map_combine_left(unique, prefix);
    let r2 = list_intersect(filtered, combineds);
    let r3 = list_map(r2, path_base);
    return r3;
  }
  let fs = await import("fs");
  function lambda(file) {
    let result = path_join([path_folder, file]);
    let v = fs.statSync(result).isFile();
    return v;
  }
  const all = fs.readdirSync(path_folder);
  let files = all.filter(lambda);
  list_sort_text(files);
  return files;
}
function list_intersect(list, other) {
  let r = list_intersect_multiple([list, other]);
  return r;
}
function list_intersect_multiple(list) {
  let fr = list_first_remaining(list);
  let first = property_get(fr, "first");
  let remaining = property_get(fr, "remaining");
  let e = null_is(remaining);
  if (e) {
    let copy = list_copy(first);
    return copy;
  }
  let uniques = list_map(remaining, list_unique_set);
  function lambda2(la) {
    function lambda(l) {
      function lambda3(set) {
        let v = set_includes(set, l);
        return v;
      }
      let a = list_all(uniques, lambda3);
      if (a) {
        la(l);
      }
    }
    each(first, lambda);
  }
  let i = list_adder(lambda2);
  return i;
}
function list_first_remaining(list) {
  const property_name = "remaining";
  let value_get = list_skip_1;
  let r = list_first_second_generic(list, value_get, property_name);
  return r;
}
function list_first_second_generic(list, other_get, property_name_second) {
  let property_name_first = "first";
  let one_get = list_first;
  let result = list_one_other(list, one_get, other_get, property_name_first, property_name_second);
  return result;
}
function list_one_other(list, one_get, other_get, property_name_one, property_name_other) {
  let one = null;
  let other = null;
  if (list_empty_not_is(list)) {
    one = one_get(list);
    if (list_multiple_is(list)) {
      other = other_get(list);
    }
  }
  let result = {
    [property_name_one]: one,
    [property_name_other]: other
  };
  return result;
}
function list_multiple_is(list) {
  let m = list_size(list) >= 2;
  return m;
}
function list_skip_1(list) {
  let skipped = list_skip(list, 1);
  return skipped;
}
function set_includes(set, item) {
  let si = set.has(item);
  return si;
}
function list_map_combine_left(list, left) {
  function lambda(right) {
    let combined = left + right;
    return combined;
  }
  let combineds = list_map(list, lambda);
  return combineds;
}
function list_sort_text(list) {
  list_sort_text_mapper(list, identity);
}
function list_sort_text_mapper(list, lambda$item) {
  function lambda(a, b) {
    const va = lambda$item(a);
    const vb = lambda$item(b);
    const [na, ia] = va.split(/[_\.]/);
    const [nb, ib] = vb.split(/[_\.]/);
    let v = na.localeCompare(nb) || Number(ia) - Number(ib);
    return v;
  }
  list.sort(lambda);
}
function function_name_folder_to_path(f_name, folder) {
  let base = function_name_to_base(f_name);
  let second = [folder, base];
  let joined = path_join(second);
  return joined;
}
function function_name_to_base(f_name) {
  let f_name_ext = f_name + function_name_extension();
  return f_name_ext;
}
function data_path() {
  let inner = "";
  const folder = data_folder();
  let d_path = data_path_generic(inner, folder);
  return d_path;
}
function data_folder() {
  let d = "data";
  return d;
}
function data_path_generic(suffix, f_name_unsuffixed) {
  const f_name = f_name_unsuffixed + suffix;
  const folder = data_folder();
  let f_path = file_name_json_folder(folder, f_name);
  return f_path;
}
function file_name_json_folder(folder, f_name) {
  let joined = path_join([folder, f_name]);
  let f_path = file_name_json(joined);
  return f_path;
}
async function data_all_initialize(file_path) {
  let exists = await file_exists(file_path);
  if (not(exists)) {
    let contents = json_format_to_truncated({});
    await file_write(file_path, contents);
  }
}
async function file_write(f_path, contents) {
  let overwrite = file_overwrite;
  await file_write_generic(f_path, overwrite, contents);
}
async function file_write_generic(f_path, overwrite, contents) {
  await assert_file_exists_not(f_path);
  await overwrite(f_path, contents);
}
async function assert_file_exists_not(file_path_new) {
  if (await file_exists(file_path_new)) {
    error(file_path_new);
  }
}
async function file_exists(file_path) {
  if (browser_is()) {
    file_path = file_path_normalize(file_path);
    await app_a_file_system_initialize();
    let store = app_a_file_system_store();
    let exists = await indexeddb_exists(app_a_indexeddb_initialize, store, file_path);
    return exists;
  }
  if (promise_is(file_path)) {
    error();
  }
  let fs = await import("fs");
  let v = fs.promises;
  let access = property_get(v, "access");
  let constants = property_get(fs, "constants");
  let exists = await throws_not_async(lambda);
  async function lambda() {
    await access(file_path, constants.F_OK);
  }
  return exists;
}
async function indexeddb_exists(db_get, store, key) {
  const property = "key";
  let all = await indexeddb_get_all(db_get, store);
  list_property_exists_not_error(all, property);
  let s1 = list_find_property_exists(all, property, key);
  return s1;
  let exists = await indexeddb_exists_backend(db_get, store, key);
  return exists;
}
async function indexeddb_exists_backend(db_get, store, key) {
  const db = await db_get();
  const tx = db.transaction(store, "readonly");
  const s = tx.objectStore(store);
  const exists = await new Promise(function lambda3(resolve, reject) {
    const req = s.count(key);
    req.onsuccess = function lambda() {
      let v = resolve(req.result > 0);
      return v;
    };
    req.onerror = function lambda2() {
      let v2 = reject(req.error);
      return v2;
    };
  });
  return exists;
}
function list_find_property_exists(list, property, value) {
  let f = list_filter_property(list, property, value);
  let s1 = list_size_1(f);
  return s1;
}
function list_filter_property(list, property_name, property_value) {
  let filter = property_equals_lambda(property_name, property_value);
  let filtered = list_filter(list, filter);
  return filtered;
}
async function throws_not_async(lambda) {
  let success = null;
  try {
    await lambda();
    success = true;
  } catch (e) {
    success = false;
  }
  return success;
}
async function file_overwrite(file_path, contents) {
  text_is_assert(contents);
  let exists = global_function_property_exists(file_read_cached, file_path);
  if (exists) {
    global_function_property_set(file_read_cached, file_path, contents);
  }
  if (not(exists)) {
    await file_overwrite_uncached(file_path, contents);
  }
}
async function file_overwrite_uncached(file_path, contents) {
  if (browser_is()) {
    file_path = file_path_normalize(file_path);
    await app_a_file_system_initialize();
    let store = app_a_file_system_store();
    async function value_get(previous) {
      const p = "compressed";
      let f = null;
      let nn = null_is(previous);
      if (nn) {
        f = {
          ["versions"]: [""]
        };
        previous = {
          key: file_path
        };
      } else {
        let compressed_before = property_get(previous, p);
        f = await json_decompress(compressed_before);
      }
      let e = text_empty_is(contents);
      if (e) {
        property_set(previous, "deleted", true);
      } else {
        property_delete_if_exists(previous, "deleted");
      }
      let list = property_get(f, "versions");
      list_add(list, contents);
      let compressed_after = await json_compress(f);
      property_set(previous, p, compressed_after);
      return previous;
    }
    let item = await indexeddb_put(app_a_indexeddb_initialize, store, file_path, value_get);
    return;
  } else {
    await file_parent_exists_ensure(file_path);
    let fs = await import("fs");
    await fs.promises.writeFile(file_path, contents, "utf-8");
  }
  await data_file_update(file_path);
  return;
}
function property_delete_if_exists(data, p) {
  let exists = property_exists(data, p);
  if (exists) {
    property_delete(data, p);
  }
}
function text_empty_is(s) {
  const e = s === "";
  return e;
}
async function data_file_update(f_path) {
  return;
  let f_names = await functions_names();
  let f_name = function_path_to_name(f_path);
  let n = list_includes_not(f_names, f_name);
  if (n) {
    return;
  }
  let d_path = data_path();
  var d = await data_all(d_path);
  let parsed = await file_js_parse(f_path);
  data_file_update_inner(parsed, d);
  await data_save(d);
  return;
}
async function functions_names() {
  let f_names = await repos_paths_map_unordered_combine_squash(mapper);
  async function mapper(joined) {
    let f_names = await functions_names_from_path(joined);
    return f_names;
  }
  return f_names;
}
async function data_save(a) {
  let data = property_get(a, "data");
  let file_path = property_get(a, "file_path");
  await file_overwrite_json(file_path, data);
}
async function file_overwrite_json(file_path, object) {
  if (browser_is()) {
    let json = json_format_to_truncated(object);
    await file_overwrite(file_path, json);
    return;
  }
  await file_parent_exists_ensure(file_path);
  "Using " + json_to.name + " did not work on sufficiently large object, whereas this did:";
  let fs = await import("fs");
  const v = await import("stream/promises");
  let pipeline = property_get(v, "pipeline");
  let streamJsonStringify = await (await import_install("stream-json-stringify")).default;
  const out = fs.createWriteStream(file_path);
  let json = streamJsonStringify(object);
  await pipeline(json, out);
}
async function file_parent_exists_ensure(file_path) {
  await file_root_exists_assert(file_path);
  let path = await import("path");
  const dir = path.dirname(file_path);
  await folder_exists_ensure(dir);
}
async function folder_exists_ensure(dir) {
  let fs = await import("fs");
  let path = await import("path");
  await fs.promises.mkdir(dir, {
    recursive: true
  });
  return path;
}
async function file_root_exists_assert(file_path) {
  let {exists, root} = await file_root_exists(file_path);
  assert_json(exists, {
    file_path,
    root,
    message: "root does not exist"
  });
}
async function file_root_exists(file_path) {
  let path = await import("path");
  let parsed = path.parse(file_path);
  let root = property_get(parsed, "root");
  let en = text_empty_not_is(root);
  let exists = true;
  if (en) {
    async function lambda2() {
      let fs = await import("fs");
      await fs.promises.access(root);
    }
    exists = await throws_not_async(lambda2);
  }
  let v = {
    exists,
    root
  };
  return v;
}
function text_empty_not_is(name) {
  let a = text_empty_is(name);
  const ne = not(a);
  return ne;
}
async function import_install(name) {
  try {
    let v = await import(name);
    return v;
  } catch (err) {
    if (err.code === "ERR_MODULE_NOT_FOUND" || err.code === "MODULE_NOT_FOUND") {
      await npm_install(name);
      let v2 = await import(name);
      return v2;
    }
    throw err;
  }
}
async function npm_install(package_name) {
  await command_line("npm install " + package_name + "@latest");
}
async function command_line(command) {
  let extra = {};
  const stdout = await command_line_generic(command, extra);
  return stdout;
}
async function command_line_generic(command, extra) {
  const {exec} = await import("child_process");
  const {promisify} = await import("util");
  const execAsync = promisify(exec);
  const options = {
    encoding: "utf8"
  };
  object_merge(options, extra);
  const stdout = await execAsync(command, options);
  return stdout;
}
async function indexeddb_put(db_get, store, key, value_get) {
  let all = await indexeddb_get_all(db_get, store);
  let f = list_find_property_or_null(all, "key", key);
  const next = await value_get(f);
  log({
    next
  });
  if (null_is(f)) {
    list_add(all, next);
  } else {
    object_replace(f, next);
  }
  async function lambda_async() {
    await indexeddb_put_backend(db_get, store, key, next);
  }
  indexeddb_next(lambda_async);
  return next;
}
function list_find_property_or_null(list, property_name, property_value) {
  let filter = property_equals_lambda(property_name, property_value);
  let filtered = list_filter(list, filter);
  let e = list_empty_is(filtered);
  if (e) {
    let v = null;
    return v;
  }
  let only = list_single(filtered);
  return only;
}
async function indexeddb_put_backend(db_get, store, key, next) {
  const db = await db_get();
  if (false) {
    const previous = await new Promise(function lambda3(resolve, reject) {
      const tx = db.transaction(store, "readonly");
      const s = tx.objectStore(store);
      const req = s.get(key);
      req.onsuccess = function lambda() {
        let v = resolve(req.result ?? null);
        return v;
      };
      req.onerror = function lambda2() {
        let v2 = reject(req.error);
        return v2;
      };
    });
  }
  const tx = db.transaction(store, "readwrite");
  const s = tx.objectStore(store);
  s.put(next);
  await new Promise(function lambda6(resolve, reject) {
    tx.oncomplete = resolve;
    tx.onerror = function lambda4() {
      let v3 = reject(tx.error);
      return v3;
    };
    tx.onabort = function lambda5() {
      let v4 = reject(tx.error);
      return v4;
    };
  });
}
function object_replace(to, from) {
  if (equal_not(to, from)) {
    properties_delete_all(to);
    object_merge(to, from);
  }
}
function properties_delete_all(obj) {
  function lambda(p) {
    let v = property_delete(obj, p);
    return v;
  }
  let list = properties_get(obj);
  each(list, lambda);
}
function user_repo_path() {
  const name = "user";
  let f_path = file_name_json_folder_gitignore(name);
  return f_path;
}
function file_name_json_folder_gitignore(name) {
  let f_path2 = file_name_json_folder("gitignore", name);
  return f_path2;
}
async function firebase_service_account() {
  let f_name = await user_repo_firebase_service_account_get();
  let file_path = await function_run_unalias(f_name, []);
  let service_account = await file_read_json(file_path);
  return service_account;
}
async function function_run_unalias(f_name, args) {
  const fn = await function_import_unalias(f_name);
  const result = await fn(...args);
  return result;
}
async function function_import_unalias(f_name) {
  let v = await function_name_unalias(f_name);
  let unaliased = property_get(v, "unaliased");
  const imported_fn = await function_import(unaliased);
  return imported_fn;
}
async function function_import(f_name) {
  "if you need to unalias use " + function_import_unalias.name;
  let v2 = await function_name_to_path_search(f_name);
  let f = property_get(v2, "f_path");
  let f_path = await path_resolve(f);
  const imported = await import(`file://${f_path}`);
  const imported_fn = imported[f_name];
  if (typeof imported_fn !== "function") {
    throw new Error(`‚ùå The module "${f_name}" does not export a default function.`);
  }
  return imported_fn;
}
async function path_resolve(paths) {
  let path = await import("path");
  let v = path.resolve(paths);
  return v;
}
async function function_name_to_path_search(f_name) {
  let f_path = function_name_to_path(f_name);
  async function lambda(joined) {
    let exists = await file_exists(joined);
    let v = {
      exists,
      f_path: joined
    };
    return v;
  }
  let mapped = await repos_paths_names_map_unordered_combine(f_path, lambda);
  function lambda2(m) {
    let mapped = property_get(m, "mapped");
    let exists2 = property_get(mapped, "exists");
    let ti2 = true_is(exists2);
    return ti2;
  }
  let filtered = list_filter(mapped, lambda2);
  let multiple = list_multiple_is(filtered);
  let exists = list_size_1(filtered);
  let search = {
    f_name,
    exists,
    multiple
  };
  if (exists) {
    let only = list_single(filtered);
    let mapped = property_get(only, "mapped");
    property_from(search, "f_path", mapped);
    property_from(search, "repo_name", only);
  }
  return search;
}
function property_from(to, property_name, from) {
  let value = property_get(from, property_name);
  property_set(to, property_name, value);
}
async function repos_paths_names_map_unordered_combine(path, mapper) {
  let result = await repos_paths_names_map_unordered(each_folder);
  async function each_folder(repo_name, r_path) {
    let joined = path_join([r_path, path]);
    let mapped = await mapper(joined);
    let v = {
      mapped,
      repo_name
    };
    return v;
  }
  return result;
}
async function repos_paths_names_map_unordered(lambda$name$path) {
  let all = await repos_names();
  async function lambda(repo_name) {
    let path = repo_path(repo_name);
    let mapped = await lambda$name$path(repo_name, path);
    return mapped;
  }
  let result = await list_map_unordered_async(all, lambda);
  return result;
}
function true_is(value) {
  let ti = equal(value, true);
  return ti;
}
function function_name_to_path(f_name) {
  if (text_includes(f_name, ".")) {
    error_json({
      f_name
    });
  }
  let folder = functions_path();
  let f_path = function_name_folder_to_path(f_name, folder);
  return f_path;
}
function text_includes(input, part) {
  const o = {
    input,
    part
  };
  text_is_assert_json(input, o);
  text_is_assert_json(part, o);
  let i = input.includes(part);
  return i;
}
function text_is_assert_json(value, o) {
  let message = json_to(o);
  text_is_assert_message(value, message);
}
function text_is_assert_message(value, message) {
  let b = text_is(value);
  let v = assert_message(b, message);
  return v;
}
async function function_name_unalias(f_name) {
  assert_arguments(arguments, 1);
  var v2 = await function_alias_add_generic(f_name);
  let unaliased_actual = property_get(v2, "unaliased");
  let exists = property_get(v2, "exists");
  let v3 = await function_acronym_to_name(f_name);
  let expandeds = property_get(v3, "expandeds");
  let expanded = property_get(v3, "expanded");
  const unaliased = exists ? unaliased_actual : expanded !== null ? expanded : f_name;
  let v = {
    unaliased,
    expandeds
  };
  return v;
}
async function function_acronym_to_name(alias) {
  let expanded = null;
  let expandeds = null;
  let acronyms = await function_names_to_acronyms();
  const exists2 = property_exists(acronyms, alias);
  if (exists2) {
    expandeds = property_get(acronyms, alias);
    let s1 = list_size_1(expandeds);
    if (s1) {
      expanded = list_single(expandeds);
    }
  }
  let v = {
    expanded,
    expandeds
  };
  return v;
}
async function function_names_to_acronyms() {
  let f_names = await functions_names();
  let result = global_function_cache(function_names_to_acronyms, f_names, value_get);
  return result;
  function value_get() {
    let dictionary = list_to_dictionary_value(f_names, function_name_to_acronym);
    let acronyms = object_invert(dictionary);
    return acronyms;
  }
}
function global_function_cache(fn, key, value_get) {
  let c = global_function_initialize(fn, {
    json: null,
    result: null
  });
  let result = global_function_cache_generic(key, c, value_get);
  return result;
}
function object_invert(object) {
  let inverted = {};
  function lambda(value, key) {
    undefined_not_is_assert(value);
    let list = property_initialize(inverted, value, []);
    list_add(list, key);
  }
  each_object(object, lambda);
  return inverted;
}
function function_name_to_acronym(f_name) {
  let parts = function_name_to_parts(f_name);
  let letters = null;
  try {
    letters = list_map(parts, list_first);
  } catch (e) {
    "if this error, then maybe string empty, __ instead of _ or ends with _";
    error_json({
      e,
      f_name
    });
  }
  let acronym = list_join_empty(letters);
  return acronym;
}
function function_name_to_parts(f_name) {
  let separator = function_name_separator();
  let parts = text_split(f_name, separator);
  return parts;
}
function list_to_dictionary_value(list, lambda$item) {
  let key_get = identity;
  let dictionary = list_to_dictionary(list, lambda$item, key_get);
  return dictionary;
}
async function function_alias_add_generic(alias) {
  let unaliased = null;
  let d_path = data_aliases_path();
  var {value: aliases, file_path, data} = await data_get("aliases", {}, d_path);
  const exists = property_exists(aliases, alias);
  if (exists) {
    unaliased = property_get(aliases, alias);
  }
  let v = {
    exists,
    aliases,
    file_path,
    data,
    unaliased
  };
  return v;
}
function data_aliases_path() {
  let f_path = data_path_generic("", "aliases");
  return f_path;
}
async function user_repo_firebase_service_account_get() {
  let repo_name = await user_repo_get();
  let v = await repo_firebase_service_account_get(repo_name);
  return v;
}
async function repo_firebase_service_account_get(repo_name) {
  const key = "firebase_service_account";
  let v = await repo_about_get(repo_name, key);
  return v;
}
async function repo_about_get(repo, key) {
  let a_path = path_repo_about(repo);
  let {value} = await data_get(key, null, a_path);
  let v = value;
  return v;
}
function path_repo_about(repo) {
  let f_path = data_path_generic("", "about");
  let a_path = path_repo_combine(repo, f_path);
  return a_path;
}
function path_repo_combine(repo, f_path) {
  let r_path = repo_path(repo);
  let joined = path_join([r_path, f_path]);
  return joined;
}
function firebase_path_fix(path) {
  let replaced = text_replace(path, "\\", "/");
  return replaced;
}
function text_replace(s, from, to) {
  let split = text_split(s, from);
  let replaced = list_join(split, to);
  return replaced;
}
async function firebase_storage_url(storage_path) {
  let replaced = text_replace(storage_path, "/", "%2F");
  let url = "https://firebasestorage.googleapis.com/v0/b/" + await firebase_storage_url_project() + "/o/" + replaced + "?alt=media";
  return url;
}
app_context_initialize( app_replace_main );
  </script>
</body>
</html>