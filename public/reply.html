<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>reply</title>
</head>
<body>
  <script type="module"> 
    let global = {};
    app_reply(  );
    async function app_reply() {
  marker("1");
  let f_name = app_reply_main.name;
  await firebase_storage_function_run(f_name);
}
async function app_reply_main() {
  global_function_initialize(firebase_name, "jared-grace");
  let en = ebible_folder_english();
  let languages = ebible_languages();
  list_remove_property(languages, "language_code", "en");
  let file_name = ebible_index_flat_upload_name();
  let index = await firebase_storage_download_ebible(en, file_name);
  let books = await ebible_version_books(en);
  let verses_list = null;
  await verse_random_reset();
  const root = html_document_body();
  let copied = [];
  let languages_chosens = [];
  let buttons = null;
  let preview = null;
  let chosens = [];
  let typed = "";
  async function verse_random_reset() {
    let encouragement = bible_verses_encouragement();
    let reference = list_random_item(encouragement);
    let verses = await ebible_references_parse_lines([en], [reference]);
    verses_list = [{
      verses,
      reference
    }];
  }
  function lambda6(event) {
    let key = object_property_get(event, "key");
    if (equal(key, "Backspace")) {
      typed = string_take_less_1(typed);
    } else {
      typed += key;
    }
    buttons_refresh();
  }
  html_on_keydown(root, lambda6);
  async function lambda4() {
    await verse_random_reset();
    list_empty(copied);
    list_empty(chosens);
    list_empty(languages_chosens);
    typed = "";
    buttons_refresh();
    preview_refresh();
  }
  let component3 = html_button(root, "Reset", lambda4);
  let component2 = html_button(root, "Copy", preview_refresh);
  function lambda5(item2) {
    let name2 = object_property_get(item2, "name");
    let bible_folder2 = object_property_get(item2, "bible_folder");
    let language_code = object_property_get(item2, "language_code");
    async function lambda7() {
      let verses_list_first = list_first(verses_list);
      let verses2 = object_property_get(verses_list_first, "verses");
      let reference = object_property_get(verses_list_first, "reference");
      async function lambda8(verse) {
        let chapter_code2 = object_property_get(verse, "chapter_code");
        let verse_number2 = object_property_get(verse, "verse_number");
        let d = await ebible_verse_download(bible_folder2, chapter_code2, verse_number2);
        return d;
      }
      let verses = await list_map_unordered_async(verses2, lambda8);
      list_add_first(verses_list, {
        verses,
        reference
      });
      list_add_first(languages_chosens, language_code);
      preview_refresh();
    }
    let component4 = html_button(root, name2, lambda7);
  }
  each(languages, lambda5);
  marker("1");
  let choices = app_reply_choices();
  function buttons_refresh() {
    function lambda2(item) {
      let text2 = object_property_get(item, "text");
      let letters = string_letters_only(text2);
      let lower = string_lower_to(letters);
      let sw = string_starts_with(lower, typed);
      let includes = list_includes(chosens, item);
      const condition = includes || not(sw);
      html_display_none_or_block(condition, item);
    }
    each(buttons, lambda2);
  }
  function lambda(choice) {
    let response2 = object_property_get(choice, "response");
    let text = object_property_get(choice, "text");
    let component = html_button(root, text, lambda3);
    object_property_set_exists_not(component, "text", text);
    async function lambda3() {
      list_add(copied, response2);
      await preview_refresh();
      list_add(chosens, component);
      typed = "";
      buttons_refresh();
    }
    return component;
  }
  buttons = list_map(choices, lambda);
  preview = html_p(root);
  preview_refresh();
  buttons_refresh();
  async function preview_refresh() {
    let verses_list_first = list_first(verses_list);
    let reference = object_property_get(verses_list_first, "reference");
    if (false) {
      function lambda9(item3) {}
      each(list, lambda9);
      let chapter_code2 = object_property_get(verse, "chapter_code");
      let book_code = ebible_chapter_code_to_book(chapter_code2);
      let chapter_name = ebible_chapter_code_to_name(chapter_code2);
      let book = list_find_property(books, "book_code", book_code);
      let book_name = object_property_get(book, "text");
      let verse_number2 = object_property_get(verse, "verse_number");
      let reference2 = book_name + " " + chapter_name + ":" + verse_number2;
    }
    let verses = list_map_property(verses_list, "verses");
    let squashed = list_squash(verses);
    let verse_texts = list_map_property(squashed, "text");
    list_add_first(verse_texts, reference);
    let verse_text = list_join_newline_2(verse_texts);
    const other = [verse_text];
    let ne = list_empty_not_is(languages_chosens);
    if (ne) {
      list_add(other, languages_chosens);
    }
    let concated = list_concat(copied, other);
    let joined = list_join_newline_2(concated);
    html_clear(preview);
    html_p_text_multiple(preview, concated);
    html_text_set(preview, joined);
    await clipboard_copy(joined);
  }
}
async function firebase_name() {
  if (browser_is()) {
    let value = global_function_get(firebase_name);
    return value;
  }
  let repo_name = await user_repo_get();
  let default2 = await firebase_name_repo(repo_name);
  return default2;
}
async function firebase_name_repo(repo_name) {
  const f_path = ".firebaserc";
  let combined = repo_path_combine(repo_name, f_path);
  let f = await file_read_json(combined);
  let projects = object_property_get(f, "projects");
  let default2 = object_property_get(projects, "default");
  return default2;
}
function object_property_get(object, property_name) {
  let value = object[property_name];
  undefined_not_is_assert_lambda(value, object_get);
  function object_get() {
    let v = {
      object,
      property_name
    };
    return v;
  }
  return value;
}
function undefined_not_is_assert_lambda(value, lambda) {
  if (undefined_is(value)) {
    const object = lambda();
    let message = json_to(object);
    error(message);
  }
}
function error(message) {
  throw new Error(message);
}
function json_to(object) {
  let json = JSON.stringify(object);
  return json;
}
function undefined_is(value) {
  let v = typeof value === "undefined";
  return v;
}
async function file_read_json(file_path) {
  let json = await file_read(file_path);
  let data = json_from(json);
  return data;
}
async function file_read(file_path) {
  let fs = await import("fs");
  let contents = await fs.promises.readFile(file_path, "utf-8");
  return contents;
}
function json_from(json) {
  let v = JSON.parse(json);
  return v;
}
function repo_path_combine(repo_name, f_path) {
  let folder_name = repo_path(repo_name);
  let combined = path_join([folder_name, f_path]);
  return combined;
}
function path_join(segments) {
  assert_arguments(arguments, 1);
  let parts = [];
  for (let seg of segments) {
    if (not(seg)) {
      continue;
    }
    let split = seg.split(/[\\/]+/);
    for (let s of split) {
      if (s === "" || s === ".") {
        continue;
      }
      if (s === folder_previous()) {
        if (parts.length > 0 && parts[parts.length - 1] !== folder_previous()) {
          parts.pop();
        } else {
          let previous = folder_previous();
          parts.push(previous);
        }
      } else {
        parts.push(s);
      }
    }
  }
  let joined = parts.join("/");
  return joined;
}
function assert_arguments(args, count) {
  let length = object_property_get(args, "length");
  equal_assert(length, count);
}
function equal_assert(left, right) {
  marker("1");
  let eq = equal(left, right);
  assert(eq);
}
function marker(marker_name) {
  noop();
}
function noop() {}
function assert(b) {
  if (not(b)) {
    error();
  }
}
function not(a) {
  let n = !a;
  return n;
}
function equal(left, right) {
  let eq = left === right;
  return eq;
}
function folder_previous() {
  let previous = "..";
  return previous;
}
function repo_path(repo_name) {
  marker("1");
  let previous = repos_folder();
  let r_path = path_join([previous, repo_name]);
  return r_path;
}
function repos_folder() {
  let previous = folder_previous();
  return previous;
}
function global_function_get(fn) {
  let global = global_get();
  let value = object_property_get(global, fn.name);
  return value;
}
function global_get() {
  marker("1");
  return global;
}
function browser_is() {
  let b = typeof window !== "undefined" && typeof window.document !== "undefined";
  return b;
}
async function user_repo_get() {
  marker("1");
  let f_path = user_repo_path();
  let {value: repo_name} = await data_get("repo_current", null, f_path);
  await repo_exists_assert(repo_name);
  return repo_name;
}
async function repo_exists_assert(repo_name) {
  let all = await repos_names();
  list_includes_assert(all, repo_name);
}
function list_includes_assert(all, repo_name) {
  let includes = list_includes(all, repo_name);
  assert(includes);
}
function list_includes(list, item) {
  const includes = list.includes(item);
  return includes;
}
async function repos_names() {
  marker("1");
  let path_folder = repos_folder();
  let rns = await folder_read(path_folder);
  return rns;
}
async function folder_read(path_folder) {
  marker("1");
  let fs = await import("fs");
  const all = await fs.promises.readdir(path_folder);
  return all;
}
async function data_get(property_name, value_initial, d_path) {
  marker("1");
  var {data, file_path} = await data_all(d_path);
  let value = object_property_initialize(data, property_name, value_initial);
  let v = {
    value,
    file_path,
    data
  };
  return v;
}
async function data_all(file_path) {
  marker("1");
  let data = {};
  let d_path = data_path();
  if (equal(file_path, d_path)) {
    await data_generate(data);
    if (false) {
      async function lambda2() {
        await data_generate(data);
        return data;
      }
      data = await global_function_property_async(data_all, d_path, lambda2);
    }
  } else {
    let exists = await file_exists(file_path);
    if (not(exists)) {
      let contents = json_format_to({});
      await file_write(file_path, contents);
    }
    data = await file_read_json(file_path);
  }
  let v = {
    data,
    file_path
  };
  return v;
}
async function data_generate(data) {
  let f_paths = await functions_paths();
  let parseds = await list_map_unordered_async(f_paths, file_js_parse);
  async function lambda(parsed) {
    data_file_update_inner(parsed, data);
  }
  each(parseds, lambda);
}
function each(list, lambda$item) {
  marker("1");
  for (let item of list) {
    lambda$item(item);
  }
}
function data_file_update_inner(parsed, data) {
  let {f_path} = parsed;
  let f_name = function_path_to_name(f_path);
  let {ast} = parsed;
  let f_identifiers_new = js_identifiers_names(ast);
  const property_name = "identifiers";
  let identifiers = object_property_initialize(data, property_name, {});
  function lambda2(i_name) {
    let list = object_property_initialize(identifiers, i_name, []);
    list_add_if_not_includes(list, f_name);
  }
  each(f_identifiers_new, lambda2);
  let functions = object_property_initialize(data, "functions", {});
  let f_this = object_property_initialize(functions, f_name, {});
  let declaration = js_declaration_single(ast);
  let async_is = object_property_get(declaration, "async");
  object_property_set(f_this, "async", async_is);
  let f_identifiers_old = object_property_initialize(f_this, property_name, []);
  let removals = list_difference(f_identifiers_old, f_identifiers_new);
  function lambda(item) {
    let list = object_property_initialize(identifiers, item, []);
    list_remove_all(list, f_name);
    let e = list_empty_is(list);
    if (e) {
      object_property_delete(identifiers, item);
    }
  }
  each(removals, lambda);
  object_property_set(f_this, property_name, f_identifiers_new);
}
function js_declaration_single(ast) {
  function lambda2(la) {
    function lambda(v) {
      let {node} = v;
      la(node);
    }
    js_visit_type(ast, "ExportNamedDeclaration", lambda);
  }
  let nameds = list_adder(lambda2);
  let {declaration} = list_single(nameds);
  return declaration;
}
function list_adder(lambda$la) {
  let fn = list_add;
  let list = list_adder_generic(lambda$la, fn);
  return list;
}
function list_adder_generic(lambda, fn) {
  let list = [];
  function list_adder_inner(item) {
    fn(list, item);
  }
  lambda(list_adder_inner);
  return list;
}
function list_add(list, item) {
  list.push(item);
}
function list_single(list) {
  list_size_1_assert(list);
  let only = list_first(list);
  return only;
}
function list_size_1_assert(list) {
  let message = list_size(list);
  let message2 = string_to(message);
  list_size_1_assert_message(list, message2);
}
function list_size_1_assert_message(list, message) {
  let a = list_size_1(list);
  if (not(a)) {
    error(message);
  }
}
function list_size_1(list) {
  const s1 = list_size(list) === 1;
  return s1;
}
function list_size(list) {
  list_is_assert(list);
  let size = list.length;
  return size;
}
function list_is_assert(list) {
  let result = list_is(list);
  function lambda() {
    let v = {
      list
    };
    return v;
  }
  assert_json_get(result, lambda);
  return;
}
function assert_json_get(b, lambda) {
  marker("1");
  function lambda2() {
    let object = lambda();
    let json = json_to(object);
    return json;
  }
  let v = assert_message_get(b, lambda2);
  return v;
}
function assert_message_get(b, lambda) {
  marker("1");
  if (not(b)) {
    let message = lambda();
    error(message);
  }
}
function list_is(value) {
  const l = Array.isArray(value);
  return l;
}
function string_to(input) {
  const s = input.toString();
  return s;
}
function list_first(list) {
  const index = 0;
  const first = list_get(list, index);
  return first;
}
function list_get(list, index) {
  integer_is_assert(index);
  let item = list[index];
  undefined_not_is_assert_lambda(item, object_get);
  function object_get() {
    let v = {
      list,
      index
    };
    return v;
  }
  return item;
}
function integer_is_assert(index) {
  let ii = integer_is(index);
  assert_json(ii, {
    index
  });
}
function assert_json(b, o) {
  let message = json_to(o);
  assert_message(b, message);
}
function assert_message(b, message) {
  if (not(b)) {
    error(message);
  }
}
function integer_is(value) {
  marker("1");
  let ii = Number.isInteger(value);
  return ii;
}
function js_visit_type(ast, type, lambda$v) {
  js_visit_types(ast, [type], lambda$v);
}
function js_visit_types(ast, types, lambda$v) {
  marker("1");
  function lambda(v) {
    let {node} = v;
    if (js_node_is(node) && js_node_types_is(node, types)) {
      lambda$v(v);
    }
  }
  js_visit(ast, lambda);
}
function js_node_types_is(item, types) {
  function lambda2(type) {
    let type_is = js_node_type_is(item, type);
    return type_is;
  }
  const match = list_any(types, lambda2);
  return match;
}
function list_any(list, lambda$item) {
  marker("1");
  let filtered = list_filter(list, lambda$item);
  let any = list_empty_not_is(filtered);
  return any;
}
function list_empty_not_is(list) {
  let a = list_empty_is(list);
  const ne = not(a);
  return ne;
}
function list_empty_is(list) {
  const e = list_size(list) === 0;
  return e;
}
function list_filter(list, lambda$item) {
  let l = list_is(list);
  assert(l);
  function lambda(item) {
    let match = lambda$item(item);
    return match;
  }
  let filtered = list.filter(lambda);
  return filtered;
}
function js_node_type_is(node, type) {
  const type_is = js_node_is(node) && js_node_type(node) === type;
  return type_is;
}
function js_node_is(n) {
  const ni = object_property_exists(n, "type");
  return ni;
}
function object_property_exists(object, property_name) {
  const exists = object && Object.hasOwn(object, property_name);
  return exists;
}
function js_node_type(n) {
  const nt = object_property_get(n, "type");
  return nt;
}
function js_visit(ast, lambda$v) {
  let a = promise_not_is(ast);
  if (not(a)) {
    error();
  }
  visit_filter(ast, js_visit_children_get, js_visit_filter, lambda$v);
}
function promise_not_is(ast) {
  let a = promise_is(ast);
  let n = not(a);
  return n;
}
function promise_is(value) {
  let v = value !== null && typeof value === "object" && typeof value.then === "function" && typeof value.catch === "function";
  return v;
}
function visit_filter(node, children_get, filter, on_each) {
  visit_filter_recursive(node, children_get, filter, on_each, []);
}
function visit_filter_recursive(node, children_get, filter, on_each, stack) {
  let a = filter(node);
  if (not(a)) {
    return;
  }
  list_add(stack, node);
  let children = children_get(node);
  function lambda(c) {
    visit_filter_recursive(c, children_get, filter, on_each, stack);
  }
  each(children, lambda);
  let copy = list_copy(stack);
  on_each({
    node,
    stack: copy
  });
  let removed = list_pop(stack);
  if (removed !== node) {
    error();
  }
}
function list_pop(list) {
  let v = list.pop();
  return v;
}
function list_copy(original) {
  const copy = [...original];
  return copy;
}
function js_visit_children_get(n) {
  if (list_is(n)) {
    return n;
  }
  if (string_is(n)) {
    let v = [];
    return v;
  }
  function lambda(p) {
    let value = object_property_get(n, p);
    return value;
  }
  let list = object_properties(n);
  let mapped = list_map(list, lambda);
  return mapped;
}
function object_properties(obj) {
  const properties = Object.getOwnPropertyNames(obj);
  return properties;
}
function string_is(value) {
  let si = typeof value === "string";
  return si;
}
function list_map(list, lambda$item) {
  list_is_assert(list);
  let mapped = list.map(lambda$item);
  return mapped;
}
function js_visit_filter(n) {
  let v = js_node_is(n) || list_is(n);
  return v;
}
function object_property_set(object, property_name, value) {
  object[property_name] = value;
}
function object_property_delete(object, property_name) {
  delete object[property_name];
}
function list_remove_all(list, item) {
  while (list_includes(list, item)) {
    list_remove(list, item);
  }
}
function list_remove(list, item) {
  const index = list_index_of(list, item);
  list_remove_at(list, index);
}
function list_remove_at(list, index) {
  list.splice(index, 1);
}
function list_index_of(list, item) {
  let index = list.indexOf(item);
  if (index <= -1) {
    error_json({
      list,
      item,
      index
    });
  }
  return index;
}
function error_json(o) {
  let message = json_format_to(o);
  error(message);
}
function json_format_to(object) {
  let v = JSON.stringify(object, null, 1);
  return v;
}
function list_difference(list, other) {
  function lambda2(la) {
    function lambda(l) {
      let a = list_includes(other, l);
      if (not(a)) {
        la(l);
      }
    }
    each(list, lambda);
  }
  let difference = list_adder(lambda2);
  return difference;
}
function list_add_if_not_includes(list, item) {
  "rename includes to exists todo";
  let exists = list_includes(list, item);
  if (not(exists)) {
    list_add(list, item);
  }
}
function object_property_initialize(object, property_name, value_initial) {
  const exists = object_property_exists(object, property_name);
  if (not(exists)) {
    object_property_set(object, property_name, value_initial);
  }
  let value = object_property_get(object, property_name);
  return value;
}
function js_identifiers_names(ast) {
  function lambda2(la) {
    function lambda(v) {
      let {node} = v;
      let value = object_property_get(node, "name");
      la(value);
    }
    js_visit_type(ast, "Identifier", lambda);
  }
  const names = list_adder_unique(lambda2);
  return names;
}
function list_adder_unique(lambda) {
  let items = list_adder(lambda);
  let unique = list_unique(items);
  return unique;
}
function list_unique(list) {
  let unique = [];
  function lambda(item) {
    let a = list_includes(unique, item);
    if (not(a)) {
      list_add(unique, item);
    }
  }
  each(list, lambda);
  return unique;
}
function function_path_to_name(f_path) {
  let f_name = path_name(f_path);
  return f_name;
}
function path_name(file_path) {
  const parts = file_path.split(/[/\\]/);
  const filename = parts.pop();
  let v = filename.lastIndexOf(".");
  const name = filename.includes(".") ? filename.slice(0, v) : filename;
  return name;
}
async function file_js_parse(f_path) {
  let code = await file_read(f_path);
  const ast = await js_parse_async(code);
  const parsed = {
    ast,
    code,
    f_path
  };
  return parsed;
}
async function js_parse_async(code) {
  const acorn = await import("acorn");
  marker("1");
  let v = js_parse_generic(acorn, code);
  return v;
}
function js_parse_generic(acorn, code) {
  let ast = null;
  try {
    ast = acorn.parse(code, {
      ecmaVersion: 2020,
      sourceType: "module"
    });
  } catch (e) {
    log_keep(code);
    throw e;
  }
  return ast;
}
function log_keep(message) {
  console.log(message);
}
function log(message) {
  log_keep(message);
}
async function list_map_unordered_async(list, lambda$item) {
  let mapped = list_map(list, lambda$item);
  let waited = await list_wait(mapped);
  return waited;
}
async function list_wait(list) {
  let v = await Promise.all(list);
  return v;
}
async function functions_paths() {
  marker("1");
  async function mapper(folder) {
    let f_names = await functions_names_from_path(folder);
    function lambda2(f_name) {
      let v = function_name_folder_to_path(f_name, folder);
      return v;
    }
    let mapped = list_map(f_names, lambda2);
    return mapped;
  }
  let squashed = await repos_paths_map_unordered_combine_squash(mapper);
  return squashed;
}
async function repos_paths_map_unordered_combine_squash(mapper) {
  let path = functions_path();
  let result = await repos_paths_map_unordered_combine(path, mapper);
  let squashed = list_squash(result);
  return squashed;
}
function list_squash(list) {
  function lambda2(la) {
    list_process(list);
    function list_process(list) {
      function lambda(item) {
        let l = list_is(item);
        let fn = null;
        if (l) {
          fn = list_process;
        } else {
          fn = la;
        }
        fn(item);
      }
      each(list, lambda);
    }
  }
  let squashed = list_adder(lambda2);
  return squashed;
}
async function repos_paths_map_unordered_combine(path, mapper) {
  let result = await repos_paths_map_unordered(each_folder);
  async function each_folder(folder) {
    let joined = path_join([folder, path]);
    let f_names = mapper(joined);
    return f_names;
  }
  return result;
}
async function repos_paths_map_unordered(lambda$folder) {
  marker("1");
  let all = await repos_names();
  async function lambda(repo_name) {
    let folder = repo_path(repo_name);
    let mapped = await lambda$folder(folder);
    return mapped;
  }
  let result = await list_map_unordered_async(all, lambda);
  return result;
}
function functions_path() {
  const second = folder_src();
  let joined = folder_public_combine(second);
  return joined;
}
function folder_src() {
  let src = "src";
  return src;
}
function folder_public_combine(f_path) {
  let result = folder_public();
  let combined = path_join([result, f_path]);
  return combined;
}
function folder_public() {
  let v = "public";
  return v;
}
async function functions_names_from_path(path) {
  let paths = await folder_read_files(path);
  function lambda(p) {
    let suffix = function_name_extension();
    let without = string_suffix_without(p, suffix);
    return without;
  }
  let f_names = list_map(paths, lambda);
  return f_names;
}
function string_suffix_without(s, suffix) {
  let a = string_ends_with(s, suffix);
  if (not(a)) {
    error();
  }
  const without = string_slice(s, 0, string_size(s) - string_size(suffix));
  return without;
}
function string_ends_with(s, suffix) {
  const ew = s.endsWith(suffix);
  return ew;
}
function string_slice(s, a, b) {
  let v = s.slice(a, b);
  return v;
}
function string_size(s) {
  let v = s.length;
  return v;
}
function function_name_extension() {
  const ext = ".mjs";
  return ext;
}
async function folder_read_files(path_folder) {
  let fs = await import("fs");
  marker("1");
  function lambda(file) {
    let result = path_join([path_folder, file]);
    let v = fs.statSync(result).isFile();
    return v;
  }
  const all = fs.readdirSync(path_folder);
  let files = all.filter(lambda);
  return files;
}
function function_name_folder_to_path(f_name, folder) {
  let base = function_name_to_base(f_name);
  let second = [folder, base];
  let joined = path_join(second);
  return joined;
}
function function_name_to_base(f_name) {
  let f_name_ext = f_name + function_name_extension();
  return f_name_ext;
}
async function global_function_property_async(fn, property_name, lambda) {
  let global = global_get();
  marker("1");
  let fn_object = object_property_initialize(global, fn.name, {});
  let value = await object_property_lambda_async(fn_object, property_name, lambda);
  return value;
}
async function object_property_lambda_async(object, property_name, lambda) {
  marker("1");
  const exists = object_property_exists(object, property_name);
  if (not(exists)) {
    let value_set = await lambda();
    object_property_set(object, property_name, value_set);
  }
  let value = object_property_get(object, property_name);
  return value;
}
async function file_write(f_path, contents) {
  let overwrite = file_overwrite;
  await file_write_generic(f_path, overwrite, contents);
}
async function file_write_generic(f_path, overwrite, contents) {
  await assert_file_exists_not(f_path);
  await overwrite(f_path, contents);
}
async function assert_file_exists_not(file_path_new) {
  if (await file_exists(file_path_new)) {
    error(file_path_new);
  }
}
async function file_exists(file_path) {
  marker("1");
  if (promise_is(file_path)) {
    error();
  }
  let fs = await import("fs");
  let {access} = fs.promises;
  let {constants} = fs;
  let exists = await throws_not_async(lambda);
  async function lambda() {
    await access(file_path, constants.F_OK);
  }
  return exists;
}
async function throws_not_async(lambda) {
  let success = null;
  try {
    await lambda();
    success = true;
  } catch (e) {
    success = false;
  }
  return success;
}
async function file_overwrite(file_path, contents) {
  await file_parent_exists_ensure(file_path);
  let fs = await import("fs");
  await fs.promises.writeFile(file_path, contents, "utf-8");
  return;
}
async function file_root_exists_assert(file_path) {
  let {exists, root} = await file_root_exists(file_path);
  assert_json(exists, {
    file_path,
    root,
    message: "root does not exist"
  });
}
async function file_root_exists(file_path) {
  let path = await import("path");
  let parsed = path.parse(file_path);
  let root = object_property_get(parsed, "root");
  let en = string_empty_not_is(root);
  let exists = true;
  if (en) {
    async function lambda2() {
      let fs = await import("fs");
      await fs.promises.access(root);
    }
    exists = await throws_not_async(lambda2);
  }
  let v = {
    exists,
    root
  };
  return v;
}
function string_empty_not_is(name) {
  let a = string_empty_is(name);
  const ne = not(a);
  return ne;
}
function string_empty_is(s) {
  const e = s === "";
  return e;
}
async function file_parent_exists_ensure(file_path) {
  await file_root_exists_assert(file_path);
  let fs = await import("fs");
  let path = await import("path");
  const dir = path.dirname(file_path);
  await fs.promises.mkdir(dir, {
    recursive: true
  });
  return;
}
function data_path() {
  let inner = "";
  let f_path = data_path_generic(inner, "data");
  return f_path;
}
function data_path_generic(suffix, f_name_unsuffixed) {
  marker("1");
  const f_name = f_name_unsuffixed + suffix;
  const folder = "data";
  let f_path = file_name_json_folder(folder, f_name);
  return f_path;
}
function file_name_json_folder(folder, f_name) {
  let joined = path_join([folder, f_name]);
  let f_path = file_name_json(joined);
  return f_path;
}
function file_name_json(name) {
  let file_name = name + ".json";
  return file_name;
}
function user_repo_path() {
  const name = "user";
  let f_path = file_name_json_folder_gitignore(name);
  return f_path;
}
function file_name_json_folder_gitignore(name) {
  let f_path2 = file_name_json_folder("gitignore", name);
  return f_path2;
}
function global_function_initialize(fn, initial) {
  assert_arguments(arguments, 2);
  let global = global_get();
  let value = object_property_initialize(global, fn.name, initial);
  return value;
}
function bible_verses_encouragement() {
  marker("1");
  let encouragement = ["Deuteronomy 31:6", "Deuteronomy 31:8", "Joshua 1:9", "Proverbs 3:5-6", "Proverbs 12:25", "Proverbs 29:25", "Isaiah 26:3", "Isaiah 35:4", "Isaiah 40:31", "Isaiah 41:10", "Isaiah 41:13", "Isaiah 43:1", "Jeremiah 29:11", "Zephaniah 3:17", "Matthew 11:28-30", "Mark 5:36", "John 14:1", "John 14:27", "John 16:33", "Romans 8:38-39", "Colossians 3:15", "Philippians 4:6-9", "Philippians 4:13", "1 Peter 5:6-8", "2 Timothy 1:7", "1 John 4:18", "Revelation 1:17"];
  return encouragement;
}
async function ebible_references_parse_lines(bible_folders, lines) {
  let bible_folder = ebible_folder_english();
  let books_all = await list_map_unordered_async(bible_folders, ebible_version_books);
  let books = await ebible_version_books(bible_folder);
  let mapped = list_map_property(books, "text");
  let verse_references = list_filter_starts_with_any(mapped, lines);
  let book_names = list_map_prefix_any(verse_references, mapped);
  let mapped2 = list_map_prefix_without_any(verse_references, mapped);
  let mapped3 = list_map_split_space(mapped2);
  let mapped4 = list_map_filter_string_empty_not_is(mapped3);
  let chapter_verses_list = list_map_first(mapped4);
  async function lambda2(la) {
    async function lambda(book_name, chapter_verses) {
      let book = list_find_property(books, "text", book_name);
      let book_code = object_property_get(book, "book_code");
      let split2 = string_split_colon(chapter_verses);
      let {first: chapter_name, second} = list_first_second(split2);
      let pad_count = 2;
      if (equal(book_code, "PSA")) {
        pad_count = 3;
      }
      let chapter_padded = number_pad(chapter_name, pad_count);
      let chapter_code = book_code + chapter_padded;
      let verse_range = string_split_dash(second);
      let verse_start = list_first(verse_range);
      let verse_end = null;
      let m = list_multiple_is(verse_range);
      if (m) {
        verse_end = list_second(verse_range);
      } else {
        verse_end = verse_start;
      }
      let index = list_index_of(books, book);
      async function lambda5(bible_folder, books) {
        let book2 = list_get(books, index);
        let book_name = object_property_get(book2, "text");
        async function lambda4(verse_number) {
          verse_number = string_to(verse_number);
          let result = await ebible_verse(bible_folder, chapter_code, verse_number);
          la(result);
        }
        await each_range_from_async(verse_start, verse_end, lambda4);
      }
      await each_pair_async(bible_folders, books_all, lambda5);
    }
    await each_pair_async(book_names, chapter_verses_list, lambda);
  }
  let list = await list_adder_async(lambda2);
  return list;
}
async function ebible_verse(bible_folder, chapter_code, verse_number) {
  marker("1");
  let b = browser_is();
  if (b) {
    let verse = await ebible_verse_download(bible_folder, chapter_code, verse_number);
    return verse;
  }
  let verses = await ebible_verses(bible_folder, chapter_code);
  let result = list_find_property(verses, "verse_number", verse_number);
  return result;
}
async function ebible_verse_download(bible_folder, chapter_code, verse_number) {
  let n = ebible_verses_upload_name(chapter_code, verse_number);
  let index = await firebase_storage_download_ebible(bible_folder, n);
  return index;
}
async function firebase_storage_download_ebible(en, file_name) {
  let destination = ebible_firebase_upload_path(en, file_name);
  let index = await firebase_storage_download_json(destination);
  return index;
}
async function firebase_storage_download_json(destination) {
  let s = await firebase_storage_download_string(destination);
  let index = json_from(s);
  return index;
}
async function firebase_storage_download_string(destination) {
  let buffer = await firebase_storage_download(destination);
  let s = buffer_string_to(buffer);
  return s;
}
function buffer_string_to(buffer) {
  let s = null;
  let b = browser_is();
  if (b) {
    if (buffer instanceof ArrayBuffer) {
      s = new TextDecoder("utf-8").decode(new Uint8Array(buffer));
    } else if (buffer instanceof Uint8Array) {
      s = new TextDecoder("utf-8").decode(buffer);
    } else {
      throw new Error("Unsupported buffer type");
    }
  } else {
    s = buffer.toString("utf8");
  }
  return s;
}
async function firebase_storage_download(destination) {
  marker("1");
  destination = firebase_path_fix(destination);
  let b = browser_is();
  if (b) {
    let url = await firebase_storage_url(destination);
    let buffer = await http(url);
    return buffer;
  }
  const bucket = await firebase_bucket();
  let [buffer] = await bucket.file(destination).download();
  return buffer;
}
async function http(url) {
  let b = browser_is();
  if (b) {
    async function lambda3() {
      const response = await fetch(url);
      if (not(response.ok)) {
        error("Failed to fetch file");
      }
      const buf = await response.arrayBuffer();
      return buf;
    }
    let v = await html_loading(lambda3);
    return v;
  }
  await http_sleep();
  let h = null;
  let sw = string_starts_with(url, "https://");
  if (sw) {
    h = await import("https");
  }
  let buffer = await promise_wrap(lambda);
  function lambda(resolve, reject) {
    function lambda2(res) {
      const chunks = [];
      function on_data(chunk) {
        let v2 = chunks.push(chunk);
        return v2;
      }
      let result = catch_call(reject, on_data);
      res.on("data", result);
      function on_end() {
        const {statusCode} = res;
        const d = statusCode / 100;
        const rounded = round(d);
        assert_json(rounded === 2, {
          url
        });
        let v3 = Buffer.concat(chunks);
        resolve(v3);
      }
      let result2 = catch_call(reject, on_end);
      res.on("end", result2);
    }
    h.get(url, lambda2).on("error", reject);
  }
  return buffer;
}
async function http_sleep() {
  await sleep(integer_random(5, 8) * 1000);
}
function integer_random(min, max) {
  let r = floor(random() * (max - min + 1)) + min;
  return r;
}
function random() {
  let v = Math.random();
  return v;
}
function floor(p) {
  let floored = Math.floor(p);
  return floored;
}
async function sleep(ms) {
  await new Promise(function lambda5(resolve) {
    let v = setTimeout(resolve, ms);
    return v;
  });
}
async function html_loading(lambda) {
  marker("1");
  let body = html_document_body();
  let div = html_div(body);
  let s = {
    position: "fixed",
    top: "0",
    left: "0",
    width: "100vw",
    height: "100vh",
    background: "rgba(0, 0, 0, 0.6)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    zIndex: "1000"
  };
  html_style_assign(div, s);
  let result = await lambda();
  html_remove(div);
  return result;
}
function html_remove(component) {
  marker("1");
  let element = html_component_element_get(component);
  element.remove();
}
function html_component_element_get(component) {
  let element = object_property_get(component, "element");
  return element;
}
function html_style_assign(b, s) {
  marker("1");
  let b_element = html_component_element_get(b);
  object_assign(b_element.style, s);
}
function object_assign(to, from) {
  marker("1");
  let a = Object.assign(to, from);
  return a;
}
function html_div(root) {
  let div = html_element(root, "div");
  return div;
}
function html_element(parent, tag_name) {
  let parent_element = html_component_element_get(parent);
  const e = document.createElement(tag_name);
  parent_element.appendChild(e);
  let component = html_component_wrap(e);
  html_style_set(component, "box-sizing", "border-box");
  return component;
}
function html_style_set(b, style_key, style_value) {
  let b_element = html_component_element_get(b);
  b_element.style[style_key] = style_value;
}
function html_component_wrap(element) {
  let v = {
    element
  };
  return v;
}
function html_document_body() {
  marker("1");
  let body_element = document.body;
  let body = html_component_wrap(body_element);
  return body;
}
function catch_call(reject, lambda) {
  let i = function inner() {
    let result = null;
    try {
      result = lambda(...arguments);
    } catch (e) {
      reject(e);
    }
    marker("1");
    return result;
  };
  return i;
}
function promise_wrap(lambda) {
  let v = new Promise(function lambda4(resolve, reject) {
    try {
      lambda(resolve, reject);
    } catch (e) {
      reject(e);
    }
  });
  return v;
}
function round(n) {
  let rounded = Math.round(n);
  return rounded;
}
function string_starts_with(s, prefix) {
  let sw = s.startsWith(prefix);
  return sw;
}
async function firebase_bucket() {
  const admin = await firebase_admin();
  const bucket = admin.storage().bucket();
  return bucket;
}
async function firebase_admin() {
  let admin = await global_function_async(firebase_admin, firebase_admin_get);
  return admin;
}
async function global_function_async(fn, lambda) {
  let global = global_get();
  marker("1");
  let value = object_property_lambda(global, fn.name, lambda);
  let awaited = await value;
  return awaited;
}
function object_property_lambda(object, property_name, lambda) {
  marker("1");
  const exists = object_property_exists(object, property_name);
  if (not(exists)) {
    let value_set = lambda();
    object_property_set(object, property_name, value_set);
  }
  let value = object_property_get(object, property_name);
  return value;
}
async function firebase_admin_get() {
  const admin = (await import("firebase-admin")).default;
  marker("1");
  let service_account = await firebase_service_account();
  const sb = await firebase_storage_url_project();
  log({
    sb
  });
  admin.initializeApp({
    credential: admin.credential.cert(service_account),
    storageBucket: sb
  });
  return admin;
}
async function firebase_storage_url_project() {
  marker("1");
  const prefix = await firebase_name();
  let url = prefix + ".firebasestorage.app";
  return url;
}
async function firebase_service_account() {
  let f_name = await user_repo_firebase_service_account_get();
  let file_path = await function_run(f_name, []);
  let service_account = await file_read_json(file_path);
  return service_account;
}
async function function_run(f_name, args) {
  const fn = await function_import(f_name);
  const result = await fn(...args);
  return result;
}
async function function_import(f_name) {
  let {unaliased} = await function_name_unalias(f_name);
  let {f_path: f} = await function_name_to_path_search(unaliased);
  let f_path = await path_resolve(f);
  const imported = await import(`file://${f_path}`);
  const imported_fn = imported[unaliased];
  if (typeof imported_fn !== "function") {
    throw new Error(`❌ The module "${unaliased}" does not export a default function.`);
  }
  return imported_fn;
}
async function path_resolve(paths) {
  let path = await import("path");
  let v = path.resolve(paths);
  return v;
}
async function function_name_unalias(f_name) {
  assert_arguments(arguments, 1);
  marker("1");
  var {exists, unaliased: unaliased_actual} = await function_alias_add_generic(f_name);
  let {expanded, expandeds} = await function_acronym_to_name(f_name);
  const unaliased = exists ? unaliased_actual : expanded !== null ? expanded : f_name;
  let v = {
    unaliased,
    expandeds
  };
  return v;
}
async function function_acronym_to_name(alias) {
  let expanded = null;
  let expandeds = null;
  let acronyms = await function_names_to_acronyms();
  const exists2 = object_property_exists(acronyms, alias);
  if (exists2) {
    expandeds = object_property_get(acronyms, alias);
    let s1 = list_size_1(expandeds);
    if (s1) {
      expanded = list_single(expandeds);
    }
  }
  let v = {
    expanded,
    expandeds
  };
  return v;
}
async function function_names_to_acronyms() {
  let f_names = await functions_names();
  let dictionary = list_to_dictionary(f_names, function_name_to_acronym);
  let acronyms = object_invert(dictionary);
  return acronyms;
}
function object_invert(object) {
  let inverted = {};
  function lambda(value, key) {
    undefined_not_is_assert(value);
    let list = object_property_initialize(inverted, value, []);
    list_add(list, key);
  }
  each_object(object, lambda);
  return inverted;
}
function undefined_not_is_assert(value) {
  marker("1");
  function lambda2() {
    let v2 = {};
    return v2;
  }
  undefined_not_is_assert_lambda(value, lambda2);
}
function each_object(object, lambda) {
  function lambda2(p) {
    let value = object_property_get(object, p);
    lambda(value, p);
  }
  let list = object_properties(object);
  each(list, lambda2);
}
function function_name_to_acronym(f_name) {
  let parts = function_name_to_parts(f_name);
  let letters = null;
  try {
    letters = list_map(parts, list_first);
  } catch (e) {
    "if this error, then maybe string empty, __ instead of _ or ends with _";
    error_json({
      e,
      f_name
    });
  }
  let acronym = list_join_empty(letters);
  return acronym;
}
function list_join_empty(letters) {
  const e = string_empty();
  let joined = list_join(letters, e);
  return joined;
}
function list_join(list, separator) {
  let joined = list.join(separator);
  return joined;
}
function string_empty() {
  let v = "";
  return v;
}
function function_name_to_parts(f_name) {
  let separator = function_name_separator();
  let parts = string_split(f_name, separator);
  return parts;
}
function string_split(s, separator) {
  const split = s.split(separator);
  return split;
}
function function_name_separator() {
  const separator = "_";
  return separator;
}
function list_to_dictionary(list, lambda$item) {
  let dictionary = {};
  function lambda(item) {
    let value = lambda$item(item);
    object_property_set(dictionary, item, value);
  }
  each(list, lambda);
  return dictionary;
}
async function functions_names() {
  marker("1");
  let f_names = await repos_paths_map_unordered_combine_squash(mapper);
  async function mapper(joined) {
    let f_names = await functions_names_from_path(joined);
    return f_names;
  }
  return f_names;
}
async function function_alias_add_generic(alias) {
  let unaliased = null;
  let d_path = data_aliases_path();
  var {value: aliases, file_path, data} = await data_get("aliases", {}, d_path);
  const exists = object_property_exists(aliases, alias);
  if (exists) {
    unaliased = object_property_get(aliases, alias);
  }
  let v = {
    exists,
    aliases,
    file_path,
    data,
    unaliased
  };
  return v;
}
function data_aliases_path() {
  marker("1");
  let f_path = data_path_generic("", "aliases");
  return f_path;
}
async function function_name_to_path_search(unaliased) {
  let f_path = function_name_to_path(unaliased);
  async function lambda(joined) {
    let exists = await file_exists(joined);
    let v = {
      exists,
      f_path: joined
    };
    return v;
  }
  let mapped = await repos_paths_names_map_unordered_combine(f_path, lambda);
  function lambda2(m) {
    let mapped = object_property_get(m, "mapped");
    let exists2 = object_property_get(mapped, "exists");
    let ti2 = true_is(exists2);
    return ti2;
  }
  let filtered = list_filter(mapped, lambda2);
  let multiple = list_multiple_is(filtered);
  let exists = list_size_1(filtered);
  let search = {
    exists,
    multiple
  };
  if (exists) {
    let only = list_single(filtered);
    let mapped = object_property_get(only, "mapped");
    object_property_from(search, "f_path", mapped);
    object_property_from(search, "repo_name", only);
  }
  return search;
}
function object_property_from(to, property_name, from) {
  let value = object_property_get(from, property_name);
  object_property_set(to, property_name, value);
}
async function repos_paths_names_map_unordered_combine(path, mapper) {
  marker("1");
  let result = await repos_paths_names_map_unordered(each_folder);
  async function each_folder(repo_name, r_path) {
    let joined = path_join([r_path, path]);
    let mapped = await mapper(joined);
    let v = {
      mapped,
      repo_name
    };
    return v;
  }
  return result;
}
async function repos_paths_names_map_unordered(lambda$name$path) {
  marker("1");
  let all = await repos_names();
  async function lambda(repo_name) {
    let path = repo_path(repo_name);
    let mapped = await lambda$name$path(repo_name, path);
    return mapped;
  }
  let result = await list_map_unordered_async(all, lambda);
  return result;
}
function list_multiple_is(list) {
  let v = list_size(list) >= 2;
  return v;
}
function true_is(value) {
  let ti = equal(value, true);
  return ti;
}
function function_name_to_path(f_name) {
  if (string_includes(f_name, ".")) {
    error_json({
      f_name
    });
  }
  let folder = functions_path();
  let v = function_name_folder_to_path(f_name, folder);
  return v;
}
function string_includes(input, part) {
  const o = {
    input,
    part
  };
  string_is_assert_json(input, o);
  string_is_assert_json(part, o);
  let v = input.includes(part);
  return v;
}
function string_is_assert_json(value, o) {
  let message = json_to(o);
  string_is_assert_message(value, message);
}
function string_is_assert_message(value, message) {
  marker("1");
  let b = string_is(value);
  let v = assert_message(b, message);
  return v;
}
async function user_repo_firebase_service_account_get() {
  marker("1");
  let repo_name = await user_repo_get();
  let v = await repo_firebase_service_account_get(repo_name);
  return v;
}
async function repo_firebase_service_account_get(repo_name) {
  const key = "firebase_service_account";
  let v = await repo_about_get(repo_name, key);
  return v;
}
async function repo_about_get(repo, key) {
  let a_path = path_repo_about(repo);
  let {value} = await data_get(key, null, a_path);
  let v = value;
  return v;
}
function path_repo_about(repo) {
  let f_path = data_path_generic("", "about");
  let a_path = path_repo_combine(repo, f_path);
  return a_path;
}
function path_repo_combine(repo, f_path) {
  let r_path = repo_path(repo);
  let joined = path_join([r_path, f_path]);
  return joined;
}
function firebase_path_fix(path) {
  let replaced = string_replace(path, "\\", "/");
  return replaced;
}
function string_replace(s, from, to) {
  marker("1");
  let split = string_split(s, from);
  let replaced = list_join(split, to);
  return replaced;
}
async function firebase_storage_url(storage_path) {
  let replaced = string_replace(storage_path, "/", "%2F");
  let url = "https://firebasestorage.googleapis.com/v0/b/" + await firebase_storage_url_project() + "/o/" + replaced + "?alt=media";
  return url;
}
function ebible_firebase_upload_path(bible_folder, file_name) {
  let file_name_with_extension = file_name_json(file_name);
  let joined = list_join_slash_forward(["bible", bible_folder]);
  let destination = list_join_slash_forward([joined, file_name_with_extension]);
  return destination;
}
function list_join_slash_forward(list) {
  let joined = list_join(list, "/");
  return joined;
}
function ebible_verses_upload_name(chapter_code, verse_number) {
  let joined = list_join_slash_forward([chapter_code, verse_number]);
  return joined;
}
function list_find_property(list, property_name, property_value) {
  let filter = object_property_equals_lambda(property_name, property_value);
  let item = list_find(list, filter);
  return item;
}
function object_property_equals_lambda(property_name, property_value) {
  let v2 = function lambda(item) {
    let v = object_property_equals(item, property_name, property_value);
    return v;
  };
  return v2;
}
function object_property_equals(item, property_name, property_value) {
  let v = object_property_get(item, property_name) === property_value;
  return v;
}
function list_find(list, lambda$item) {
  let filtered = list_filter(list, lambda$item);
  let only = list_single(filtered);
  return only;
}
async function ebible_verses(bible_folder, chapter_code) {
  marker("1");
  let {verse_numbers, text} = await ebible_chapter_text(bible_folder, chapter_code);
  text = whitespace_normalize(text);
  text = urdu_allah_to_god(text);
  let split = string_split_space(text);
  let filtered = list_filter(split, string_empty_not_is);
  function lambda(la) {
    function lambda2(verse_number) {
      verse_number += "";
      let index = list_index_of_last(filtered, verse_number);
      let skipped = list_skip(filtered, index + 1);
      const v = ebible_verse_new(skipped, verse_number);
      la(v);
      filtered = list_take(filtered, index);
    }
    each_reverse(verse_numbers, lambda2);
  }
  let list = list_adder(lambda);
  let ne = list_empty_not_is(filtered);
  if (ne) {
    const v = ebible_verse_new(filtered, "0");
    list_add(list, v);
  }
  list_reverse(list);
  return list;
}
function urdu_allah_to_god(text) {
  let v = text.replace(/الله/g, "خدا");
  return v;
}
function list_index_of_last(list, item) {
  marker("1");
  let index = list.lastIndexOf(item);
  if (index <= -1) {
    error_json({
      list,
      item,
      index
    });
  }
  return index;
}
function ebible_verse_new(tokens, verse_number) {
  marker("1");
  let joined = list_join_space(tokens);
  const v = {
    verse_number,
    text: joined
  };
  return v;
}
function list_join_space(args) {
  let joined = list_join(args, " ");
  return joined;
}
function list_take(list, count) {
  marker("1");
  let taken = list_slice(list, 0, count);
  return taken;
}
function list_slice(list, a, b) {
  let sliced = list.slice(a, b);
  return sliced;
}
function list_skip(list, skip_count) {
  let b = list_size(list);
  const skipped = list_slice(list, skip_count, b);
  return skipped;
}
function each_reverse(list, lambda) {
  let reversed = list_copy_reverse(list);
  each(reversed, lambda);
}
function list_copy_reverse(previous) {
  let copy = list_copy(previous);
  list_reverse(copy);
  return copy;
}
function list_reverse(list) {
  list.reverse();
}
function whitespace_normalize(str) {
  marker("1");
  let v = str.replace(/\s+/g, " ").trim();
  return v;
}
function string_split_space(s) {
  let split = string_split(s, " ");
  return split;
}
async function ebible_chapter_text(bible_folder, chapter_code) {
  marker("1");
  let joined = ebible_version_download_path_combine(bible_folder, chapter_code);
  let {d, root} = await html_parse_read(joined);
  let main = html_parse_find(root, ".main");
  let classes = html_parse_descendants_classes(main, d);
  let include = ebible_verses_include();
  let exclude = ebible_verses_exclude();
  list_intersect_empty_is_assert(include, exclude);
  let list2 = list_difference(classes, include);
  let extra = list_difference(list2, exclude);
  let dictionary = html_parse_classes_preview(main, d, extra);
  list_empty_is_assert(extra, {
    extra,
    dictionary
  });
  function lambda(item) {
    let selector2 = css_class_prefix_combine(item);
    html_parse_find_remove(main, selector2);
  }
  each(exclude, lambda);
  let list = html_parse_find_list_to(main, ".verse");
  function lambda2(item) {
    let t = html_parse_text(d, item);
    let n = whitespace_normalize(t);
    return n;
  }
  let verse_numbers = list_map(list, lambda2);
  verse_numbers = list_map(verse_numbers, roman_to_integer);
  let text = html_parse_text(d, main);
  let result = {
    verse_numbers,
    text
  };
  return result;
}
function roman_to_integer(input) {
  function unicodeToAscii(roman) {
    const map = {
      Ⅰ: "I",
      Ⅱ: "II",
      Ⅲ: "III",
      Ⅳ: "IV",
      Ⅴ: "V",
      Ⅵ: "VI",
      Ⅶ: "VII",
      Ⅷ: "VIII",
      Ⅸ: "IX",
      Ⅹ: "X",
      Ⅺ: "XI",
      Ⅻ: "XII",
      Ⅼ: "L",
      Ⅽ: "C",
      Ⅾ: "D",
      Ⅿ: "M"
    };
    function lambda(ch) {
      let v = map[ch] ?? ch;
      return v;
    }
    let v3 = roman.split("").map(lambda).join("");
    return v3;
  }
  function romanToInt(roman) {
    const values = {
      I: 1,
      V: 5,
      X: 10,
      L: 50,
      C: 100,
      D: 500,
      M: 1000
    };
    let total = 0;
    for (let i = 0; i < roman.length; i++) {
      const v1 = values[roman[i]];
      const v2 = values[roman[i + 1]] || 0;
      total += v1 < v2 ? -v1 : v1;
    }
    return total;
  }
  function parseRomanOrInteger(input) {
    const match = input.match(/^([ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯIVXLCDM]+)([a-zA-Z]*)$/);
    if (not(match)) {
      return input;
    }
    const romanPart = match[1];
    const suffix = match[2] || "";
    const asciiRoman = unicodeToAscii(romanPart);
    let v5 = romanToInt(asciiRoman) + suffix;
    return v5;
  }
  let v6 = parseRomanOrInteger(input);
  return v6;
}
function list_intersect_empty_is_assert(include, exclude) {
  let i = list_intersect(include, exclude);
  list_empty_is_assert(i, {
    include,
    exclude
  });
}
function list_empty_is_assert(extra, j) {
  let e = list_empty_is(extra);
  assert_json(e, j);
}
function list_intersect(list, other) {
  function lambda2(la) {
    function lambda(l) {
      if (list_includes(other, l)) {
        la(l);
      }
    }
    each(list, lambda);
  }
  let list2 = list_adder(lambda2);
  return list2;
}
function html_parse_find_list_to(bl, selector) {
  let query = html_parse_find(bl, selector);
  let list = html_parse_list_to(query);
  return list;
}
function html_parse_list_to(query) {
  let v = query.get();
  return v;
}
function html_parse_find(root, selector) {
  let result = root.find(selector);
  return result;
}
function html_parse_text(d, item) {
  let text = d(item).text();
  return text;
}
function css_class_prefix_combine(item) {
  let v = "." + item;
  return v;
}
function ebible_verses_exclude() {
  let v = ["b", "bdit", "chapterlabel", "copyright", "f", "fq", "fqa", "fr", "footnote", "fl", "ft", "fv", "iex", "im", "imt", "is", "io", "ior", "iot", "io2", "ip", "k", "mt", "mt3", "mr", "ms", "ms2", "mt2", "nb", "notebackref", "notemark", "popup", "qa", "qd", "r", "rq", "s", "s2", "s3", "sp", "tl", "tnav", "x", "xo", "xt"];
  return v;
}
function ebible_verses_include() {
  let v = ["bd", "bk", "d", "em", "fk", "it", "li", "li2", "li3", "li4", "m", "mi", "nd", "p", "pi", "pc", "pm", "pmc", "pmo", "pmr", "sc", "q", "q2", "q3", "q4", "qc", "qm", "qm2", "qr", "qs", "verse", "wj"];
  return v;
}
function html_parse_descendants_classes(item, d) {
  let descendants = html_parse_find_list_to(item, "*");
  function lambda2(la) {
    function lambda(item) {
      let c = html_parse_attr(d, item, "class");
      if (string_is(c)) {
        let split = string_split(c, " ");
        each(split, la);
      }
    }
    each(descendants, lambda);
  }
  let list = list_adder(lambda2);
  let classes = list_unique(list);
  list_sort_string(classes);
  return classes;
}
function list_sort_string(list) {
  list.sort();
}
function html_parse_attr(d, item, name) {
  let v = d(item).attr(name);
  return v;
}
function html_parse_find_remove(main, selector) {
  let result = html_parse_find(main, selector);
  result.remove();
}
function html_parse_classes_preview(main, d, classes) {
  function lambda(c) {
    let e = html_parse_find(main, "." + c);
    let text = html_parse_text(d, e);
    return text;
  }
  let dictionary = list_to_dictionary(classes, lambda);
  return dictionary;
}
async function html_parse_read(file_path) {
  let contents = await file_read(file_path);
  let parsed = await html_parse(contents);
  return parsed;
}
async function html_parse(contents) {
  let cheerio = await import_install("cheerio");
  let d = cheerio.load(contents);
  let root = d("html");
  let result = {
    d,
    root
  };
  return result;
}
async function import_install(name) {
  try {
    let v = await import(name);
    return v;
  } catch (err) {
    if (err.code === "ERR_MODULE_NOT_FOUND" || err.code === "MODULE_NOT_FOUND") {
      await npm_install(name);
      let v2 = await import(name);
      return v2;
    }
    throw err;
  }
}
async function npm_install(package_name) {
  await command_line("npm install " + package_name + "@latest");
}
async function command_line(command) {
  marker("1");
  let extra = {};
  const stdout = await command_line_generic(command, extra);
  return stdout;
}
async function command_line_generic(command, extra) {
  const {exec} = await import("child_process");
  const {promisify} = await import("util");
  const execAsync = promisify(exec);
  const options = {
    encoding: "utf8"
  };
  object_merge(options, extra);
  const stdout = await execAsync(command, options);
  return stdout;
}
function object_merge(to, from) {
  let strict = true;
  object_merge_generic(strict, to, from);
  return to;
}
function object_merge_generic(strict, to, from) {
  function lambda(property_name) {
    if (strict) {
      if (object_property_exists(to, property_name)) {
        error_json({
          to,
          from,
          property_name
        });
      }
    }
    let value = object_property_get(from, property_name);
    object_property_set(to, property_name, value);
  }
  let list = object_properties(from);
  each(list, lambda);
}
function ebible_version_download_path_combine(bible_folder, book_code) {
  let chapters_name = book_code + ".htm";
  let file_path = ebible_version_download_path(bible_folder);
  let joined = path_join([file_path, chapters_name]);
  return joined;
}
function ebible_version_download_path(bible_folder) {
  let joined2 = local_function_path(ebible_version_download, bible_folder);
  return joined2;
}
async function ebible_version_download(bible_folder) {
  marker("1");
  let url = "https://ebible.org/Scriptures/" + bible_folder + "_html.zip";
  let buffer = await http_local(url);
  let file_path = ebible_version_download_path(bible_folder);
  await unzip(file_path, buffer);
  return file_path;
}
async function unzip(file_path, buffer) {
  const AdmZip = (await import_install("adm-zip")).default;
  const zip = new AdmZip(buffer);
  zip.extractAllTo(file_path, true);
}
async function http_local(url) {
  marker("1");
  let key_get = http_local_file_name;
  let cached_exists = file_exists;
  let cached_get = file_read_buffer;
  let value_get = http_firebase;
  let cache_save = file_write_buffer;
  let result = await cache_generic(key_get, url, cached_exists, cached_get, value_get, cache_save);
  return result;
}
async function file_write_buffer(f_path, contents) {
  await file_write_generic(f_path, file_overwrite_buffer, contents);
}
async function file_overwrite_buffer(file_path, contents) {
  marker("1");
  let fs = await import("fs");
  await file_parent_exists_ensure(file_path);
  await fs.promises.writeFile(file_path, contents);
}
async function file_read_buffer(file_path) {
  marker("1");
  let fs = await import("fs");
  let v = await fs.promises.readFile(file_path);
  return v;
}
function http_local_file_name(url) {
  let file_name = http_firebase_file_name(url);
  let fn = http_local;
  let joined = local_function_path(fn, file_name);
  return joined;
}
function local_function_path(fn, file_name) {
  let joined2 = path_join(["D:\\user\\storage\\function", fn.name, file_name]);
  return joined2;
}
function http_firebase_file_name(url) {
  let safe = string_base64_to(url);
  return safe;
}
function string_base64_to(s) {
  let b = browser_is();
  if (b) {
    const b64 = btoa(s);
    return b64;
  }
  const b64node = Buffer.from(s, "utf-8").toString("base64");
  return b64node;
}
async function http_firebase(url) {
  let key_get = http_firebase_file_path;
  let cached_exists = firebase_storage_exists;
  let cached_get = firebase_storage_download;
  let value_get = http;
  async function cache_save(key, value) {
    await firebase_upload_buffer(value, key);
  }
  let result = await cache_generic(key_get, url, cached_exists, cached_get, value_get, cache_save);
  return result;
}
async function firebase_upload_buffer(content, destination) {
  marker("1");
  let buffer = Buffer.from(content);
  const settings = {
    contentType: "application/octet-stream",
    resumable: false
  };
  await firebase_upload_generic(destination, settings, buffer);
  return destination;
}
async function firebase_upload_generic(destination, settings, buffer) {
  destination = firebase_path_fix(destination);
  const bucket = await firebase_bucket();
  const file = bucket.file(destination);
  let merged = object_merge({
    metadata: {
      cacheControl: "no-cache"
    }
  }, settings);
  await retry(5, lambda);
  log_keep(`Uploaded data to ${destination}`);
  const url = `https://storage.googleapis.com/${bucket.name}/${file.name}`;
  log_keep("Accessible at:" + url);
  async function lambda() {
    await file.save(buffer, merged);
  }
}
async function retry(count, lambda) {
  let wait = 1000;
  let result = null;
  let success = false;
  async function lambda3(la) {
    async function lambda2() {
      try {
        result = await lambda();
        success = true;
        return success;
      } catch (e) {
        log_keep({
          e
        });
        la(e);
        await sleep(wait);
        wait *= 2;
      }
    }
    await each_range_async(count, lambda2);
  }
  let errors = await list_adder_async(lambda3);
  if (success) {
    return result;
  }
  error_json({
    errors
  });
}
async function list_adder_async(lambda$la) {
  let list = [];
  function list_adder_inner(item) {
    list_add(list, item);
  }
  await lambda$la(list_adder_inner);
  return list;
}
async function each_range_async(count, lambda) {
  let r = range(count);
  await each_async(r, lambda);
}
async function each_async(list, lambda$item) {
  for (let item of list) {
    if (await lambda$item(item) === true) {
      break;
    }
  }
}
function range(count) {
  marker("1");
  let rr = [];
  for (let i = 0; i < count; i++) {
    list_add(rr, i);
  }
  return rr;
}
async function cache_generic(key_get, url, cached_exists, cached_get, value_get, cache_save) {
  let key = key_get(url);
  let e = await cached_exists(key);
  let result = null;
  if (e) {
    result = await cached_get(key);
  } else {
    let value = await value_get(url);
    await cache_save(key, value);
    result = await cached_get(key);
  }
  return result;
}
function http_firebase_file_path(url) {
  marker("1");
  let file_name = http_firebase_file_name(url);
  let joined = path_join(["http", file_name]);
  joined = firebase_path_fix(joined);
  return joined;
}
async function firebase_storage_exists(path) {
  path = firebase_path_fix(path);
  const bucket = await firebase_bucket();
  const file = bucket.file(path);
  let exists = null;
  try {
    const [e] = await file.exists();
    exists = e;
  } catch (err) {
    error(err);
    exists = false;
  }
  return exists;
}
async function each_pair_async(list_a, list_b, lambda$a$b) {
  marker("1");
  let lists = [list_a, list_b];
  await each_multiple_async(lists, lambda);
  async function lambda(items) {
    let [a, b] = items;
    await lambda$a$b(a, b);
  }
}
async function each_multiple_async(lists, lambda) {
  marker("1");
  let first = list_first(lists);
  async function lambda2(item, index) {
    let items = lists_get(lists, index);
    await lambda(items);
  }
  await each_index_async(first, lambda2);
}
async function each_index_async(list, lambda$item$index) {
  marker("1");
  let index = 0;
  async function lambda2(item) {
    await lambda$item$index(item, index);
    index++;
  }
  await each_async(list, lambda2);
}
function lists_get(lists, index) {
  function lambda(list) {
    let item = list_get(list, index);
    return item;
  }
  const items = list_map(lists, lambda);
  return items;
}
async function each_range_from_async(from, to, lambda) {
  marker("1");
  let list = range_from(from, to);
  await each_async(list, lambda);
}
function range_from(from, to) {
  from = integer_to(from);
  to = integer_to(to);
  marker("1");
  let count = to - from + 1;
  let r = range(count);
  function lambda(item) {
    let s = add(from, item);
    return s;
  }
  let mapped = list_map(r, lambda);
  return mapped;
}
function integer_to(input) {
  let i = parseInt(input, 10);
  if (Number.isNaN(i)) {
    let v = null;
    return v;
  }
  return i;
}
function add(left, right) {
  const sum = left + right;
  return sum;
}
function list_second(list) {
  const index = 1;
  const second = list_get(list, index);
  return second;
}
function string_split_dash(second) {
  let split4 = string_split(second, "-");
  return split4;
}
function number_pad(num, count) {
  marker("1");
  let v = String(num).padStart(count, "0");
  return v;
}
function list_first_second(list) {
  const property_name = "second";
  let value_get = list_second;
  let result = list_first_second_generic(list, value_get, property_name);
  return result;
}
function list_first_second_generic(list, value_get, property_name) {
  let first = null;
  let second = null;
  if (list_empty_not_is(list)) {
    first = list_first(list);
    if (list_multiple_is(list)) {
      second = value_get(list);
    }
  }
  let result = {
    first,
    [property_name]: second
  };
  return result;
}
function string_split_colon(chapter_verses) {
  let split3 = string_split(chapter_verses, ":");
  return split3;
}
function list_map_first(mapped4) {
  let mapped6 = list_map(mapped4, list_first);
  return mapped6;
}
function list_map_filter_string_empty_not_is(list) {
  marker("1");
  let mapped4 = list_map(list, list_filter_empty_not_is);
  return mapped4;
}
function list_filter_empty_not_is(item) {
  let filtered2 = list_filter(item, string_empty_not_is);
  return filtered2;
}
function list_map_split_space(mapped2) {
  function lambda(item) {
    let split2 = string_split_space(item);
    return split2;
  }
  let mapped3 = list_map(mapped2, lambda);
  return mapped3;
}
function list_map_prefix_without_any(list, prefixes) {
  marker("1");
  function lambda(item) {
    let prefix = list_find_starts_with(item, prefixes);
    let result = string_prefix_without(item, prefix);
    return result;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function list_find_starts_with(item, prefixes) {
  marker("1");
  function lambda2(item2) {
    let sw = string_starts_with(item, item2);
    return sw;
  }
  let any = list_find(prefixes, lambda2);
  return any;
}
function string_prefix_without(s, prefix) {
  let a = string_starts_with(s, prefix);
  if (not(a)) {
    error();
  }
  let skipped = string_size(prefix);
  let without = string_skip(s, skipped);
  return without;
}
function string_skip(s, skip_count) {
  let b = string_size(s);
  const skipped = string_slice(s, skip_count, b);
  return skipped;
}
function list_map_prefix_any(list, prefixes) {
  marker("1");
  function lambda(item) {
    let prefix = list_find_starts_with(item, prefixes);
    return prefix;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function list_filter_starts_with_any(prefixes, list) {
  function lambda(item) {
    let any = list_any_starts_with(item, prefixes);
    return any;
  }
  let verse_references = list_filter(list, lambda);
  return verse_references;
}
function list_any_starts_with(item, prefixes) {
  function lambda2(item2) {
    let sw = string_starts_with(item, item2);
    return sw;
  }
  let any = list_any(prefixes, lambda2);
  return any;
}
function list_map_property(list, property_name) {
  function list_map_property_lambda(item) {
    let value = object_property_get(item, property_name);
    return value;
  }
  let mapped = list_map(list, list_map_property_lambda);
  return mapped;
}
async function ebible_version_books(bible_folder) {
  marker("1");
  let b = browser_is();
  if (b) {
    let file_name2 = ebible_version_books_upload_name();
    let {books} = await firebase_storage_download_ebible(bible_folder, file_name2);
    return books;
  }
  const n = ebible_class_new();
  let o = ebible_class_old();
  let a = ebible_class_apocrypha();
  let classes = list_join_comma_space([o, a, n]);
  let books = await ebible_version_books_testament(bible_folder, classes);
  return books;
}
function ebible_version_books_upload_name() {
  let v = "books";
  return v;
}
function ebible_class_apocrypha() {
  let v = ".aa";
  return v;
}
async function ebible_version_books_testament(bible_folder, selector) {
  let file_path = await ebible_version_download(bible_folder);
  let joined = path_join([file_path, "index.htm"]);
  let {d, root} = await html_parse_read(joined);
  let bl = html_parse_find(root, ".bookList");
  let mapped = html_parse_find_list_href_text(bl, selector, d);
  function lambda(item) {
    let href = object_property_get(item, "href");
    let taken = ebible_chapter_code_to_book(href);
    let to = object_merge({
      book_code: taken
    }, item);
    return to;
  }
  let mapped2 = list_map(mapped, lambda);
  return mapped2;
}
function ebible_chapter_code_to_book(chapter_code) {
  marker("1");
  let count = ebible_book_code_size();
  let book_code = string_take(chapter_code, count);
  return book_code;
}
function ebible_book_code_size() {
  let v = 3;
  return v;
}
function string_take(s, count) {
  let taken = string_slice(s, 0, count);
  return taken;
}
function html_parse_find_list_href_text(bl, selector, d) {
  marker("1");
  let list = html_parse_find_list_to(bl, selector);
  let mapped = html_parse_href_text_map(d, list);
  return mapped;
}
function html_parse_href_text_map(d, list) {
  function lambda(item) {
    let both = html_parse_href_text(d, item);
    return both;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function html_parse_href_text(d, item) {
  let text = html_parse_text(d, item);
  let href = html_parse_href(d, item);
  let both = {
    text,
    href
  };
  return both;
}
function html_parse_href(d, item) {
  marker("1");
  const name = "href";
  let href = html_parse_attr(d, item, name);
  return href;
}
function list_join_comma_space(args) {
  let v = list_join(args, ", ");
  return v;
}
function ebible_class_old() {
  let v = ".oo";
  return v;
}
function ebible_class_new() {
  let v = ".nn";
  return v;
}
function ebible_folder_english() {
  let v = "engbsb";
  return v;
}
function html_display_none_or_block(condition, item) {
  if (condition) {
    html_display_none(item);
  } else {
    html_display_block(item);
  }
}
function html_display_block(element) {
  marker("1");
  html_style_set(element, "display", "block");
}
function html_display_none(element) {
  marker("1");
  html_style_set(element, "display", "none");
}
function ebible_chapter_code_to_name(chapter_code) {
  let count = ebible_book_code_size();
  let s = string_skip(chapter_code, count);
  let i = integer_to(s);
  let chapter_name = string_to(i);
  return chapter_name;
}
function list_remove_property(languages, property_name, en) {
  let found = list_find_property(languages, property_name, en);
  list_remove(languages, found);
}
function ebible_languages() {
  let languages = [{
    name: "English",
    bible_folder: ebible_folder_english(),
    language_code: "en"
  }, {
    name: "Urdu",
    bible_folder: ebible_folder_urdu(),
    language_code: "ur"
  }, {
    name: "Swahili",
    bible_folder: "swhonen",
    language_code: "swh"
  }, {
    name: "Luganda",
    bible_folder: "lug",
    language_code: "lug"
  }, {
    name: "Bengali",
    bible_folder: "benirv",
    language_code: "ben"
  }, {
    name: "Telugu",
    bible_folder: "tel2017",
    language_code: "tel"
  }, {
    name: "Yoruba",
    bible_folder: "yor",
    language_code: "yor"
  }, {
    name: "Hindi",
    bible_folder: "hin2017",
    language_code: "hin"
  }, {
    name: "Arabic",
    bible_folder: "arbnav",
    language_code: "arb"
  }, {
    name: "Ekegusii",
    bible_folder: "guz",
    language_code: "guz"
  }, {
    name: "Cebuano",
    bible_folder: "cebulb",
    language_code: "ceb"
  }, {
    name: "Tagalog",
    bible_folder: "tglulb",
    language_code: "tgl"
  }];
  return languages;
}
function ebible_folder_urdu() {
  let v2 = "urdgvu";
  return v2;
}
function string_take_less_1(typed) {
  const sz1 = string_size_less_1(typed);
  typed = string_take(typed, sz1);
  return typed;
}
function string_size_less_1(typed) {
  let sz = string_size(typed);
  const sz1 = sz - 1;
  return sz1;
}
function list_add_first(list, item) {
  list_insert(list, 0, item);
}
function list_insert(list, index, value) {
  const delete_count = 0;
  list_insert_generic(index, list, delete_count, value);
}
function list_insert_generic(index, list, delete_count, value) {
  let b = number_is(index);
  assert(b);
  list_splice(list, index, delete_count, value);
}
function list_splice(list, index, delete_count, value) {
  list.splice(index, delete_count, value);
}
function number_is(value) {
  let v = typeof value === "number" && isFinite(value);
  return v;
}
function ebible_index_flat_upload_name() {
  let v = ebible_index_upload_name();
  let file_name = list_join_slash_forward([v, "flat"]);
  return file_name;
}
function ebible_index_upload_name() {
  let v = "index";
  return v;
}
function string_lower_to(s) {
  marker("1");
  let lower = s.toLowerCase();
  return lower;
}
function html_on_keydown(component, lambda) {
  marker("1");
  const name_event = "keydown";
  html_on(component, name_event, lambda);
}
function html_on(component, name_event, lambda) {
  function_is_assert(lambda);
  let element = html_component_element_get(component);
  element.addEventListener(name_event, lambda);
}
function function_is_assert(lambda) {
  let fi = function_is(lambda);
  assert_json(fi, {
    lambda
  });
}
function function_is(f) {
  marker("1");
  let fi = typeof f === "function";
  return fi;
}
function string_letters_only(str) {
  marker("1");
  let letters = str.replace(/[^a-zA-Z]/g, "");
  return letters;
}
function object_property_set_exists_not(object, property_name, value) {
  object_property_exists_not_assert(object, property_name);
  object_property_set(object, property_name, value);
}
function object_property_exists_not_assert(object, property_name) {
  marker("1");
  let result = object_property_exists_not(object, property_name);
  assert(result);
}
function object_property_exists_not(object, property_name) {
  let result = object_property_exists(object, property_name);
  let n = not(result);
  return n;
}
function list_concat(a, b) {
  let l = list_is(a);
  assert(l);
  let concated = a.concat(b);
  return concated;
}
function list_random_item(arr) {
  const p = random() * list_size(arr);
  let index = floor(p);
  let r = list_get(arr, index);
  return r;
}
function html_p_text_multiple(parent, list) {
  function lambda2(item) {
    html_p_text(parent, item);
  }
  each(list, lambda2);
}
function html_p_text(root, text) {
  let p = html_p(root);
  html_text_set(p, text);
  return p;
}
function html_text_set(component, text) {
  let element = html_component_element_get(component);
  element.innerHTML = text;
}
function html_p(root) {
  let component = html_element(root, "p");
  return component;
}
function html_clear(element) {
  html_text_set(element, "");
}
function app_reply_choices() {
  let education = app_reply_pray("Education", "provide education to those in need 🏫");
  let heal = app_reply_pray("Heal", "heal the sick");
  let job = app_reply_pray("Job", "provide you with a good job");
  let provide = app_reply_pray("Provide", "provide what is needed");
  let travel_pray = app_reply_pray("Travel pray", "give you safe travels " + emoji_dove());
  let will = app_reply_pray("Will", "have His will done " + emoji_dove());
  let with2 = app_reply_pray("With", "always be with you " + emoji_dove());
  let v = [{
    text: emoji_pray() + " Amen",
    response: prayer_end()
  }, {
    text: emoji_question() + " Ask",
    response: "What are you asking me to do?"
  }, {
    text: emoji_pray() + " Bless",
    response: prayer_start() + string_lord_bless() + "you, your family, your church and your country exceedingly abundantly more than anyone can ask or think " + prayer_end()
  }, {
    text: emoji_pray() + " Bless short",
    response: "God bless" + prayer_end()
  }, {
    text: emoji_phone() + " Call why?",
    response: emoji_phone() + " Why did you call me? What did you want to talk about?"
  }, {
    text: emoji_phone() + " Call no",
    response: emoji_phone() + " No video call"
  }, {
    text: emoji_pray() + " Church",
    response: emoji_pray() + string_lord_bless_your() + "church " + emoji_church()
  }, education, {
    text: emoji_pray() + " Family",
    response: emoji_pray() + string_lord_bless_your() + "family " + emoji_family()
  }, {
    text: emoji_pray() + " Future",
    response: emoji_pray() + "God knows the future. I do not know the future." + emoji_question()
  }, {
    text: emoji_fire() + " Glory",
    response: emoji_pray() + " All glory to God " + emoji_trinity() + " ! "
  }, {
    text: emoji_pray() + " Give",
    response: emoji_pray() + " Sorry, I have nothing to give you at this time. According to the desire of the LORD: May the LORD provide and may the LORD lead you to someone who will abundantly provide whatever you ask the same day you ask."
  }, {
    text: emoji_wave() + " Greetings",
    response: emoji_wave() + emoji_smile() + " Greetings in the name of our LORD Jesus Christ! " + emoji_cross()
  }, {
    text: emoji_hands_raising() + " Hallelujah",
    response: emoji_hands_raising() + " Hallelujah! Hallelujah! Hallelujah! " + emoji_pray()
  }, heal, {
    text: emoji_pray() + " Health",
    response: emoji_pray() + " The doctors said I had a diagnosis of schizoaffective disorder. Please pray for my health, that I am healed from everything and that those who gave me medicine command me to stop taking medicine."
  }, {
    text: emoji_pray() + " Help",
    response: "God help us" + prayer_end()
  }, {
    text: emoji_question() + " Help what",
    response: emoji_pray() + "What help are you asking for? What are you asking me to do?"
  }, {
    text: emoji_ok() + " How day",
    response: emoji_ok() + " The day of the " + string_the_servant_of_god_is() + " doing good " + emoji_100() + " through the grace of God, because " + emoji_book_open() + " all things work together for good to them that love God and are called according to the purpose of God! (Romans 8:28) However please pray that the servant of God will stop hearing demons" + emoji_pray()
  }, {
    text: emoji_pray() + " How family",
    response: emoji_pray() + "Please pray for my family"
  }, {
    text: emoji_ok() + "How r u",
    response: emoji_ok() + " " + string_the_servant_of_god_is() + " doing good " + emoji_100() + " through the grace of God, because " + emoji_book_open() + " all things work together for good to them that love God and are called according to the purpose of God! (Romans 8:28) However please pray that the servant of God will stop hearing demons" + emoji_pray()
  }, {
    text: emoji_pray() + " Invite",
    response: emoji_pray() + "If the LORD makes a way, then I will travel to you. However at this time I have no money to travel."
  }, job, {
    text: emoji_globe_americas() + " Language",
    response: emoji_globe_americas() + " " + string_the_servant_of_god() + " speaks English. " + emoji_pray()
  }, {
    text: emoji_question() + " Languages",
    response: "Do you speak any languages besides English?"
  }, {
    text: emoji_globe_americas() + " Location",
    response: emoji_globe_americas() + " " + string_the_servant_of_god_is() + " from 🇺🇸 the United States of America, state of Florida, city of Jacksonville. " + emoji_pray()
  }, {
    text: emoji_wave() + " Meet",
    response: emoji_pray() + " Nice to meet you! " + emoji_handshake()
  }, {
    text: emoji_wave() + " Name",
    response: emoji_pray() + " " + string_the_servant_of_god_is() + " called Jared Patten Mathis " + emoji_handshake()
  }, {
    text: emoji_ok() + "Okay",
    response: emoji_ok() + " " + string_the_servant_of_god_is() + " okay, yes " + emoji_100() + " " + emoji_pray()
  }, {
    text: emoji_dove() + " Peace",
    response: emoji_dove() + " Now may the Lord of peace himself give you peace at all times and in every way. The Lord be with all of you " + emoji_rainbow()
  }, {
    text: "🎵 Praise",
    response: " 🎵 " + emoji_voice() + " Praise the LORD our God in the name of Jesus Christ! 🎶"
  }, {
    text: emoji_pray() + " Pray",
    response: prayer_start()
  }, {
    text: emoji_pray() + " Preach",
    response: emoji_pray() + "If God wills, then yes I will preach. I am not available 10 am to 12 pm every day EST. Do you have a day and time?"
  }, {
    text: emoji_pray() + " " + "Prayers",
    response: emoji_pray() + "According to the desire of God, may there be prayer"
  }, {
    text: emoji_pray() + " " + "Programming",
    response: emoji_pray() + "I have been computer programming 💻"
  }, {
    text: emoji_pray() + " " + "Replying",
    response: emoji_pray() + "I have been replying to messages 📨"
  }, {
    text: emoji_pray() + " Share",
    response: emoji_pray() + " What day and time are you asking me to share the word of God? " + emoji_book_open()
  }, provide, {
    text: emoji_pray() + " Sleep",
    response: emoji_pray() + emoji_sleep_z() + " " + string_lord_bless_your() + "sleep, make your sleep sweet and peaceful, protect you from demons, bad dreams and all harm, and make you wake up feeling refreshed. " + emoji_sleep_face()
  }, {
    text: "Song",
    response: "https://youtu.be/rNhSoUKPgMQ" + newline() + newline() + " Jesus gave me the grace to write this song"
  }, {
    text: emoji_pray() + " Testimony",
    response: emoji_pray() + " Jesus died for my sins. " + emoji_cross() + " Jesus was buried. " + emoji_rock() + " Jesus rose to life. " + emoji_pray() + emoji_church() + " I confessed this truth since I was about 7 years old. But I never decided to fully obey Jesus as LORD until I was about 26 years old. Then eventually God called me to ministry. " + emoji_cross() + emoji_smile()
  }, {
    text: emoji_pray() + " Thank God",
    response: emoji_pray() + " Thank the LORD, our God! " + emoji_smile()
  }, {
    text: emoji_pray() + " Thank you",
    response: emoji_pray() + " Thank you very much! " + emoji_smile()
  }, {
    text: emoji_pray() + " Travel ask",
    response: emoji_pray() + "No money for travel"
  }, travel_pray, {
    text: emoji_question() + " What",
    response: emoji_pray() + "What do you mean?"
  }, {
    text: emoji_phone() + " WhatsApp",
    response: emoji_phone() + " WhatsApp: +1-904-314-4052"
  }, will, {
    text: emoji_pray() + " Wills",
    response: emoji_pray() + " If God wills, yes"
  }, with2];
  return v;
}
function emoji_handshake() {
  let v2 = "🤝";
  return v2;
}
function newline() {
  let v = "\n";
  return v;
}
function emoji_rock() {
  let v2 = "🪨";
  return v2;
}
function emoji_rainbow() {
  let v2 = "🌈";
  return v2;
}
function string_the_servant_of_god() {
  let v2 = "The servant of God";
  return v2;
}
function emoji_question() {
  let v2 = "❓";
  return v2;
}
function emoji_dove() {
  let v = "🕊️";
  return v;
}
function app_reply_pray(pray_title, pray_request) {
  let v2 = {
    text: emoji_pray() + " " + pray_title,
    response: emoji_pray() + string_may_the_lord() + pray_request
  };
  return v2;
}
function string_may_the_lord() {
  let v = "May the LORD ";
  return v;
}
function emoji_pray() {
  let v = "🙏";
  return v;
}
function emoji_family() {
  let v2 = "👨‍👩‍👧‍👦";
  return v2;
}
function emoji_voice() {
  let v2 = "🗣️";
  return v2;
}
function emoji_hands_raising() {
  let v2 = "🙌";
  return v2;
}
function emoji_church() {
  let v2 = "⛪";
  return v2;
}
function string_lord_bless() {
  let v = string_may_the_lord() + "bless ";
  return v;
}
function string_lord_bless_your() {
  let blessing = string_lord_bless() + "your ";
  return blessing;
}
function emoji_phone() {
  let v2 = "📞";
  return v2;
}
function emoji_sleep_face() {
  let v = "😴";
  return v;
}
function emoji_sleep_z() {
  let v = "💤";
  return v;
}
function emoji_globe_americas() {
  let v = "🌎";
  return v;
}
function emoji_book_open() {
  let v = "📖";
  return v;
}
function emoji_100() {
  let v = "💯";
  return v;
}
function string_the_servant_of_god_is() {
  let v = string_the_servant_of_god() + " is";
  return v;
}
function emoji_ok() {
  let v = "👌";
  return v;
}
function emoji_cross() {
  let v = "✝️";
  return v;
}
function emoji_smile() {
  let v = "😁";
  return v;
}
function emoji_wave() {
  let v = "👋";
  return v;
}
function emoji_trinity() {
  let v = emoji_heart_fire() + emoji_cross() + emoji_dove();
  return v;
}
function emoji_heart_fire() {
  let v2 = "❤️‍🔥";
  return v2;
}
function emoji_fire() {
  let v = "🔥";
  return v;
}
function prayer_start() {
  let v = "🙇 In the name of the Father, and of the Son, and of the Holy Spirit" + " " + emoji_trinity() + " : ";
  return v;
}
function prayer_end() {
  marker("1");
  let v = " Amen! " + emoji_pray();
  return v;
}
function list_empty(list) {
  object_property_set(list, "length", 0);
}
function list_join_newline_2(list) {
  marker("1");
  let separator = newline();
  let joined = list_join(list, separator + separator);
  return joined;
}
async function clipboard_copy(text) {
  let b = browser_is();
  if (b) {
    await navigator.clipboard.writeText(text);
    return;
  }
  const clipboard = await import("clipboardy");
  await clipboard.default.write(text);
}
function html_button(parent, text, lambda) {
  assert_arguments(arguments, 3);
  let component = html_button_element(parent);
  html_text_set(component, text);
  html_on_click(component, lambda);
  html_style_font_size(component, "inherit");
  return component;
}
function html_style_font_size(html, value) {
  html_style_set(html, "font-size", value);
}
function html_on_click(component, lambda) {
  const name_event = "click";
  html_on(component, name_event, lambda);
}
function html_button_element(parent) {
  marker("1");
  const tag_name = "button";
  let b = html_element(parent, tag_name);
  return b;
}
async function firebase_storage_function_run(f_name, version_get) {
  marker("1");
  let destination_version = version_get(f_name);
  let destination = await firebase_storage_download_property(destination_version, "destination");
  let code = await firebase_storage_download_property(destination, "code");
  let call = js_code_call_statement(f_name);
  let global_init = js_code_global_init();
  let joined = list_join_newline([global_init, call, code]);
  if (browser_is()) {
    let body = html_document_body();
    let component = html_element(body, "script");
    html_attribute_set(component, "type", "module");
    html_text_set(component, joined);
    return;
  }
  eval(joined);
}
function js_code_global_init() {
  let right = js_code_braces_empty();
  let code_assign = js_code_let_assign("global", right);
  return code_assign;
}
function js_code_let_assign(left, right) {
  let code_assign = js_keyword_let() + " " + js_code_assign(left, right) + ";";
  return code_assign;
}
function js_code_assign(left, right) {
  const code = left + " = " + right;
  return code;
}
function js_keyword_let() {
  let v = "let";
  return v;
}
function js_code_braces_empty() {
  let v = js_code_wrap_braces("");
  return v;
}
function js_code_wrap_braces(inside) {
  let v = "{" + inside + "}";
  return v;
}
function html_attribute_set(component, key, value) {
  let element = html_component_element_get(component);
  element.setAttribute(key, value);
}
function list_join_newline(list) {
  let separator = newline();
  let joined = list_join(list, separator);
  return joined;
}
function js_code_call_statement(f_name) {
  let code = js_code_call(f_name);
  let result = js_code_statement(code);
  return result;
}
function js_code_call(fn_name) {
  let args = [];
  let result = js_code_call_args(fn_name, args);
  return result;
}
function js_code_call_args(fn_name, args) {
  let joined = list_join_comma_space(args);
  let code = fn_name + js_code_wrap_parenthesis(joined);
  return code;
}
function js_code_wrap_parenthesis(inside) {
  let v = "( " + inside + " )";
  return v;
}
function js_code_statement(code) {
  let v = code + ";";
  return v;
}
async function firebase_storage_download_property(storage_path, property_name) {
  let buffer = await firebase_storage_download(storage_path);
  const json = buffer_string_to(buffer);
  let o = json_from(json);
  let value = object_property_get(o, property_name);
  return value;
}
  </script>
</body>
</html>