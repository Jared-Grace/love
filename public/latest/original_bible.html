<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>original_bible</title>
</head>
<body>
  <script type="importmap"> 
    {
 "imports": {
  "lz-string": "https://cdn.jsdelivr.net/npm/lz-string@1.5.0/+esm"
 }
}
  </script>
<script type="module"> 
    let global = {};
async function app_context_initialize(fn) {
  const root = html_document_body();
  await app_context_initialize_root(root, fn);
}
async function app_context_initialize_root(root, fn) {
  let context = {
    root
  };
  await fn(context);
}
function html_document_body() {
  let body_element = document.body;
  let body = html_component_wrap(body_element);
  return body;
}
function html_component_wrap(element) {
  let c = {
    element
  };
  return c;
}
async function app_original_bible_main(context) {
  try {
    let app_fn = app_original_bible;
    let screens = app_original_bible_screens();
    let screen_home = app_original_bible_home;
    await app_ceb_bible_main_generic(context, app_fn, screens, screen_home);
  } catch (e) {
    alert(e);
    let body = html_document_body();
    let json = json_to(e);
    let p = html_pre_text(body, json);
  }
}
function html_pre_text(root, text) {
  let pre = html_pre(root);
  html_text_set(pre, text);
  return pre;
}
function html_pre(root) {
  let component = html_element(root, "pre");
  return component;
}
function html_element(parent, tag_name) {
  const e = document.createElement(tag_name);
  let component = html_component_wrap(e);
  html_parent_append(parent, component);
  html_style_set(component, "box-sizing", "border-box");
  return component;
}
function html_parent_append(parent, child) {
  let parent_element = html_component_element_get(parent);
  let child_element = html_component_element_get(child);
  parent_element.appendChild(child_element);
}
function html_component_element_get(component) {
  let element = property_get(component, "element");
  return element;
}
function property_get(object, property_name) {
  let value = object[property_name];
  undefined_not_is_assert_lambda(value, object_get);
  function object_get() {
    let v = {
      object,
      property_name
    };
    return v;
  }
  return value;
}
function undefined_not_is_assert_lambda(value, lambda) {
  if (undefined_is(value)) {
    const object = lambda();
    let message = json_to(object);
    error(message);
  }
}
function error(message) {
  throw new Error(message);
}
function json_to(object) {
  let json = JSON.stringify(object);
  return json;
}
function undefined_is(value) {
  let v = typeof value === "undefined";
  return v;
}
function html_style_set(b, style_key, style_value) {
  let b_element = html_component_element_get(b);
  b_element.style[style_key] = style_value;
}
function html_text_set(component, text) {
  let element = html_component_element_get(component);
  element.innerHTML = text;
}
async function app_ceb_bible_main_generic(context, app_fn, screens, screen_home) {
  app_bible_main_generic_before(context, app_fn, screens, screen_home);
  await app_shared_refresh(context);
}
async function app_shared_refresh(context) {
  let screens = property_get(context, "screens");
  let app_fn = property_get(context, "app_fn");
  let body = html_document_body();
  html_clear(body);
  let value = property_get(app_fn, "name");
  let combined = function_name_combine(value, "home");
  let screen_name = storage_local_initialize_context(context, "screen", combined);
  let screen = list_find_property(screens, "name", screen_name);
  await screen(context);
}
function function_name_combine(left, right) {
  const combined = function_name_combine_multiple([left, right]);
  return combined;
}
function function_name_combine_multiple(parts) {
  let separator = function_name_separator();
  const combined = list_join(parts, separator);
  return combined;
}
function function_name_separator() {
  const separator = "_";
  return separator;
}
function list_join(list, separator) {
  let l = list_is(list);
  if (not(l)) {
    error_json({
      list
    });
  }
  let joined = list.join(separator);
  return joined;
}
function not(b) {
  let n = !b;
  return n;
}
function list_is(value) {
  const l = Array.isArray(value);
  return l;
}
function error_json(o) {
  let message = json_format_to_truncated(o);
  error(message);
}
function json_format_to_truncated(object) {
  let j = json_format_to(object);
  let taken = text_take(j, 10000);
  return taken;
}
function json_format_to(object) {
  let r = JSON.stringify(object, null, 1);
  return r;
}
function text_take(s, count) {
  let taken = text_slice(s, 0, count);
  return taken;
}
function text_slice(s, from, to) {
  let sliced = s.slice(from, to);
  return sliced;
}
function storage_local_initialize_context(context, key, value_initial) {
  let app_fn = property_get(context, "app_fn");
  let value = storage_local_initialize(app_fn, key, value_initial);
  return value;
}
function storage_local_initialize(app_fn, key, value_initial) {
  let value = storage_local_get(app_fn, key);
  let n = null_is(value);
  if (n) {
    log({
      value_initial
    });
    storage_local_set(app_fn, key, value_initial);
    value = storage_local_get(app_fn, key);
  }
  return value;
}
function log(message) {
  log_keep(message);
  let a = 1;
}
function log_keep(message) {
  console.log(message);
}
function storage_local_set(app_fn, key, value) {
  let storage_local_key = storage_local_key_get(app_fn, key);
  if (storage_local_enabled()) {
    storage_local_specify_set(storage_local_key, value);
    return;
  }
  global_function_property_set(storage_local_set, storage_local_key, value);
}
function global_function_property_set(fn, property_name, value) {
  let fn_object = global_function_initialize(fn, {});
  property_set(fn_object, property_name, value);
}
function property_set(object, property_name, value) {
  object[property_name] = value;
}
function global_function_initialize(fn, initial) {
  assert_arguments(arguments, 2);
  let value_get = lambda_get(initial);
  let value = global_function_initialize_lambda(fn, value_get);
  return value;
}
function global_function_initialize_lambda(fn, lambda) {
  assert_arguments(arguments, 2);
  let global = global_get();
  let value = property_initialize_lambda(global, fn.name, lambda);
  return value;
}
function property_initialize_lambda(object, property_name, lambda) {
  const exists = property_exists(object, property_name);
  if (not(exists)) {
    let value_set = lambda();
    property_set(object, property_name, value_set);
  }
  let value = property_get(object, property_name);
  return value;
}
function property_exists(object, property_name) {
  const exists = object && Object.hasOwn(object, property_name);
  return exists;
}
function assert_arguments(args, count) {
  let length = property_get(args, "length");
  equal_assert(length, count);
}
function equal_assert(left, right) {
  let eq = equal(left, right);
  assert(eq);
}
function assert(b) {
  if (not(b)) {
    error();
  }
}
function equal(left, right) {
  let eq = left === right;
  return eq;
}
function global_get() {
  let exists = property_exists(global, global_alternate_set.name);
  if (exists) {
    let value = property_get(global, global_alternate_set.name);
    return value;
  }
  return global;
}
function global_alternate_set(global_alternate) {
  let global = global_get();
  global_function_set(global_alternate_set, global_alternate);
  let unset = function lambda() {
    property_delete(global, global_alternate_set.name);
  };
  return unset;
}
function property_delete(object, property_name) {
  property_exists_assert(object, property_name);
  delete object[property_name];
}
function property_exists_assert(object, property_name) {
  let result = property_exists(object, property_name);
  function lambda() {
    let v = {
      object,
      property_name
    };
    return v;
  }
  assert_json_get(result, lambda);
}
function assert_json_get(b, lambda) {
  function json_get() {
    let object = lambda();
    let json = json_to(object);
    return json;
  }
  assert_message_get(b, json_get);
}
function assert_message_get(b, lambda) {
  if (not(b)) {
    let message = lambda();
    error(message);
  }
}
function global_function_set(fn, value) {
  let global = global_get();
  property_set(global, fn.name, value);
}
function lambda_get(value) {
  function value_get() {
    return value;
  }
  return value_get;
}
function storage_local_specify_set(storage_local_key, value) {
  value = undefined_is_if_null(value);
  let j = json_to({
    value
  });
  localStorage.setItem(storage_local_key, j);
}
function undefined_is_if_null(result) {
  if (undefined_is(result)) {
    result = null;
  }
  return result;
}
function storage_local_key_get(app_fn, key) {
  let ley = app_fn.name + " " + key;
  return ley;
}
function storage_local_enabled() {
  let set = global_function_exists(storage_local_enabled);
  let enabled = not(set) || global_function_get(storage_local_enabled) === true;
  return enabled;
}
function global_function_get(fn) {
  let global = global_get();
  let value = property_get(global, fn.name);
  return value;
}
function global_function_exists(fn) {
  let global = global_get();
  let exists = property_exists(global, fn.name);
  return exists;
}
function null_is(value) {
  const n = value === null;
  return n;
}
function storage_local_get(app_fn, key) {
  let storage_local_key = storage_local_key_get(app_fn, key);
  if (storage_local_enabled()) {
    let result = storage_local_specify_get(storage_local_key);
    return result;
  }
  let value = storage_local_get_global(storage_local_key);
  return value;
}
function storage_local_get_global(storage_local_key) {
  let exists = storage_local_exists_global(storage_local_key);
  "localStorage has this behavior of null if not exists, so the in-memory version also mirrors api";
  let value = null;
  if (exists) {
    value = global_function_property_get(storage_local_set, storage_local_key);
  }
  return value;
}
function storage_local_exists_global(storage_local_key) {
  let exists2 = global_function_property_exists(storage_local_set, storage_local_key);
  return exists2;
}
function global_function_property_exists(fn, property_name) {
  let fn_object = global_function_initialize_object(fn);
  let exists = property_exists(fn_object, property_name);
  return exists;
}
function global_function_initialize_object(fn) {
  let value = global_function_initialize(fn, {});
  return value;
}
function global_function_property_get(fn, property_name) {
  let fn_object = global_function_initialize(fn, {});
  let value = property_get(fn_object, property_name);
  return value;
}
function storage_local_specify_get(storage_local_key) {
  let json = storage_local_specify_get_json(storage_local_key);
  let nn = null_not_is(json);
  let result = null;
  if (nn) {
    let r = json_from(json);
    result = property_get(r, "value");
  }
  return result;
}
function null_not_is(value) {
  let nn = value !== null;
  return nn;
}
function storage_local_specify_get_json(storage_local_key) {
  let r = localStorage.getItem(storage_local_key);
  return r;
}
function json_from(json) {
  let v = JSON.parse(json);
  return v;
}
function html_clear(element) {
  html_text_set(element, "");
}
function list_find_property(list, property_name, property_value) {
  let filter = property_equals_lambda(property_name, property_value);
  let item = list_find(list, filter);
  return item;
}
function property_equals_lambda(property_name, property_value) {
  let v2 = function object_property_equals_lambda_result(item) {
    let v = property_equals(item, property_name, property_value);
    return v;
  };
  return v2;
}
function property_equals(item, property_name, property_value) {
  let left = property_get(item, property_name);
  let eq = equal(left, property_value);
  return eq;
}
function list_find(list, lambda$item) {
  let filtered = list_filter(list, lambda$item);
  let found = list_single(filtered);
  return found;
}
function list_filter(list, lambda$item) {
  list_is_assert(list);
  function list_filter_lambda(item) {
    let match = lambda$item(item);
    return match;
  }
  let filtered = list.filter(list_filter_lambda);
  return filtered;
}
function list_is_assert(list) {
  function lambda() {
    let v = {
      list
    };
    return v;
  }
  list_is_assert_json(list, lambda);
}
function list_is_assert_json(list, lambda) {
  let result = list_is(list);
  assert_json_get(result, lambda);
}
function list_single(list) {
  list_size_1_assert(list);
  let only = list_first(list);
  return only;
}
function list_size_1_assert(list) {
  list_size_1_assert_message(list, {});
}
function list_size_1_assert_message(list, message) {
  list_size_assert_message(list, 1, message);
}
function list_size_assert_message(list, size, message) {
  let a = list_size(list) === size;
  if (not(a)) {
    error_json({
      message,
      list,
      size
    });
  }
}
function list_size(list) {
  list_is_assert(list);
  let size = list.length;
  return size;
}
function list_first(list) {
  const index = 0;
  const first = list_get(list, index);
  return first;
}
function list_get(list, index) {
  integer_is_assert(index);
  let item = list[index];
  undefined_not_is_assert_lambda(item, object_get);
  function object_get() {
    let v = {
      list,
      index
    };
    return v;
  }
  return item;
}
function integer_is_assert(index) {
  let ii = integer_is(index);
  assert_json(ii, {
    index
  });
}
function assert_json(b, o) {
  let message = json_to(o);
  assert_message(b, message);
}
function assert_message(b, message) {
  if (not(b)) {
    error(message);
  }
}
function integer_is(value) {
  let ii = Number.isInteger(value);
  return ii;
}
function app_bible_main_generic_before(context, app_fn, screens, screen_home) {
  object_merge(context, {
    app_fn,
    screens,
    screen_home
  });
  firebase_name_jg();
  let root = html_mobile_default(context);
  html_margin_0(root);
}
function html_margin_0(root) {
  html_style_assign(root, {
    margin: 0
  });
}
function html_style_assign(b, s) {
  let b_element = html_component_element_get(b);
  object_assign(b_element.style, s);
}
function object_assign(to, from) {
  Object.assign(to, from);
}
function html_mobile_default(context) {
  let root = html_mobile_default_font_size_context(context);
  html_meta_viewport();
  html_font_sans_serif_set_html();
  return root;
}
function html_mobile_default_font_size_context(context) {
  let root = property_get(context, "root");
  html_mobile_default_font_size(root);
  return root;
}
function html_mobile_default_font_size(root) {
  html_style_font_size(root, "25px");
}
function html_style_font_size(html, value) {
  html_style_set(html, "font-size", value);
}
function html_font_sans_serif_set_html() {
  let html2 = html_document_root();
  html_roboto_include();
  let style_value = html_font_sans_serif_value();
  html_font_set(html2, style_value);
  const style = ":font-family: " + html_font_sans_serif_value();
  html_style_button(style);
}
function html_style_button(style) {
  html_style_head("button { " + style + " }");
}
function html_style_head(style_text) {
  let parent = html_document_head();
  let component = html_element(parent, "style");
  html_text_set(component, style_text);
}
function html_document_head() {
  let head_e = document.head;
  let head = html_component_wrap(head_e);
  return head;
}
function html_roboto_include() {
  const href = "https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap";
  let fn = html_roboto_include;
  html_font_include(fn, href);
}
function html_font_include(fn, href) {
  global_function_once(lambda, fn);
  function lambda() {
    html_stylesheet(href);
  }
}
function html_stylesheet(href) {
  let l = html_link();
  html_attribute_set(l, "href", href);
  html_attribute_set(l, "rel", "stylesheet");
}
function html_attribute_set(component, key, value) {
  let element = html_component_element_get(component);
  element.setAttribute(key, value);
}
function html_link() {
  let head = html_document_head();
  let link = html_element(head, "link");
  return link;
}
function global_function_once(lambda, fn) {
  function value_get() {
    lambda();
    let v = true;
    return v;
  }
  global_function_initialize_lambda(fn, value_get);
}
function html_font_set(html, value) {
  html_style_set(html, "font-family", value);
}
function html_font_sans_serif_value() {
  let v = '"Roboto", Arial, Helvetica, sans-serif';
  return v;
}
function html_document_root() {
  let html_element = document.documentElement;
  let html = html_component_wrap(html_element);
  return html;
}
function html_meta_viewport() {
  const head = html_document_head();
  let component = html_element(head, "meta");
  html_attribute_set(component, "name", "viewport");
  html_attribute_set(component, "content", "width=device-width, initial-scale=1.0");
}
function firebase_name_jg() {
  global_function_initialize(firebase_name, "jared-grace");
}
async function firebase_name() {
  if (browser_is()) {
    let value = global_function_get(firebase_name);
    return value;
  }
  let repo_name = await user_repo_get();
  let default2 = await firebase_name_repo(repo_name);
  return default2;
}
async function firebase_name_repo(repo_name) {
  const f_path = ".firebaserc";
  let combined = repo_path_combine(repo_name, f_path);
  let f = await file_read_json(combined);
  let projects = property_get(f, "projects");
  let default2 = property_get(projects, "default");
  return default2;
}
async function file_read_json(file_path) {
  let json = await file_read(file_path);
  let data = json_from(json);
  return data;
}
async function file_read(file_path) {
  let exists = global_function_property_exists(file_read_cached, file_path);
  if (exists) {
    let c = await global_function_property_get(file_read_cached, file_path);
    return c;
  }
  if (browser_is()) {
    file_path = file_path_normalize(file_path);
    await app_a_file_system_initialize();
    let store = app_a_file_system_store();
    let item = await indexeddb_get(app_a_indexeddb_initialize, store, file_path);
    let compressed = property_get(item, "compressed");
    let f = await json_decompress(compressed);
    let versions = property_get(f, "versions");
    let last = list_last(versions);
    return last;
  }
  let fs = await import("fs");
  let contents = await fs.promises.readFile(file_path, "utf-8");
  return contents;
}
async function file_read_cached(f_path) {
  let exists = global_function_property_exists(file_read_cached, f_path);
  if (exists) {
    let v2 = false;
    return v2;
  }
  assert_not(exists);
  let contents = await file_read(f_path);
  global_function_property_set(file_read_cached, f_path, contents);
  let v = true;
  return v;
}
function assert_not(b) {
  if (b) {
    error();
  }
}
async function json_decompress(compressed) {
  let json = await text_decompress(compressed);
  let text = json_from(json);
  return text;
}
async function text_decompress(compressed) {
  let lz = null;
  let condition = browser_is();
  let result = null;
  if (condition) {
    result = (await import("lz-string")).default;
  } else {
    result = LZString;
  }
  lz = result;
  let v = lz.decompressFromUTF16(compressed);
  return v;
}
function browser_is() {
  let b = typeof window !== "undefined" && typeof window.document !== "undefined";
  return b;
}
function list_last(list) {
  list_empty_not_is_assert(list);
  let last = list_get_end(list, 0);
  return last;
}
function list_empty_not_is_assert(list) {
  let ne = list_empty_not_is(list);
  assert(ne);
}
function list_empty_not_is(list) {
  let a = list_empty_is(list);
  const ne = not(a);
  return ne;
}
function list_empty_is(list) {
  const e = list_size(list) === 0;
  return e;
}
function list_get_end(list, index_from_end) {
  const difference = list_index_end(list, index_from_end);
  const item = list_get(list, difference);
  return item;
}
function list_index_end(list, index_from_end) {
  let v = list_size(list) - 1 - index_from_end;
  return v;
}
function file_path_normalize(file_path) {
  file_path = path_normalize(file_path);
  const prefix = "../";
  let n = text_starts_with_not(file_path, prefix);
  if (n) {
    file_path = prefix + "love/" + file_path;
  }
  return file_path;
}
function text_starts_with_not(item, book_code) {
  let a = text_starts_with(item, book_code);
  let sw = not(a);
  return sw;
}
function text_starts_with(t, prefix) {
  let sw = t.startsWith(prefix);
  return sw;
}
function path_normalize(path) {
  let n = path.replace(/\\/g, "/").replace(/\/+/g, "/").replace(/\/\.\//g, "/").replace(/\/$/, "").replace(/^\.\/+/, "");
  return n;
}
async function app_a_indexeddb_initialize() {
  const db_name = app_a.name;
  const version = 1;
  const store_files = "files";
  const db = await new Promise(function lambda4(resolve, reject) {
    const req = indexedDB.open(db_name, version);
    req.onupgradeneeded = function lambda() {
      const db = req.result;
      let b = db.objectStoreNames.contains(store_files);
      if (not(b)) {
        db.createObjectStore(store_files, {
          keyPath: app_a_indexeddb_path_key()
        });
      }
    };
    req.onsuccess = function lambda2() {
      let v = resolve(req.result);
      return v;
    };
    req.onerror = function lambda3() {
      let v2 = reject(req.error);
      return v2;
    };
  });
  return db;
}
function app_a_indexeddb_path_key() {
  let v3 = "key";
  return v3;
}
async function app_a() {
  await app_main_production("app_a_main", "jared-grace");
}
async function app_main_production(f_name, firebase_name_value) {
  let v = await app_main(f_name, firebase_name_value, firebase_deploy_function_destination_production);
  return v;
}
function firebase_deploy_function_destination_production(f_name) {
  let destination2 = firebase_deploy_function_destination_json("version_production", f_name);
  return destination2;
}
function firebase_deploy_function_destination_json(name, f_name) {
  let file_name = file_name_json(name);
  let destination = firebase_deploy_function_destination(f_name, file_name);
  return destination;
}
function firebase_deploy_function_destination(f_name, file_name) {
  const list = ["function", f_name, file_name];
  let destination = list_join_slash_forward(list);
  return destination;
}
function list_join_slash_forward(list) {
  let joined = list_join(list, "/");
  return joined;
}
function file_name_json(name) {
  let file_name = name + json_extension();
  return file_name;
}
function json_extension() {
  let ext_j = ".json";
  return ext_j;
}
async function app_main(f_name, firebase_name_value, version_get) {
  global_function_initialize(firebase_name, firebase_name_value);
  let call = js_code_call_app_context_initialize(f_name);
  await firebase_storage_function_run_generic(version_get, f_name, call);
}
function js_code_call_app_context_initialize(name_prefixed) {
  let result = js_code_call_args_statement(app_context_initialize.name, [name_prefixed]);
  return result;
}
function js_code_call_args_statement(f_name, args) {
  let code = js_code_call_args(f_name, args);
  let result = js_code_statement(code);
  return result;
}
function js_code_call_args(fn_name, args) {
  assert_arguments(arguments, 2);
  let joined = list_join_comma_space(args);
  let code = fn_name + js_code_wrap_parenthesis(joined);
  return code;
}
function fn_name(f_name) {
  return f_name;
}
function js_code_wrap_parenthesis(inside) {
  const inside_larger = " " + inside + " ";
  let v = text_wrap_parenthesis(inside_larger);
  return v;
}
function text_wrap_parenthesis(inside) {
  let v2 = js_code_parenthesis_left() + inside + js_code_parenthesis_right();
  return v2;
}
function js_code_parenthesis_right() {
  let v2 = ")";
  return v2;
}
function js_code_parenthesis_left() {
  let v3 = "(";
  return v3;
}
function list_join_comma_space(args) {
  let v = list_join(args, ", ");
  return v;
}
function js_code_statement(code) {
  let v = code + js_code_semicolon();
  return v;
}
function js_code_semicolon() {
  let v2 = ";";
  return v2;
}
async function firebase_storage_function_run_generic(version_get, f_name, call) {
  let destination_version = version_get(f_name);
  let destination = await firebase_storage_download_property(destination_version, "destination");
  let code = await firebase_storage_download_property(destination, "code");
  let global_init = js_code_global_init();
  let joined = list_join_newline([global_init, code, call]);
  if (browser_is()) {
    let body = html_document_body();
    let component = html_element(body, "script");
    html_attribute_set(component, "type", "module");
    html_text_set(component, joined);
  } else {
    eval(joined);
  }
}
function list_join_newline(list) {
  let separator = newline();
  let joined = list_join(list, separator);
  return joined;
}
function newline() {
  let v = "\n";
  return v;
}
function js_code_global_init() {
  let right = js_code_braces_empty();
  let left = global_name();
  let code_assign = js_code_let_assign(left, right);
  return code_assign;
}
function global_name() {
  let global = "global";
  return global;
}
function js_code_let_assign(left, right) {
  let code_assign = js_keyword_let() + " " + js_code_assign(left, right) + ";";
  return code_assign;
}
function js_code_assign(left, right) {
  const code = left + js_code_equals_padded() + right;
  return code;
}
function js_code_equals_padded() {
  let v = " = ";
  return v;
}
function js_keyword_let() {
  let v = "let";
  return v;
}
function js_code_braces_empty() {
  let v = js_code_wrap_braces("");
  return v;
}
function js_code_wrap_braces(inside) {
  let w = js_code_brace_left() + inside + js_code_brace_right();
  return w;
}
function js_code_brace_right() {
  let v2 = "}";
  return v2;
}
function js_code_brace_left() {
  let v2 = "{";
  return v2;
}
async function firebase_storage_download_property(storage_path, property_name) {
  let buffer = await firebase_storage_download(storage_path);
  const json = buffer_text_to(buffer);
  let o = json_from(json);
  let value = property_get(o, property_name);
  return value;
}
function buffer_text_to(buffer) {
  let s = null;
  let b = browser_is();
  if (b) {
    if (buffer instanceof ArrayBuffer) {
      s = new TextDecoder("utf-8").decode(new Uint8Array(buffer));
    } else if (buffer instanceof Uint8Array) {
      s = new TextDecoder("utf-8").decode(buffer);
    } else {
      throw new Error("Unsupported buffer type");
    }
  } else {
    s = buffer.toString("utf8");
  }
  return s;
}
async function firebase_storage_download(destination) {
  destination = firebase_path_fix(destination);
  let b = browser_is();
  if (b) {
    async function lambda2() {
      let url = await firebase_storage_url(destination);
      let buffer = await http(url);
      return buffer;
    }
    let result = await html_loading(lambda2);
    return result;
  }
  const bucket = await firebase_bucket();
  let [buffer] = await bucket.file(destination).download();
  return buffer;
}
async function html_loading(lambda) {
  let div = null;
  let b2 = browser_is();
  if (b2) {
    let body = html_document_body();
    div = html_div(body);
    let s = {
      position: "fixed",
      top: "0",
      left: "0",
      width: "100vw",
      height: "100vh",
      background: "rgba(0, 0, 0, 0.6)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      zIndex: "1000"
    };
    html_style_assign(div, s);
  }
  let result = null;
  try {
    result = await lambda();
  } catch (e) {
    throw e;
  } finally {
    if (b2) {
      html_remove(div);
    }
  }
  return result;
}
function html_remove(component) {
  let element = html_component_element_get(component);
  element.remove();
}
function html_div(root) {
  let div = html_element(root, "div");
  return div;
}
async function http(url) {
  let options = http_get_options();
  let v = await http_generic(url, options);
  return v;
}
function http_get_options() {
  let v2 = {
    method: "GET"
  };
  return v2;
}
async function http_generic(url, options) {
  const method = options.method || "GET";
  const body = options.body || null;
  const b = browser_is();
  if (b) {
    async function lambda3() {
      const r = {
        method
      };
      let exists = property_exists(options, "body");
      if (exists) {
        object_assign(r, {
          headers: {
            "Content-Type": "application/json",
            ...options.headers || ({})
          },
          body: json_to(body)
        });
      }
      const response = await fetch(url, r);
      if (not(response.ok)) {
        error("Failed to fetch file");
      }
      const buf = await response.arrayBuffer();
      return buf;
    }
    let v = await html_loading(lambda3);
    return v;
  }
  let sleep = true;
  let e = property_exists(options, "sleep");
  if (e) {
    sleep = property_get(options, "sleep");
  }
  if (sleep) {
    await http_sleep();
  }
  let swHttps = text_starts_with(url, "https://");
  let h_name = ternary(swHttps, "s", "");
  let h = await import("http" + h_name);
  let buffer = await promise_wrap(lambda);
  function lambda(resolve, reject) {
    const urlObj = new URL(url);
    function lambda5(res) {
      const chunks = [];
      function lambda2(chunk) {
        chunks.push(chunk);
      }
      let i = catch_call(reject, lambda2);
      res.on("data", i);
      function on_end() {
        let statusCode = property_get(res, "statusCode");
        const d = statusCode / 100;
        const rounded = round(d);
        assert_json(rounded === 2, {
          url,
          statusCode
        });
        let v2 = Buffer.concat(chunks);
        resolve(v2);
      }
      let i2 = catch_call(reject, on_end);
      res.on("end", i2);
    }
    const a = {
      hostname: urlObj.hostname,
      port: urlObj.port || (swHttps ? 443 : 80),
      path: urlObj.pathname + urlObj.search,
      method,
      headers: {
        ...options.headers || ({}),
        ...body ? {
          "Content-Type": "application/json"
        } : {}
      }
    };
    const req = h.request(a, lambda5);
    req.on("error", reject);
    if (body) {
      let json = json_to(body);
      req.write(json);
    }
    req.end();
  }
  return buffer;
}
function ternary(condition, on_true, on_false) {
  let result = null;
  if (condition) {
    result = on_true;
  } else {
    result = on_false;
  }
  return result;
}
async function sleep(ms) {
  await new Promise(function lambda5(resolve) {
    let v = setTimeout(resolve, ms);
    return v;
  });
}
function round(n) {
  let rounded = Math.round(n);
  return rounded;
}
function catch_call(reject, lambda) {
  let i = function inner() {
    let result = null;
    try {
      result = lambda(...arguments);
    } catch (e) {
      reject(e);
    }
    return result;
  };
  return i;
}
async function promise_wrap(lambda$resolve$reject) {
  let p = await new Promise(function promise_wrap_inner(resolve, reject) {
    try {
      lambda$resolve$reject(resolve, reject);
    } catch (e) {
      reject(e);
    }
  });
  return p;
}
async function http_sleep() {
  await sleep(integer_random(5, 8) * 1000);
}
function integer_random(min, max) {
  let list = [min, max];
  assert_multiple(integer_is, list);
  let r = floor(random() * (max - min + 1)) + min;
  return r;
}
function assert_multiple(fn, list) {
  function lambda(l) {
    let ii = fn(l);
    assert(ii);
  }
  each(list, lambda);
}
function each(list, lambda$item) {
  for (let item of list) {
    if (lambda$item(item) === true) {
      return;
    }
  }
}
function random() {
  let v = Math.random();
  return v;
}
function floor(p) {
  let floored = Math.floor(p);
  return floored;
}
async function firebase_bucket() {
  const admin = await firebase_admin();
  const bucket = admin.storage().bucket();
  return bucket;
}
async function firebase_admin() {
  let admin = await global_function_async(firebase_admin, firebase_admin_get);
  return admin;
}
async function global_function_async(fn, lambda) {
  let global = global_get();
  let value = property_initialize_lambda(global, fn.name, lambda);
  let awaited = await value;
  return awaited;
}
async function firebase_admin_get() {
  const admin = (await import("firebase-admin")).default;
  let service_account = await firebase_service_account();
  const sb = await firebase_storage_url_project();
  admin.initializeApp({
    credential: admin.credential.cert(service_account),
    storageBucket: sb
  });
  return admin;
}
async function firebase_storage_url_project() {
  const prefix = await firebase_name();
  let url = prefix + ".firebasestorage.app";
  return url;
}
async function firebase_service_account() {
  let f_name = await user_repo_firebase_service_account_get();
  let file_path = await function_run_unalias(f_name, []);
  let service_account = await file_read_json(file_path);
  return service_account;
}
async function function_run_unalias(f_name, args) {
  const fn = await function_import_unalias(f_name);
  const result = await fn(...args);
  return result;
}
async function function_import_unalias(f_name) {
  let v = await function_name_unalias(f_name);
  let unaliased = property_get(v, "unaliased");
  const imported_fn = await function_import(unaliased);
  return imported_fn;
}
async function function_import(f_name) {
  "if you need to unalias use " + function_import_unalias.name;
  let v2 = await function_name_to_path_search(f_name);
  let f = property_get(v2, "f_path");
  let f_path = await path_resolve(f);
  const imported = await import(`file://${f_path}`);
  const imported_fn = imported[f_name];
  if (typeof imported_fn !== "function") {
    throw new Error(`âŒ The module "${f_name}" does not export a default function.`);
  }
  return imported_fn;
}
async function path_resolve(paths) {
  let path = await import("path");
  let v = path.resolve(paths);
  return v;
}
async function function_name_to_path_search(f_name) {
  let f_path = function_name_to_path(f_name);
  async function lambda(joined) {
    let exists = await file_exists(joined);
    let v = {
      exists,
      f_path: joined
    };
    return v;
  }
  let mapped = await repos_paths_names_map_unordered_combine(f_path, lambda);
  function lambda2(m) {
    let mapped = property_get(m, "mapped");
    let exists2 = property_get(mapped, "exists");
    let ti2 = true_is(exists2);
    return ti2;
  }
  let filtered = list_filter(mapped, lambda2);
  let multiple = list_multiple_is(filtered);
  let exists = list_size_1(filtered);
  let search = {
    f_name,
    exists,
    multiple
  };
  if (exists) {
    let only = list_single(filtered);
    let mapped = property_get(only, "mapped");
    property_from(search, "f_path", mapped);
    property_from(search, "repo_name", only);
  }
  return search;
}
function property_from(to, property_name, from) {
  let value = property_get(from, property_name);
  property_set(to, property_name, value);
}
async function repos_paths_names_map_unordered_combine(path, mapper) {
  let result = await repos_paths_names_map_unordered(each_folder);
  async function each_folder(repo_name, r_path) {
    let joined = path_join([r_path, path]);
    let mapped = await mapper(joined);
    let v = {
      mapped,
      repo_name
    };
    return v;
  }
  return result;
}
async function repos_paths_names_map_unordered(lambda$name$path) {
  let all = await repos_names();
  async function lambda(repo_name) {
    let path = repo_path(repo_name);
    let mapped = await lambda$name$path(repo_name, path);
    return mapped;
  }
  let result = await list_map_unordered_async(all, lambda);
  return result;
}
async function list_map_unordered_async(list, lambda$item) {
  let mapped = list_map(list, lambda$item);
  let waited = await list_wait(mapped);
  return waited;
}
async function list_wait(list) {
  let v = await Promise.all(list);
  return v;
}
function list_map(list, lambda$item) {
  list_is_assert(list);
  let mapped = list.map(lambda$item);
  return mapped;
}
function repo_path(repo_name) {
  let previous = repos_folder();
  let r_path = path_join([previous, repo_name]);
  return r_path;
}
function repos_folder() {
  let previous = folder_previous();
  return previous;
}
function folder_previous() {
  let previous = "..";
  return previous;
}
function path_join(segments) {
  assert_arguments(arguments, 1);
  let parts = [];
  for (let seg of segments) {
    if (not(seg)) {
      continue;
    }
    let split = seg.split(/[\\/]+/);
    for (let s of split) {
      if (s === "" || s === ".") {
        continue;
      }
      if (s === folder_previous()) {
        if (parts.length > 0 && parts[parts.length - 1] !== folder_previous()) {
          parts.pop();
        } else {
          let previous = folder_previous();
          parts.push(previous);
        }
      } else {
        parts.push(s);
      }
    }
  }
  let joined = parts.join("/");
  return joined;
}
async function repos_names() {
  let path_folder = repos_folder();
  let rns = await folder_read(path_folder);
  let v = folder_vscode();
  let ignores = [v];
  function lambda(r) {
    let n = list_includes_not(ignores, r);
    return n;
  }
  let f = list_filter(rns, lambda);
  return f;
}
function folder_vscode() {
  let vc = ".vscode";
  return vc;
}
async function folder_read(path_folder) {
  if (browser_is()) {
    let v = await folder_read_browser(path_folder);
    let unique = property_get(v, "unique");
    return unique;
  }
  let fs = await import("fs");
  const all = await fs.promises.readdir(path_folder);
  return all;
}
async function folder_read_browser(path_folder) {
  let files_paths = await app_a_files_paths();
  let r = global_function_property_cache(folder_read_browser, path_folder, files_paths, value_get);
  return r;
  function value_get() {
    let n = path_normalize(path_folder);
    let s = text_slash_forward();
    let prefix = "" + n + s;
    let filtered = list_filter_starts_with(files_paths, prefix);
    let mapped = list_map_prefix_without(filtered, prefix);
    function lambda(item) {
      let first = text_split_first(item, s);
      return first;
    }
    let mapped2 = list_map(mapped, lambda);
    let unique = list_unique(mapped2);
    let r = {
      unique,
      prefix,
      filtered
    };
    return r;
  }
}
function global_function_property_cache(fn, property_name, key, value_get) {
  let c = global_function_property_initialize(fn, property_name, {
    json: null,
    result: null
  });
  let result = global_function_cache_generic(key, c, value_get);
  return result;
}
function global_function_cache_generic(key, c, value_get) {
  let json = json_to(key);
  let json_existing = property_get(c, "json");
  if (equal_not(json, json_existing)) {
    let r = value_get();
    property_set(c, "result", r);
    property_set(c, "json", json);
  }
  let result = property_get(c, "result");
  return result;
}
function equal_not(left, right) {
  let a = equal(left, right);
  let ne = not(a);
  return ne;
}
function global_function_property_initialize(fn, property_name, value_initial) {
  let global = global_get();
  let fn_object = property_initialize(global, fn.name, {});
  let value = property_initialize(fn_object, property_name, value_initial);
  return value;
}
function property_initialize(object, property_name, value_initial) {
  const exists = property_exists(object, property_name);
  if (not(exists)) {
    property_set(object, property_name, value_initial);
  }
  let value = property_get(object, property_name);
  return value;
}
function list_unique(list) {
  let found = list_unique_set(list);
  let unique = [...found];
  return unique;
}
function list_unique_set(list) {
  let set = set_new();
  function lambda(item) {
    set_add(set, item);
  }
  each(list, lambda);
  return set;
}
function set_add(found, item) {
  found.add(item);
}
function add(left, right) {
  const sum = left + right;
  return sum;
}
function set_new() {
  let v = new Set();
  return v;
}
function text_split_first(item, s) {
  let index = text_index_of_try(item, s);
  if (index < 0) {
    return item;
  }
  let taken = text_take(item, index);
  return taken;
}
function text_index_of_try(t, item) {
  let v = t.indexOf(item);
  return v;
}
function list_map_prefix_without(list, prefix) {
  function lambda(item) {
    let result = text_prefix_without(item, prefix);
    return result;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function text_prefix_without(s, prefix) {
  let a = text_starts_with(s, prefix);
  function lambda() {
    let r = {
      s,
      prefix
    };
    return r;
  }
  assert_json_get(a, lambda);
  if (not(a)) {
    error();
  }
  let without = text_prefix_without_inner(s, prefix);
  return without;
}
function text_prefix_without_inner(s, prefix) {
  let skipped = text_size(prefix);
  let without = text_skip(s, skipped);
  return without;
}
function text_skip(s, skip_count) {
  let b = text_size(s);
  const skipped = text_slice(s, skip_count, b);
  return skipped;
}
function text_size(s) {
  let size = s.length;
  return size;
}
function list_filter_starts_with(list, prefix) {
  function lambda(item) {
    let sw = text_starts_with(item, prefix);
    return sw;
  }
  let filtered = list_filter(list, lambda);
  return filtered;
}
async function app_a_files_paths() {
  let store = app_a_file_system_store();
  let all = await indexeddb_get_all(app_a_indexeddb_initialize, store);
  let filtered = list_filter_property_exclude_if_exists(all, "deleted", true);
  let property_name = app_a_indexeddb_path_key();
  let files_paths = list_map_property(filtered, property_name);
  return files_paths;
}
function list_filter_property_exclude_if_exists(list, property_name, value) {
  function lambda(item) {
    let exists = property_exists(item, property_name);
    if (exists) {
      let ne = property_get(item, property_name) !== value;
      return ne;
    }
    let v2 = true;
    return v2;
  }
  let filtered = list_filter(list, lambda);
  return filtered;
}
function list_map_property(list, property_name) {
  let r = property_get_curried_right(property_name);
  let mapped = list_map(list, r);
  return mapped;
}
function property_get_curried_right(property_name) {
  let r = function property_get_curried_right_result(object) {
    let value = property_get(object, property_name);
    return value;
  };
  return r;
}
async function indexeddb_get_all(db_get, store) {
  let exists = global_function_property_exists(indexeddb_get_all, store);
  if (not(exists)) {
    let all = await indexeddb_get_all_backend(db_get, store);
    global_function_property_set(indexeddb_get_all, store, all);
  }
  let list = global_function_property_get(indexeddb_get_all, store);
  return list;
}
async function indexeddb_get_all_backend(db_get, store) {
  const db = await db_get();
  const tx = db.transaction(store, "readonly");
  const s = tx.objectStore(store);
  let all = await new Promise(function lambda3(resolve, reject) {
    const req = s.getAll();
    req.onsuccess = function lambda() {
      let v = resolve(req.result);
      return v;
    };
    req.onerror = function lambda2() {
      let v2 = reject(req.error);
      return v2;
    };
  });
  return all;
}
function app_a_file_system_store() {
  let v = "files";
  return v;
}
function text_slash_forward() {
  let s = "/";
  return s;
}
function list_includes_not(list, item) {
  let b = list_includes(list, item);
  let n = not(b);
  return n;
}
function list_includes(list, item) {
  const includes = list.includes(item);
  return includes;
}
function list_size_1(list) {
  const s1 = list_size(list) === 1;
  return s1;
}
function list_multiple_is(list) {
  let m = list_size(list) >= 2;
  return m;
}
function true_is(value) {
  let ti = equal(value, true);
  return ti;
}
async function file_exists(file_path) {
  if (browser_is()) {
    file_path = file_path_normalize(file_path);
    await app_a_file_system_initialize();
    let store = app_a_file_system_store();
    let exists = await indexeddb_exists(app_a_indexeddb_initialize, store, file_path);
    return exists;
  }
  if (promise_is(file_path)) {
    error();
  }
  let fs = await import("fs");
  let v = fs.promises;
  let access = property_get(v, "access");
  let constants = property_get(fs, "constants");
  let exists = await throws_not_async(lambda);
  async function lambda() {
    await access(file_path, constants.F_OK);
  }
  return exists;
}
async function indexeddb_exists(db_get, store, key) {
  const property = "key";
  let all = await indexeddb_get_all(db_get, store);
  list_property_exists_not_error(all, property);
  let s1 = list_find_property_exists(all, property, key);
  return s1;
  let exists = await indexeddb_exists_backend(db_get, store, key);
  return exists;
}
function list_property_exists_not_error(all, property) {
  function lambda(item, index) {
    let n = property_exists_not(item, property);
    if (n) {
      error({
        index
      });
    }
  }
  each_index(all, lambda);
}
function each_index(list, lambda$item$index) {
  let index = 0;
  function lambda_each_index(item) {
    lambda$item$index(item, index);
    index++;
  }
  each(list, lambda_each_index);
}
function property_exists_not(object, property_name) {
  let e = property_exists(object, property_name);
  let ne = not(e);
  return ne;
}
async function indexeddb_exists_backend(db_get, store, key) {
  const db = await db_get();
  const tx = db.transaction(store, "readonly");
  const s = tx.objectStore(store);
  const exists = await new Promise(function lambda3(resolve, reject) {
    const req = s.count(key);
    req.onsuccess = function lambda() {
      let v = resolve(req.result > 0);
      return v;
    };
    req.onerror = function lambda2() {
      let v2 = reject(req.error);
      return v2;
    };
  });
  return exists;
}
function list_find_property_exists(list, property, value) {
  let f = list_filter_property(list, property, value);
  let s1 = list_size_1(f);
  return s1;
}
function list_filter_property(list, property_name, property_value) {
  let filter = property_equals_lambda(property_name, property_value);
  let filtered = list_filter(list, filter);
  return filtered;
}
async function app_a_file_system_initialize() {
  let value = storage_local_exists(app_a, app_a_file_system_initialize.name);
  if (value) {
    return;
  }
  async function lambda2() {
    await app_a_file_system_initialize_download();
    let v = true;
    return v;
  }
  let value2 = await global_function_initialize_lambda_async(app_a_file_system_initialize, lambda2);
}
async function app_a_file_system_initialize_download() {
  let db = await app_a_indexeddb_initialize();
  let db_get = lambda_get(db);
  let r = await app_api_fn({
    fn: app_a_download
  });
  list_property_exists_not_error(r, "key");
  let dictionary = list_to_dictionary_property(r, "key");
  let store = app_a_file_system_store();
  await indexeddb_put_multiple(db_get, store, dictionary);
  storage_local_set(app_a, app_a_file_system_initialize.name, true);
  let all = await indexeddb_get_all(db_get, store);
  list_property_exists_not_error(all, "key");
}
async function app_api_fn(a) {
  let fn = property_get(a, "fn");
  let f_name = fn.name;
  property_set_exists_not(a, "f_name", f_name);
  let r = await app_api(a);
  return r;
}
async function app_api(a) {
  assert_arguments(arguments, 1);
  let f_name = property_get(a, "f_name");
  text_is_assert(f_name);
  let fn_http = http_post_json;
  property_set_exists_not(a, "fn_http", fn_http);
  let result = await app_api_generic(a);
  return result;
}
function property_set_exists_not(object, property_name, value) {
  property_exists_not_assert(object, property_name);
  property_set(object, property_name, value);
}
function property_exists_not_assert(object, property_name) {
  let e = property_exists(object, property_name);
  if (e) {
    let value = property_get(object, property_name);
    log_keep(property_name);
    error_json({
      object,
      property_name,
      value
    });
  }
}
function text_is_assert(value) {
  let b = text_is(value);
  assert(b);
}
function text_is(value) {
  let ti = typeof value === "string";
  return ti;
}
async function app_api_generic(a) {
  assert_arguments(arguments, 1);
  let f_name = property_get(a, "f_name");
  let args = property_initialize(a, "args", []);
  let fn_http = property_get(a, "fn_http");
  var v = app_api_generic_url_body(f_name, args);
  let body = property_get(v, "body");
  let url = property_get(v, "url");
  let o = await fn_http(url, body);
  let result = property_get(o, "result");
  return result;
}
function app_api_generic_url_body(f_name, args) {
  let body = app_api_generic_f_name_args(f_name, args);
  let url = server_url_get();
  let v = {
    url,
    body
  };
  return v;
}
function server_url_get() {
  let url = null;
  url = ternary(browser_is(), "", server_url());
  url += server_url_api();
  return url;
}
function server_url_api() {
  let a = "/api";
  return a;
}
function server_url() {
  const port = server_port();
  let url = "http://localhost:" + port;
  return url;
}
function server_port() {
  let v4 = 8080;
  return v4;
}
function app_api_generic_f_name_args(f_name, args) {
  let args_list = list_to(args);
  let v2 = {
    f_name: f_name,
    args: args_list
  };
  return v2;
}
function list_to(a) {
  let l = Array.from(a);
  return l;
}
async function http_post_json(url, body) {
  let buffer = await http_post(url, body);
  let o = buffer_to_json(buffer);
  return o;
}
async function http_post(url, body) {
  const options_extra = {};
  let v = await http_post_options(url, body, options_extra);
  return v;
}
async function http_post_options(url, body, options_extra) {
  const options = {
    method: "POST",
    body: body
  };
  object_merge(options, options_extra);
  let v = await http_generic(url, options);
  return v;
}
function object_merge(to, from) {
  let strict = true;
  object_merge_generic(strict, to, from);
  return to;
}
function object_merge_generic(strict, to, from) {
  function lambda(property_name) {
    if (strict) {
      if (property_exists(to, property_name)) {
        error_json({
          to,
          from,
          property_name
        });
      }
    }
    let value = property_get(from, property_name);
    property_set(to, property_name, value);
  }
  let list = properties_get(from);
  each(list, lambda);
}
function properties_get(obj) {
  const properties = Object.getOwnPropertyNames(obj);
  return properties;
}
function buffer_to_json(buffer) {
  let text = buffer_text_to(buffer);
  let parsed = json_from(text);
  return parsed;
}
function list_to_dictionary_property(list, property) {
  function key_get(item) {
    let key = property_get(item, property);
    return key;
  }
  let dictionary = list_to_dictionary_key(list, key_get);
  return dictionary;
}
function list_to_dictionary_key(list, lambda$item) {
  let value_get = identity;
  let dictionary = list_to_dictionary(list, value_get, lambda$item);
  return dictionary;
}
function list_to_dictionary(list, lambda$item2v, lambda$item2k) {
  "if each key has one value, then " + list_to_dictionary.name + " but if each key corresponds to a list of values, then " + list_to_lookup.name;
  let dictionary = {};
  function lambda(item) {
    let key = lambda$item2k(item);
    let value = lambda$item2v(item);
    property_set_exists_not(dictionary, key, value);
  }
  each(list, lambda);
  return dictionary;
}
function list_to_lookup(list, property_key) {
  "if each key has one value, then " + list_to_dictionary.name + " but if each key corresponds to a list of values, then " + list_to_lookup.name;
  let lookup = {};
  function lambda(item) {
    let n = property_exists_not(item, property_key);
    if (n) {
      return;
    }
    let value = property_get(item, property_key);
    let key_list = property_initialize_list(lookup, value);
    list_add(key_list, item);
  }
  each(list, lambda);
  return lookup;
}
function list_add(list, item) {
  list.push(item);
}
function property_initialize_list(object, property_name) {
  let value2 = property_initialize(object, property_name, []);
  return value2;
}
function identity(a) {
  return a;
}
async function indexeddb_put_multiple(db_get, store, lookup) {
  'at time of writing, indexeddb code only uses key value of "key" therefore this function could be made general to receive key name as param';
  let key = "key";
  let v = object_values(lookup);
  let keys = list_map_property(v, key);
  let existing = await indexeddb_get_all(db_get, store);
  function lambda(item) {
    let k = property_get(item, key);
    let includes = list_includes(keys, k);
    return includes;
  }
  let filtered = list_filter(existing, lambda);
  list_remove_multiple(existing, filtered);
  list_add_multiple(existing, v);
  async function lambda_async() {
    await indexeddb_put_multiple_backend(db_get, store, lookup);
  }
  indexeddb_next(lambda_async);
}
function list_add_multiple(list, items) {
  list.push(...items);
}
function list_remove_multiple(list, removals) {
  function lambda(r) {
    list_remove(list, r);
  }
  each(removals, lambda);
}
function list_remove(list, item) {
  const index = list_index_of(list, item);
  list_remove_at(list, index);
}
function list_remove_at(list, index) {
  let e = list_remove_at_count(list, index, 1);
  let only = list_single(e);
  return only;
}
function list_remove_at_count(list, index, count) {
  let e = list.splice(index, count);
  return e;
}
function list_index_of(list, item) {
  let index = list.indexOf(item);
  if (index <= -1) {
    error_json({
      list,
      item,
      index
    });
  }
  return index;
}
function object_values(o) {
  let v = Object.values(o);
  return v;
}
async function indexeddb_put_multiple_backend(db_get, store, nexts) {
  const tx = await db_get().transaction(store, "readwrite");
  const s = tx.objectStore(store);
  function lambda2(n) {
    s.put(n);
  }
  each_object_values(nexts, lambda2);
  await new Promise(function lambda6(resolve, reject) {
    tx.oncomplete = resolve;
    tx.onerror = function lambda4() {
      let v3 = reject(tx.error);
      return v3;
    };
    tx.onabort = function lambda5() {
      let v4 = reject(tx.error);
      return v4;
    };
  });
}
function each_object_values(object, lambda$item) {
  function lambda(value, property) {
    lambda$item(value);
  }
  each_object(object, lambda);
}
function each_object(object, lambda$value$property) {
  function lambda2(property) {
    let value = property_get(object, property);
    lambda$value$property(value, property);
  }
  let properties = properties_get(object);
  each(properties, lambda2);
}
function indexeddb_next(lambda_async) {
  let initial = promise_resolved();
  let previous = global_function_initialize(indexeddb_next, initial);
  let promise = invoke(lambda_async);
  previous = previous.then(promise);
  global_function_set(indexeddb_next, previous);
}
function invoke(lambda) {
  let r = lambda();
  return r;
}
function promise_resolved() {
  let v = Promise.resolve(null);
  return v;
}
async function app_a_download() {
  let filtered = await app_a_download_paths();
  async function lambda2(path) {
    let contents = await file_read(path);
    let data = {
      versions: [contents]
    };
    let c = await json_compress_object(data);
    object_merge(c, {
      key: path
    });
    return c;
  }
  let files = await list_map_unordered_async(filtered, lambda2);
  list_property_exists_not_error(files, "key");
  return files;
}
async function json_compress_object(data) {
  let compressed = await json_compress(data);
  let c = {
    compressed
  };
  return c;
}
async function json_compress(data) {
  let json = json_to(data);
  let compressed = await text_compress(json);
  return compressed;
}
async function text_compress(text) {
  const LZString = (await import("lz-string")).default;
  let v = LZString.compressToUTF16(text);
  return v;
}
async function app_a_download_paths() {
  let path_folder = repos_folder();
  let combineds = await folder_read_recursive_skipped_paths_async(path_folder, ["node_modules", ".git"]);
  let ext_f = function_name_extension();
  let ext_h = html_extension();
  let ext_j = json_extension();
  let filtered = list_filter_ends_with_any(combineds, [ext_f, ext_h, ext_j]);
  return filtered;
}
async function folder_read_recursive_skipped_paths_async(path_folder, folders_skipped) {
  let result = await folder_read_recursive_skipped_async(path_folder, folders_skipped);
  let mapped = folder_read_recursive_paths_to(result, path_folder);
  return mapped;
}
function folder_read_recursive_paths_to(result, path_folder) {
  let combineds = list_map_path_join_left(result, path_folder);
  let mapped = list_map(combineds, path_normalize);
  return mapped;
}
function list_map_path_join_left(list, folder_prefix) {
  function lambda(item) {
    let joined = path_join([folder_prefix, item]);
    return joined;
  }
  let mapped2 = list_map(list, lambda);
  return mapped2;
}
async function folder_read_recursive_skipped_async(path_folder, folders_skipped) {
  const fs = await import("fs/promises");
  const path = await import("path");
  let result = [];
  const entries = await fs.readdir(path_folder, {
    withFileTypes: true
  });
  for (const entry of entries) {
    let name = property_get(entry, "name");
    if (entry.isFile()) {
      result.push(name);
    } else if (entry.isDirectory()) {
      let n = list_includes_not(folders_skipped, name);
      if (n) {
        const fullPath = path.join(path_folder, name);
        const subFiles = await folder_read_recursive_skipped_async(fullPath, folders_skipped);
        function lambda(f) {
          let v = path.join(name, f);
          return v;
        }
        result.push(...subFiles.map(lambda));
      }
    }
  }
  return result;
}
function list_filter_ends_with_any(list, suffixes) {
  function lambda(item) {
    function lambda3(suffix) {
      let ew = text_ends_with(item, suffix);
      return ew;
    }
    let any = list_any(suffixes, lambda3);
    return any;
  }
  let filtered = list_filter(list, lambda);
  return filtered;
}
function list_any(list, lambda$item) {
  let filtered = list_filter(list, lambda$item);
  let any = list_empty_not_is(filtered);
  return any;
}
function text_ends_with(s, suffix) {
  const ew = s.endsWith(suffix);
  return ew;
}
function html_extension() {
  let ext_h = ".html";
  return ext_h;
}
function function_name_extension() {
  const ext = ".mjs";
  return ext;
}
async function global_function_initialize_lambda_async(fn, lambda) {
  assert_arguments(arguments, 2);
  let global = global_get();
  let value = await property_initialize_lambda_async(global, fn.name, lambda);
  return value;
}
async function property_initialize_lambda_async(object, property_name, lambda) {
  const exists = property_exists(object, property_name);
  if (not(exists)) {
    let value_set = lambda();
    property_set(object, property_name, value_set);
  }
  let value = await property_get(object, property_name);
  return value;
}
function storage_local_exists(app_fn, key) {
  let storage_local_key = storage_local_key_get(app_fn, key);
  if (storage_local_enabled()) {
    let json = storage_local_specify_get_json(storage_local_key);
    let v = json !== null;
    return v;
  }
  let exists = storage_local_exists_global(storage_local_key);
  return exists;
}
async function throws_not_async(lambda) {
  let success = null;
  try {
    await lambda();
    success = true;
  } catch (e) {
    success = false;
  }
  return success;
}
function promise_is(value) {
  let v = value !== null && typeof value === "object" && typeof value.then === "function" && typeof value.catch === "function";
  return v;
}
function function_name_to_path(f_name) {
  if (text_includes(f_name, ".")) {
    error_json({
      f_name
    });
  }
  let folder = functions_path();
  let f_path = function_name_folder_to_path(f_name, folder);
  return f_path;
}
function function_name_folder_to_path(f_name, folder) {
  let base = function_name_to_base(f_name);
  let second = [folder, base];
  let joined = path_join(second);
  return joined;
}
function function_name_to_base(f_name) {
  let f_name_ext = f_name + function_name_extension();
  return f_name_ext;
}
function text_includes(input, part) {
  const o = {
    input,
    part
  };
  text_is_assert_json(input, o);
  text_is_assert_json(part, o);
  let i = input.includes(part);
  return i;
}
function text_is_assert_json(value, o) {
  let message = json_to(o);
  text_is_assert_message(value, message);
}
function text_is_assert_message(value, message) {
  let b = text_is(value);
  let v = assert_message(b, message);
  return v;
}
function functions_path() {
  const second = folder_src();
  let joined = folder_public_combine(second);
  return joined;
}
function folder_src() {
  let src = "src";
  return src;
}
function folder_public_combine(f_path) {
  let result = folder_public();
  let combined = path_join([result, f_path]);
  return combined;
}
function folder_public() {
  let v = "public";
  return v;
}
async function function_name_unalias(f_name) {
  assert_arguments(arguments, 1);
  var v2 = await function_alias_add_generic(f_name);
  let unaliased_actual = property_get(v2, "unaliased");
  let exists = property_get(v2, "exists");
  let v3 = await function_acronym_to_name(f_name);
  let expandeds = property_get(v3, "expandeds");
  let expanded = property_get(v3, "expanded");
  const unaliased = exists ? unaliased_actual : expanded !== null ? expanded : f_name;
  let v = {
    unaliased,
    expandeds
  };
  return v;
}
async function function_acronym_to_name(alias) {
  let expanded = null;
  let expandeds = null;
  let acronyms = await function_names_to_acronyms();
  const exists2 = property_exists(acronyms, alias);
  if (exists2) {
    expandeds = property_get(acronyms, alias);
    let s1 = list_size_1(expandeds);
    if (s1) {
      expanded = list_single(expandeds);
    }
  }
  let v = {
    expanded,
    expandeds
  };
  return v;
}
async function function_names_to_acronyms() {
  let f_names = await functions_names();
  let result = global_function_cache(function_names_to_acronyms, f_names, value_get);
  return result;
  function value_get() {
    let dictionary = list_to_dictionary_value(f_names, function_name_to_acronym);
    let acronyms = object_invert(dictionary);
    return acronyms;
  }
}
function global_function_cache(fn, key, value_get) {
  let c = global_function_initialize(fn, {
    json: null,
    result: null
  });
  let result = global_function_cache_generic(key, c, value_get);
  return result;
}
function object_invert(object) {
  let inverted = {};
  function lambda(value, key) {
    undefined_not_is_assert(value);
    let list = property_initialize(inverted, value, []);
    list_add(list, key);
  }
  each_object(object, lambda);
  return inverted;
}
function undefined_not_is_assert(value) {
  function lambda2() {
    let v2 = {};
    return v2;
  }
  undefined_not_is_assert_lambda(value, lambda2);
}
function function_name_to_acronym(f_name) {
  let parts = function_name_to_parts(f_name);
  let letters = null;
  try {
    letters = list_map(parts, list_first);
  } catch (e) {
    "if this error, then maybe string empty, __ instead of _ or ends with _";
    error_json({
      e,
      f_name
    });
  }
  let acronym = list_join_empty(letters);
  return acronym;
}
function list_join_empty(list) {
  const e = text_empty();
  let joined = list_join(list, e);
  return joined;
}
function text_empty() {
  let v = "";
  return v;
}
function function_name_to_parts(f_name) {
  let separator = function_name_separator();
  let parts = text_split(f_name, separator);
  return parts;
}
function text_split(s, separator) {
  const split = s.split(separator);
  return split;
}
function list_to_dictionary_value(list, lambda$item) {
  let key_get = identity;
  let dictionary = list_to_dictionary(list, lambda$item, key_get);
  return dictionary;
}
async function functions_names() {
  let f_names = await repos_paths_map_unordered_combine_squash(mapper);
  async function mapper(joined) {
    let f_names = await functions_names_from_path(joined);
    return f_names;
  }
  return f_names;
}
async function repos_paths_map_unordered_combine_squash(mapper) {
  let path = functions_path();
  let result = await repos_paths_map_unordered_combine(path, mapper);
  let squashed = list_squash(result);
  return squashed;
}
function list_squash(lists) {
  function lambda2(la) {
    list_process(lists);
    function list_process(list) {
      function lambda(item) {
        let l = list_is(item);
        let fn = null;
        fn = ternary(l, list_process, la);
        fn(item);
      }
      each(list, lambda);
    }
  }
  let squashed = list_adder(lambda2);
  return squashed;
}
function list_adder(lambda$la) {
  let fn = list_add;
  let list = list_adder_generic(lambda$la, fn);
  return list;
}
function list_adder_generic(lambda, fn) {
  let list = [];
  function list_adder_inner(item) {
    fn(list, item);
  }
  lambda(list_adder_inner);
  return list;
}
async function repos_paths_map_unordered_combine(path, mapper) {
  let result = await repos_paths_map_unordered(each_folder);
  async function each_folder(folder) {
    let joined = path_join([folder, path]);
    let f_names = mapper(joined);
    return f_names;
  }
  return result;
}
async function repos_paths_map_unordered(lambda$folder) {
  let all = await repos_names();
  async function lambda(repo_name) {
    let folder = repo_path(repo_name);
    let mapped = await lambda$folder(folder);
    return mapped;
  }
  let result = await list_map_unordered_async(all, lambda);
  return result;
}
async function functions_names_from_path(path) {
  let paths = await folder_read_files(path);
  function lambda(p) {
    let suffix = function_name_extension();
    let without = text_suffix_without(p, suffix);
    return without;
  }
  let f_names = list_map(paths, lambda);
  return f_names;
}
function text_suffix_without(t, suffix) {
  let a = text_ends_with(t, suffix);
  if (not(a)) {
    error();
  }
  const missing = text_size(suffix);
  const without = string_skip_end(t, missing);
  return without;
}
function string_skip_end(s, missing_count) {
  const from = text_size(s) - missing_count;
  const without = text_slice_0(s, from);
  return without;
}
function text_slice_0(s, from) {
  let sliced = text_slice(s, 0, from);
  return sliced;
}
async function folder_read_files(path_folder) {
  if (browser_is()) {
    path_folder = file_path_normalize(path_folder);
    let r = await folder_read_browser(path_folder);
    let filtered = property_get(r, "filtered");
    let prefix = property_get(r, "prefix");
    let unique = property_get(r, "unique");
    let combineds = list_map_combine_left(unique, prefix);
    let r2 = list_intersect(filtered, combineds);
    let r3 = list_map(r2, path_base);
    return r3;
  }
  let fs = await import("fs");
  function lambda(file) {
    let result = path_join([path_folder, file]);
    let v = fs.statSync(result).isFile();
    return v;
  }
  const all = fs.readdirSync(path_folder);
  let files = all.filter(lambda);
  list_sort_text(files);
  return files;
}
function path_base(file_path) {
  const parts = file_path.split(/[/\\]/);
  const filename = parts.pop();
  return filename;
}
function list_intersect(list, other) {
  let r = list_intersect_multiple([list, other]);
  return r;
}
function list_intersect_multiple(list) {
  let fr = list_first_remaining(list);
  let first = property_get(fr, "first");
  let remaining = property_get(fr, "remaining");
  let e = null_is(remaining);
  if (e) {
    let copy = list_copy(first);
    return copy;
  }
  let uniques = list_map(remaining, list_unique_set);
  function lambda2(la) {
    function lambda(l) {
      function lambda3(set) {
        let v = set_includes(set, l);
        return v;
      }
      let a = list_all(uniques, lambda3);
      if (a) {
        la(l);
      }
    }
    each(first, lambda);
  }
  let i = list_adder(lambda2);
  return i;
}
function list_copy(original) {
  const copy = [...original];
  return copy;
}
function list_all(list, lambda$item) {
  let list2 = list_filter(list, lambda$item);
  let a = list_size(list2) === list_size(list);
  return a;
}
function list_first_remaining(list) {
  const property_name = "remaining";
  let value_get = list_skip_1;
  let r = list_first_second_generic(list, value_get, property_name);
  return r;
}
function list_first_second_generic(list, other_get, property_name_second) {
  let property_name_first = "first";
  let one_get = list_first;
  let result = list_one_other(list, one_get, other_get, property_name_first, property_name_second);
  return result;
}
function list_one_other(list, one_get, other_get, property_name_one, property_name_other) {
  let one = null;
  let other = null;
  if (list_empty_not_is(list)) {
    one = one_get(list);
    if (list_multiple_is(list)) {
      other = other_get(list);
    }
  }
  let result = {
    [property_name_one]: one,
    [property_name_other]: other
  };
  return result;
}
function list_skip_1(list) {
  let skipped = list_skip(list, 1);
  return skipped;
}
function list_skip(list, skip_count) {
  let b = list_size(list);
  const skipped = list_slice(list, skip_count, b);
  return skipped;
}
function list_slice(list, index_a, index_b) {
  let sliced = list.slice(index_a, index_b);
  return sliced;
}
function set_includes(set, item) {
  let si = set.has(item);
  return si;
}
function list_map_combine_left(list, left) {
  function lambda(right) {
    let combined = left + right;
    return combined;
  }
  let combineds = list_map(list, lambda);
  return combineds;
}
function list_sort_text(list) {
  list_sort_text_mapper(list, identity);
}
function list_sort_text_mapper(list, lambda$item) {
  function lambda(a, b) {
    const va = lambda$item(a);
    const vb = lambda$item(b);
    const [na, ia] = va.split(/[_\.]/);
    const [nb, ib] = vb.split(/[_\.]/);
    let v = na.localeCompare(nb) || Number(ia) - Number(ib);
    return v;
  }
  list.sort(lambda);
}
async function function_alias_add_generic(alias) {
  let unaliased = null;
  let d_path = data_aliases_path();
  var {value: aliases, file_path, data} = await data_get("aliases", {}, d_path);
  const exists = property_exists(aliases, alias);
  if (exists) {
    unaliased = property_get(aliases, alias);
  }
  let v = {
    exists,
    aliases,
    file_path,
    data,
    unaliased
  };
  return v;
}
async function data_get(property_name, value_initial, d_path) {
  var d = await data_all(d_path);
  let file_path = property_get(d, "file_path");
  let data = property_get(d, "data");
  let value = property_initialize(data, property_name, value_initial);
  let r = {
    value,
    file_path,
    data
  };
  return r;
}
async function data_all(file_path) {
  let data = {};
  let d_path = data_path();
  if (equal(file_path, d_path)) {
    await data_generate(data);
  } else {
    await data_all_initialize(file_path);
    data = await file_read_json(file_path);
  }
  let v = {
    data,
    file_path
  };
  return v;
}
async function data_generate(data) {
  let f_paths = await functions_paths();
  let parseds = await list_map_unordered_async(f_paths, file_js_parse);
  let lambda = data_file_update_inner_curried_right(data);
  each(parseds, lambda);
  return;
}
function data_file_update_inner_curried_right(data) {
  let r2 = function data_file_update_inner_curried_right_result(parsed) {
    let r = data_file_update_inner(parsed, data);
    return r;
  };
  return r2;
}
function data_file_update_inner(parsed, data) {
  let f_path = property_get(parsed, "f_path");
  let f_name = function_path_to_name(f_path);
  let ast = property_get(parsed, "ast");
  let functions = property_initialize(data, "functions", {});
  let f_this = property_initialize(functions, f_name, {});
  let declaration = js_flo(ast);
  let async_is = property_get(declaration, "async");
  property_set(f_this, "async", async_is);
  function data_add(property_name, items) {
    let items_to_functions = property_initialize(data, property_name, {});
    function identifier_add(i_name) {
      let list = property_initialize(items_to_functions, i_name, []);
      list_add_if_not_includes(list, f_name);
    }
    each(items, identifier_add);
    let items_old = property_initialize(f_this, property_name, []);
    let removals = list_difference(items_old, items);
    function lambda(item) {
      let list = property_initialize(items_to_functions, item, []);
      list_remove_all(list, f_name);
      let e = list_empty_is(list);
      if (e) {
        property_delete(items_to_functions, item);
      }
      each(removals, lambda);
    }
    property_set(f_this, property_name, items);
  }
  let f_identifiers_new = js_identifiers_names(ast);
  data_add("identifiers", f_identifiers_new);
  let strings_new = js_strings(ast);
  data_add("strings", strings_new);
  function lambda2(la) {
    js_visit_calls_named(ast, fn_name.name, lambda4);
    function lambda4({args}) {
      let first = list_first(args);
      function lambda3() {
        let v = {
          msg: fn_name.name + " first argument should be a literal: " + f_name
        };
        return v;
      }
      js_literal_is_assert(first, lambda3);
      let value = property_get(first, "value");
      la(value);
    }
  }
  let identifiers_fn_names = list_adder(lambda2);
  data_add("identifiers_fn_names", identifiers_fn_names);
}
function js_strings(ast) {
  function lambda2(la) {
    function lambda(v) {
      let node = property_get(v, "node");
      let value = null;
      function lambda5() {
        let quasis = property_get(node, "quasis");
        let s1 = list_size_1(quasis);
        if (s1) {
          let expressions = property_get(node, "expressions");
          let e = list_empty_is(expressions);
          if (e) {
            let q = list_first(quasis);
            let v2 = property_get(q, "value");
            value = property_get(v2, "raw");
          }
        }
      }
      js_node_type_is_if(node, "TemplateLiteral", lambda5);
      function lambda4() {
        value = property_get(node, "value");
      }
      js_node_type_is_if(node, "Literal", lambda4);
      let si2 = text_is(value);
      if (si2) {
        la(value);
      }
    }
    js_visit_types(ast, ["Literal", "TemplateLiteral"], lambda);
  }
  const names = list_adder_unique(lambda2);
  return names;
}
function js_node_type_is_if(node, type, lambda) {
  let type_is = js_node_type_is(node, type);
  if (type_is) {
    lambda();
  }
}
function js_node_type_is(node, type) {
  const type_is = js_node_is(node) && js_node_type(node) === type;
  return type_is;
}
function js_node_is(n) {
  const ni = property_exists(n, "type");
  return ni;
}
function js_node_type(n) {
  const nt = property_get(n, "type");
  return nt;
}
function list_adder_unique(lambda$la) {
  let items = list_adder(lambda$la);
  let unique = list_unique(items);
  return unique;
}
function js_visit_types(ast, types, lambda$v) {
  function lambda(v) {
    let node = property_get(v, "node");
    if (js_node_is(node) && js_node_types_is(node, types)) {
      lambda$v(v);
    }
  }
  js_visit(ast, lambda);
}
function js_node_types_is(item, types) {
  function lambda2(type) {
    let type_is = js_node_type_is(item, type);
    return type_is;
  }
  const match = list_any(types, lambda2);
  return match;
}
function js_visit(ast, lambda$v) {
  let a = promise_not_is(ast);
  if (not(a)) {
    error();
  }
  visit_filter(ast, js_visit_children_get, js_visit_filter, lambda$v);
}
function promise_not_is(ast) {
  let a = promise_is(ast);
  let n = not(a);
  return n;
}
function visit_filter(node, children_get, filter, on_each) {
  visit_filter_recursive(node, children_get, filter, on_each, []);
}
function visit_filter_recursive(node, children_get, filter, on_each, stack) {
  let a = filter(node);
  if (not(a)) {
    return;
  }
  list_add(stack, node);
  let children = children_get(node);
  function lambda(c) {
    visit_filter_recursive(c, children_get, filter, on_each, stack);
  }
  each(children, lambda);
  let copy = list_copy(stack);
  on_each({
    node,
    stack: copy
  });
  let removed = list_pop(stack);
  if (removed !== node) {
    error();
  }
}
function list_pop(list) {
  let popped = list.pop();
  return popped;
}
function js_visit_children_get(n) {
  if (list_is(n)) {
    return n;
  }
  if (text_is(n)) {
    let v = [];
    return v;
  }
  function lambda(p) {
    let value = property_get(n, p);
    return value;
  }
  let list = properties_get(n);
  let mapped = list_map(list, lambda);
  return mapped;
}
function js_visit_filter(n) {
  let v = js_node_is(n) || list_is(n);
  return v;
}
function js_literal_is_assert(node) {
  let li = js_literal_is(node);
  assert(li);
}
function js_literal_is(node) {
  let li = js_node_type_is(node, "Literal");
  return li;
}
function js_visit_calls_named(ast, f_name, lambda) {
  function lambda_inner(v) {
    let node = property_get(v, "node");
    let name = js_call_callee_name(node);
    if (equal_not(name, f_name)) {
      return;
    }
    let args = property_get(node, "arguments");
    lambda({
      v,
      args
    });
  }
  js_visit_calls(ast, lambda_inner);
}
function js_visit_calls(ast, lambda_inner) {
  js_visit_type(ast, "CallExpression", lambda_inner);
}
function js_visit_type(ast, type, lambda$v) {
  js_visit_types(ast, [type], lambda$v);
}
function js_call_callee_name(expression) {
  let name = null;
  let jin2 = js_node_type_not_is(expression, "CallExpression");
  if (jin2) {
    return name;
  }
  let callee = property_get(expression, "callee");
  let jin = js_identifier_not_is(callee);
  if (jin) {
    return name;
  }
  name = property_get_name(callee);
  return name;
}
function js_node_type_not_is(node, type) {
  let type_is = js_node_type_is(node, type);
  let nti = not(type_is);
  return nti;
}
function js_identifier_not_is(id) {
  let jin = js_node_type_not_is(id, "Identifier");
  return jin;
}
function property_get_name(item) {
  let name = property_get(item, "name");
  return name;
}
function js_flo(ast) {
  function lambda2(la) {
    function lambda(v) {
      let node = property_get(v, "node");
      la(node);
    }
    js_visit_type(ast, "ExportNamedDeclaration", lambda);
  }
  let nameds = list_adder(lambda2);
  let r = list_single(nameds);
  let declaration = property_get(r, "declaration");
  return declaration;
}
function list_remove_all(list, item) {
  while (list_includes(list, item)) {
    list_remove(list, item);
  }
}
function list_difference(list, other) {
  function lambda2(la) {
    function lambda(l) {
      let a = list_includes(other, l);
      if (not(a)) {
        la(l);
      }
    }
    each(list, lambda);
  }
  let difference = list_adder(lambda2);
  return difference;
}
function list_add_if_not_includes(list, item) {
  "rename includes to exists todo";
  let exists = list_includes(list, item);
  if (not(exists)) {
    list_add(list, item);
  }
}
function js_identifiers_names(ast) {
  function lambda2(la) {
    function lambda(v) {
      let node = property_get(v, "node");
      let value = property_get(node, "name");
      la(value);
    }
    js_visit_type(ast, "Identifier", lambda);
  }
  const names = list_adder_unique(lambda2);
  return names;
}
function function_path_to_name(f_path) {
  let f_name = path_name(f_path);
  return f_name;
}
function path_name(file_path) {
  const filename = path_base(file_path);
  let v = filename.lastIndexOf(".");
  const name = filename.includes(".") ? filename.slice(0, v) : filename;
  return name;
}
async function file_js_parse(f_path) {
  let code = await file_read(f_path);
  const ast = await js_parse_async(code);
  const parsed = {
    ast,
    code,
    f_path
  };
  return parsed;
}
async function js_parse_async(code) {
  const acorn = await import("acorn");
  let v = js_parse_generic(acorn, code);
  return v;
}
function js_parse_generic(acorn, code) {
  let ast = null;
  try {
    ast = acorn.parse(code, {
      ecmaVersion: 2020,
      sourceType: "module"
    });
  } catch (e) {
    log_keep(code);
    throw e;
  }
  return ast;
}
async function functions_paths() {
  async function mapper(folder) {
    let f_names = await functions_names_from_path(folder);
    function lambda2(f_name) {
      let v = function_name_folder_to_path(f_name, folder);
      return v;
    }
    let mapped = list_map(f_names, lambda2);
    return mapped;
  }
  let squashed = await repos_paths_map_unordered_combine_squash(mapper);
  return squashed;
}
function data_path() {
  let inner = "";
  const folder = data_folder();
  let d_path = data_path_generic(inner, folder);
  return d_path;
}
function data_folder() {
  let d = "data";
  return d;
}
function data_path_generic(suffix, f_name_unsuffixed) {
  const f_name = f_name_unsuffixed + suffix;
  const folder = data_folder();
  let f_path = file_name_json_folder(folder, f_name);
  return f_path;
}
function file_name_json_folder(folder, f_name) {
  let joined = path_join([folder, f_name]);
  let f_path = file_name_json(joined);
  return f_path;
}
async function data_all_initialize(file_path) {
  let exists = await file_exists(file_path);
  if (not(exists)) {
    let contents = json_format_to_truncated({});
    await file_write(file_path, contents);
  }
}
async function file_write(f_path, contents) {
  let overwrite = file_overwrite;
  await file_write_generic(f_path, overwrite, contents);
}
async function file_write_generic(f_path, overwrite, contents) {
  await assert_file_exists_not(f_path);
  await overwrite(f_path, contents);
}
async function assert_file_exists_not(file_path_new) {
  if (await file_exists(file_path_new)) {
    error(file_path_new);
  }
}
async function file_overwrite(file_path, contents) {
  text_is_assert(contents);
  let exists = global_function_property_exists(file_read_cached, file_path);
  if (exists) {
    global_function_property_set(file_read_cached, file_path, contents);
  }
  if (not(exists)) {
    await file_overwrite_uncached(file_path, contents);
  }
}
async function file_overwrite_uncached(file_path, contents) {
  if (browser_is()) {
    file_path = file_path_normalize(file_path);
    await app_a_file_system_initialize();
    let store = app_a_file_system_store();
    async function value_get(previous) {
      const p = "compressed";
      let f = null;
      let nn = null_is(previous);
      if (nn) {
        f = {
          ["versions"]: [""]
        };
        previous = {
          key: file_path
        };
      } else {
        let compressed_before = property_get(previous, p);
        f = await json_decompress(compressed_before);
      }
      let e = text_empty_is(contents);
      if (e) {
        property_set(previous, "deleted", true);
      } else {
        property_delete_if_exists(previous, "deleted");
      }
      let list = property_get(f, "versions");
      list_add(list, contents);
      let compressed_after = await json_compress(f);
      property_set(previous, p, compressed_after);
      return previous;
    }
    let item = await indexeddb_put(app_a_indexeddb_initialize, store, file_path, value_get);
    return;
  } else {
    await file_parent_exists_ensure(file_path);
    let fs = await import("fs");
    await fs.promises.writeFile(file_path, contents, "utf-8");
  }
  await data_file_update(file_path);
  return;
}
function property_delete_if_exists(data, p) {
  let exists = property_exists(data, p);
  if (exists) {
    property_delete(data, p);
  }
}
function text_empty_is(s) {
  const e = s === "";
  return e;
}
async function data_file_update(f_path) {
  return;
  let f_names = await functions_names();
  let f_name = function_path_to_name(f_path);
  let n = list_includes_not(f_names, f_name);
  if (n) {
    return;
  }
  let d_path = data_path();
  var d = await data_all(d_path);
  let parsed = await file_js_parse(f_path);
  data_file_update_inner(parsed, d);
  await data_save(d);
  return;
}
async function data_save(a) {
  let data = property_get(a, "data");
  let file_path = property_get(a, "file_path");
  await file_overwrite_json(file_path, data);
}
async function file_overwrite_json(file_path, object) {
  if (browser_is()) {
    let json = json_format_to_truncated(object);
    await file_overwrite(file_path, json);
    return;
  }
  await file_parent_exists_ensure(file_path);
  "Using " + json_to.name + " did not work on sufficiently large object, whereas this did:";
  let fs = await import("fs");
  const v = await import("stream/promises");
  let pipeline = property_get(v, "pipeline");
  let streamJsonStringify = await (await import_install("stream-json-stringify")).default;
  const out = fs.createWriteStream(file_path);
  let json = streamJsonStringify(object);
  await pipeline(json, out);
}
async function file_parent_exists_ensure(file_path) {
  await file_root_exists_assert(file_path);
  let path = await import("path");
  const dir = path.dirname(file_path);
  await folder_exists_ensure(dir);
}
async function folder_exists_ensure(dir) {
  let fs = await import("fs");
  let path = await import("path");
  await fs.promises.mkdir(dir, {
    recursive: true
  });
  return path;
}
async function file_root_exists_assert(file_path) {
  let {exists, root} = await file_root_exists(file_path);
  assert_json(exists, {
    file_path,
    root,
    message: "root does not exist"
  });
}
async function file_root_exists(file_path) {
  let path = await import("path");
  let parsed = path.parse(file_path);
  let root = property_get(parsed, "root");
  let en = text_empty_not_is(root);
  let exists = true;
  if (en) {
    async function lambda2() {
      let fs = await import("fs");
      await fs.promises.access(root);
    }
    exists = await throws_not_async(lambda2);
  }
  let v = {
    exists,
    root
  };
  return v;
}
function text_empty_not_is(name) {
  let a = text_empty_is(name);
  const ne = not(a);
  return ne;
}
async function import_install(name) {
  try {
    let v = await import(name);
    return v;
  } catch (err) {
    if (err.code === "ERR_MODULE_NOT_FOUND" || err.code === "MODULE_NOT_FOUND") {
      await npm_install(name);
      let v2 = await import(name);
      return v2;
    }
    throw err;
  }
}
async function npm_install(package_name) {
  await command_line("npm install " + package_name + "@latest");
}
async function command_line(command) {
  let extra = {};
  const stdout = await command_line_generic(command, extra);
  return stdout;
}
async function command_line_generic(command, extra) {
  const {exec} = await import("child_process");
  const {promisify} = await import("util");
  const execAsync = promisify(exec);
  const options = {
    encoding: "utf8"
  };
  object_merge(options, extra);
  const stdout = await execAsync(command, options);
  return stdout;
}
async function indexeddb_put(db_get, store, key, value_get) {
  let all = await indexeddb_get_all(db_get, store);
  let f = list_find_property_or_null(all, "key", key);
  const next = await value_get(f);
  log({
    next
  });
  if (null_is(f)) {
    list_add(all, next);
  } else {
    object_replace(f, next);
  }
  async function lambda_async() {
    await indexeddb_put_backend(db_get, store, key, next);
  }
  indexeddb_next(lambda_async);
  return next;
}
function list_find_property_or_null(list, property_name, property_value) {
  let filter = property_equals_lambda(property_name, property_value);
  let filtered = list_filter(list, filter);
  let e = list_empty_is(filtered);
  if (e) {
    let v = null;
    return v;
  }
  let only = list_single(filtered);
  return only;
}
async function indexeddb_put_backend(db_get, store, key, next) {
  const db = await db_get();
  if (false) {
    const previous = await new Promise(function lambda3(resolve, reject) {
      const tx = db.transaction(store, "readonly");
      const s = tx.objectStore(store);
      const req = s.get(key);
      req.onsuccess = function lambda() {
        let v = resolve(req.result ?? null);
        return v;
      };
      req.onerror = function lambda2() {
        let v2 = reject(req.error);
        return v2;
      };
    });
  }
  const tx = db.transaction(store, "readwrite");
  const s = tx.objectStore(store);
  s.put(next);
  await new Promise(function lambda6(resolve, reject) {
    tx.oncomplete = resolve;
    tx.onerror = function lambda4() {
      let v3 = reject(tx.error);
      return v3;
    };
    tx.onabort = function lambda5() {
      let v4 = reject(tx.error);
      return v4;
    };
  });
}
function object_replace(to, from) {
  if (equal_not(to, from)) {
    properties_delete_all(to);
    object_merge(to, from);
  }
}
function properties_delete_all(obj) {
  function lambda(p) {
    let v = property_delete(obj, p);
    return v;
  }
  let list = properties_get(obj);
  each(list, lambda);
}
function data_aliases_path() {
  let f_path = data_path_generic("", "aliases");
  return f_path;
}
async function user_repo_firebase_service_account_get() {
  let repo_name = await user_repo_get();
  let v = await repo_firebase_service_account_get(repo_name);
  return v;
}
async function repo_firebase_service_account_get(repo_name) {
  const key = "firebase_service_account";
  let v = await repo_about_get(repo_name, key);
  return v;
}
async function repo_about_get(repo, key) {
  let a_path = path_repo_about(repo);
  let {value} = await data_get(key, null, a_path);
  let v = value;
  return v;
}
function path_repo_about(repo) {
  let f_path = data_path_generic("", "about");
  let a_path = path_repo_combine(repo, f_path);
  return a_path;
}
function path_repo_combine(repo, f_path) {
  let r_path = repo_path(repo);
  let joined = path_join([r_path, f_path]);
  return joined;
}
async function user_repo_get() {
  let f_path = user_repo_path();
  let v = await data_get("repo_current", null, f_path);
  let repo_name = property_get(v, "value");
  await repo_exists_assert(repo_name);
  return repo_name;
}
async function repo_exists_assert(repo_name) {
  let all = await repos_names();
  list_includes_assert(all, repo_name);
}
function list_includes_assert(all, repo_name) {
  let includes = list_includes(all, repo_name);
  assert(includes);
}
function user_repo_path() {
  const name = "user";
  let f_path = file_name_json_folder_gitignore(name);
  return f_path;
}
function file_name_json_folder_gitignore(name) {
  let f_path2 = file_name_json_folder("gitignore", name);
  return f_path2;
}
function firebase_path_fix(path) {
  let replaced = text_replace(path, "\\", "/");
  return replaced;
}
function text_replace(s, from, to) {
  let split = text_split(s, from);
  let replaced = list_join(split, to);
  return replaced;
}
async function firebase_storage_url(storage_path) {
  let replaced = text_replace(storage_path, "/", "%2F");
  let url = "https://firebasestorage.googleapis.com/v0/b/" + await firebase_storage_url_project() + "/o/" + replaced + "?alt=media";
  return url;
}
async function indexeddb_get(db_get, store, key) {
  let all = await indexeddb_get_all(db_get, store);
  let f = list_find_property(all, "key", key);
  return f;
}
function repo_path_combine(repo_name, f_path) {
  let folder_name = repo_path(repo_name);
  let combined = path_join([folder_name, f_path]);
  return combined;
}
async function app_original_bible_home(context) {
  let download = app_original_bible_gloss_generate_download;
  await app_gloss_bible_home_generic(context, download, false);
}
async function app_original_bible_gloss_generate_download(chapter_code) {
  let destination_get = app_original_bible_gloss_generate_upload_path;
  let fn = app_original_bible_gloss_generate_download;
  let value = await global_firebase_storage_download_json_decompress(fn, destination_get, chapter_code);
  return value;
}
function app_original_bible_gloss_generate_upload_path(chapter_code) {
  let f_name = fn_name("app_original_bible_gloss_generate_upload");
  let destination = g_objection_generate_upload_path_generic(f_name, chapter_code);
  return destination;
}
function g_objection_generate_upload_path_generic(f_name, chapter_code) {
  let file_name = file_name_json(chapter_code);
  let joined2 = path_join(["uploads", file_name]);
  let destination = firebase_deploy_function_destination(f_name, joined2);
  return destination;
}
async function global_firebase_storage_download_json_decompress(fn, destination_get, property_name) {
  async function get() {
    let destination = destination_get(property_name);
    let o = await firebase_storage_download_json_decompress(destination);
    return o;
  }
  let value = await global_function_property_initialize_async(fn, property_name, get);
  return value;
}
async function global_function_property_initialize_async(fn, property_name, lambda) {
  let global = global_get();
  let fn_object = property_initialize(global, fn.name, {});
  let value = await property_initialize_lambda_async(fn_object, property_name, lambda);
  return value;
}
async function firebase_storage_download_json_decompress(destination) {
  let c = await firebase_storage_download_json(destination);
  let o = await json_decompress_object(c);
  return o;
}
async function json_decompress_object(c) {
  let compressed = property_get(c, "compressed");
  let o = await json_decompress(compressed);
  return o;
}
async function firebase_storage_download_json(destination) {
  let s = await firebase_storage_download_text(destination);
  let o = json_from(s);
  return o;
}
async function firebase_storage_download_text(destination) {
  let buffer = await firebase_storage_download(destination);
  let s = buffer_text_to(buffer);
  return s;
}
async function app_gloss_bible_home_generic(context, download, text_use) {
  let generated = g_sermon_generate_book_generic_property();
  let v2 = await app_g_bible_home_inner(context, download);
  let passages = property_get(v2, "passages");
  each_next(passages, on_passage);
  function on_passage(a, next) {
    let verses = property_get(a, "verses");
    let passage = property_get(a, "passage");
    const prop = "p";
    let last = list_last(verses);
    let p = property_get(last, prop);
    if (null_not_is(next)) {
      let d = html_div_centered(p);
      let text3 = emoji_arrow_down();
      async function lambda3() {
        let verses_next = property_get(next, "verses");
        await scroll(verses_next);
      }
      let component = html_button(d, text3, lambda3);
    }
    let h = html_hr(p);
    let texts = null;
    if (text_use) {
      let passage_texts = property_get(passage, "texts");
      let first = list_first(passage_texts);
      texts = [first];
    } else {
      texts = property_get(passage, "originals");
    }
    function lambda5(t) {
      let div = html_div_text(p, t);
      html_font_color_set_green(div);
    }
    each(texts, lambda5);
    let explains_json = property_get(passage, generated);
    let explains = json_from_try(explains_json);
    if (false) {
      let div3 = html_div(p);
      function lambda2(e) {
        let span = html_span_text_nbsp_replace_property_from(div3, e, generated);
        html_font_color_set_green(span);
        html_span_nbsp(div3);
        let span2 = html_span_text_nbsp_replace_property_from(div3, e, "gloss");
        html_font_color_set_blue(span2);
        let span4 = html_span_space(div3);
      }
      each(explains, lambda2);
    }
    let word_property = app_gloss_bible_generate_generic_word();
    function lambda(e) {
      let component2 = html_hr(p);
      let div2 = html_div(p);
      let word = property_get(e, word_property);
      let gloss = property_get(e, "gloss");
      let explain = property_get(e, "explain");
      let span = html_span_text(div2, word);
      html_bold_mild(span);
      html_font_color_set(span, "#e40000ff");
      let c = html_span_colon_2(div2);
      html_font_color_set(c, "#aaa");
      let span2 = html_span_text(div2, gloss);
      html_font_color_set_blue(span2);
      let c2 = html_span_colon_2(div2);
      html_font_color_set(c2, "#aaa");
      let span3 = html_span_text(div2, explain);
      html_font_color_set(span3, "#7b3f97ff");
    }
    each(explains, lambda);
    async function lambda6() {
      await scroll(verses);
    }
    let text2 = emoji_arrow_up();
    let d = html_div_centered(p);
    let component = html_button(d, text2, lambda6);
    let component22 = html_hr(p);
    return;
  }
  async function scroll(verses) {
    let f = list_first(verses);
    let p = property_get(f, "p_verse");
    log({
      p,
      verses
    });
    await html_scroll_top_now(p);
  }
}
function json_from_try(json) {
  let left = json_starts_find_index(json);
  let skipped = text_skip(json, left);
  let right = json_ends_find_index(skipped);
  let without = text_slice_0(skipped, right + 1);
  let first = text_first(without);
  if (first === js_code_bracket_open()) {
    let last = text_last(without);
    let end = js_code_bracket_close();
    if (equal_not(last, end)) {
      without += end + "";
    }
  }
  let result = json_from(without);
  return result;
}
function text_first(t) {
  let item = text_get(t, 0);
  return item;
}
function text_get(s, index) {
  integer_is_assert(index);
  let item = s[index];
  undefined_not_is_assert_lambda(item, object_get);
  function object_get() {
    let v = {
      s,
      index
    };
    return v;
  }
  return item;
}
function text_last(s) {
  let index_last = text_index_last(s);
  let item = text_get(s, index_last);
  return item;
}
function text_index_last(s) {
  const index_last = text_size(s) - 1;
  return index_last;
}
function js_code_bracket_close() {
  let b = "]";
  return b;
}
function js_code_bracket_open() {
  let b = "[";
  return b;
}
function json_ends_find_index(json) {
  let get = json_ends;
  let c = text_index_of_last_try_curried;
  let right = json_starts_find_index_generic(get, c, json);
  return right;
}
function text_index_of_last_try_curried(s) {
  let r2 = function text_index_of_last_try_curried_result(search) {
    let r = text_index_of_last_try(s, search);
    return r;
  };
  return r2;
}
function text_index_of_last_try(s, search) {
  let r = s.lastIndexOf(search);
  return r;
}
function json_starts_find_index_generic(get, c, json) {
  let list = get();
  let r = c(json);
  let left = list_map_negative_not_min_try(list, r);
  return left;
}
function list_map_negative_not_min_try(list, mapper) {
  let mapped = list_map(list, mapper);
  let filtered = list_filter(mapped, negative_not_is);
  let r = list_min_try(filtered);
  return r;
}
function negative_not_is(i) {
  let p = negative_is(i);
  let nn = not(p);
  return nn;
}
function negative_is(i) {
  let p = i < 0;
  return p;
}
function list_min_try(mapped) {
  let filtered = list_filter(mapped, integer_is);
  let left = list_min(filtered);
  return left;
}
function list_min(list) {
  let m = Math.min(...list);
  return m;
}
function json_ends() {
  let b = js_code_bracket_close();
  let a = js_code_brace_right();
  let list = [a, b];
  return list;
}
function json_starts_find_index(json) {
  let get = json_starts;
  let c = text_index_of_try_curried;
  let left = json_starts_find_index_generic(get, c, json);
  return left;
}
function text_index_of_try_curried(t) {
  let r = function text_index_of_try_curried_result(item) {
    let v = text_index_of_try(t, item);
    return v;
  };
  return r;
}
function json_starts() {
  let b = js_code_bracket_open();
  let v2 = js_code_brace_left();
  let list = [v2, b];
  return list;
}
function app_gloss_bible_generate_generic_word() {
  let r = "word";
  return r;
}
function g_sermon_generate_book_generic_property() {
  let g = "generated";
  return g;
}
function emoji_arrow_down() {
  let e = "â¬‡ï¸";
  return e;
}
function each_next(list, lambda$item$next) {
  let v4 = each_previous_generic(index_valid_is, add_1, list, lambda$item$next);
  return v4;
  function index_valid_is(index) {
    let n = list_index_last_not_is(list, index);
    return n;
  }
}
function list_index_last_not_is(list, index) {
  let b = list_index_last_is(list, index);
  let n = not(b);
  return n;
}
function list_index_last_is(list, index) {
  let index_last = list_index_last(list);
  let li = index === index_last;
  return li;
}
function list_index_last(list) {
  const index_last = list_index_end(list, 0);
  return index_last;
}
function add_1(left) {
  let a = add(left, 1);
  return a;
}
function each_previous_generic(index_valid_is, index_other_get, list, lambda$item$other) {
  function lambda_each_previous_generic(item, index) {
    let other = null;
    if (index_valid_is(index)) {
      let index2 = index_other_get(index);
      other = list_get(list, index2);
    }
    lambda$item$other(item, other);
  }
  let v = each_index(list, lambda_each_previous_generic);
  return v;
}
function html_div_centered(p) {
  let d = html_div(p);
  html_centered(d);
  return d;
}
function html_centered(div) {
  html_style_set(div, "text-align", "center");
}
async function html_scroll_top_now(component) {
  const block = "start";
  const behavior = "auto";
  await html_scroll_generic(component, behavior, block);
}
async function html_scroll_generic(component, behavior, block) {
  let el = await html_scroll_generic_wait(component);
  el.scrollIntoView({
    behavior,
    block: block,
    inline: "center"
  });
}
async function html_scroll_generic_wait(player_img_c) {
  let el = html_component_element_get(player_img_c);
  if (el.tagName === "IMG" && not(el.complete)) {
    await new Promise(function lambda(r) {
      let v = el.onload = r;
      return v;
    });
  }
  await new Promise(function lambda4(r) {
    function lambda3() {
      function lambda2() {
        let v2 = requestAnimationFrame(r);
        return v2;
      }
      let v3 = requestAnimationFrame(lambda2);
      return v3;
    }
    let v4 = requestAnimationFrame(lambda3);
    return v4;
  });
  return el;
}
function emoji_arrow_up() {
  let e = "â¬†ï¸";
  return e;
}
function html_button(parent, text, lambda) {
  assert_arguments(arguments, 3);
  let component = html_button_notext(parent, lambda);
  html_text_set(component, text);
  return component;
}
function html_button_notext(parent, lambda) {
  let component = html_button_element(parent);
  html_on_click(component, lambda);
  return component;
}
function html_on_click(component, lambda) {
  const name_event = "click";
  html_on(component, name_event, lambda);
}
function html_on(component, name_event, lambda) {
  function_is_assert(lambda);
  let element = html_component_element_get(component);
  element.addEventListener(name_event, lambda);
}
function function_is_assert(lambda) {
  let fi = function_is(lambda);
  assert_json(fi, {
    lambda
  });
}
function function_is(f) {
  let fi = typeof f === "function";
  return fi;
}
function html_button_element(parent) {
  const tag_name = "button";
  let b = html_element(parent, tag_name);
  html_style_font_size_inherit(b);
  return b;
}
function html_style_font_size_inherit(component) {
  html_style_font_size(component, "inherit");
}
function html_span_text(parent, text) {
  let span = html_span(parent);
  html_text_set(span, text);
  return span;
}
function html_span(parent) {
  let component = html_element(parent, "span");
  return component;
}
function html_span_text_nbsp_replace_property_from(parent, obj, prop) {
  let word = property_get(obj, prop);
  let span = html_span_text_nbsp_replace(parent, word);
  return span;
}
function html_span_text_nbsp_replace(parent, text) {
  let replaced = html_nbsp_replace(text);
  let span = html_span_text(parent, replaced);
  html_style_set(span, "white-space", "nowrap");
  return span;
}
function html_nbsp_replace(s) {
  let replaced = text_replace(s, " ", "&nbsp;");
  return replaced;
}
function html_span_nbsp(parent) {
  let text = html_nbsp_replace(" ");
  let span = html_span_text(parent, text);
  return span;
}
function html_font_color_set_blue(span2) {
  html_font_color_set(span2, "rgba(0, 0, 213, 1)");
}
function html_font_color_set(component, color) {
  html_style_set(component, "color", color);
}
function html_span_colon_2(div2) {
  let span = html_span_text(div2, " :: ");
  return span;
}
function html_bold_mild(b) {
  html_style_set(b, "font-weight", "500");
}
function html_hr(root) {
  let h = html_element(root, "hr");
  return h;
}
function html_font_color_set_green(div) {
  let c = app_karate_button_background();
  html_font_color_set(div, "#00ad28ff");
}
function app_karate_button_background() {
  let c = "#159834";
  return c;
}
function html_div_text(root, text) {
  let div = html_div(root);
  html_text_set(div, text);
  return div;
}
async function app_g_bible_home_inner(context, download) {
  let downloaded = null;
  let chapter_code = null;
  let verses = [];
  let r = null;
  async function lambda3(la) {
    async function lambda(a) {
      list_add(verses, a);
      let verse_number = property_get(a, "verse_number");
      chapter_code = property_get(a, "chapter_code");
      downloaded = await download(chapter_code);
      let passages = property_get(downloaded, "passages");
      function lambda2(passage) {
        let verse_numbers = property_get(passage, "verse_numbers");
        let mapped = list_map(verse_numbers, integer_to_try);
        let max = list_max(mapped);
        let s = text_to(max);
        if (equal(s, verse_number)) {
          let copy = list_copy(verses);
          la({
            passage,
            verses: copy
          });
          list_empty(verses);
        }
      }
      each(passages, lambda2);
    }
    r = await app_bible_home_generic(context, lambda);
  }
  let passages = await list_adder_async(lambda3);
  let v = {
    chapter_code,
    downloaded,
    r,
    passages
  };
  return v;
}
async function list_adder_async(lambda$la) {
  let list = [];
  function list_adder_inner(item) {
    list_add(list, item);
  }
  await lambda$la(list_adder_inner);
  return list;
}
function list_empty(list) {
  property_set(list, "length", 0);
}
async function app_bible_home_generic(context, lambda$a) {
  let root = html_clear_context(context);
  html_clear(root);
  let bc = html_bar_content_padded(root);
  let content = property_get(bc, "content");
  let bar = property_get(bc, "bar");
  html_centered(bar);
  let e = ebible_folder_english();
  let hash = html_hash_object_get();
  let n = property_exists_not(hash, "c");
  if (n) {
    app_bible_chapter_open(context, hash, "JHN01");
    return;
  }
  let chapter_code = property_get(hash, "c");
  let v2 = ebible_chapter_code_parse(chapter_code);
  let chapter_name = property_get(v2, "chapter_name");
  let book_code = property_get(v2, "book_code");
  let books = await ebible_version_books(e);
  let book_name = ebible_book_code_to_name(books, book_code);
  async function lambda6() {
    await on_arrow(list_previous_wrap);
  }
  let text3 = emoji_arrow_left();
  let component4 = html_button(bar, text3, lambda6);
  function lambda5() {
    app_shared_screen_set(context, app_bible_books);
  }
  let component = html_button(bar, book_name, lambda5);
  function lambda4() {
    app_shared_screen_set(context, app_bible_chapters);
  }
  let component2 = html_button(bar, chapter_name, lambda4);
  let text2 = emoji_arrow_right();
  async function lambda3() {
    await on_arrow(list_next_wrap);
  }
  let component3 = html_button(bar, text2, lambda3);
  function lambda12() {}
  let component7 = html_button(bar, "Languages", lambda12);
  const scroll_top_key = app_bible_hash_key_scroll_top();
  let verses = await ebible_verses(e, chapter_code);
  async function on_arrow(list_next_wrap) {
    let list = await ebible_chapter_codes(e);
    let next = list_next_wrap(list, chapter_code);
    app_bible_chapter_open(context, hash, next);
  }
  let verse_numbers_chosen = [];
  let languages_verses = [];
  let updates = [];
  async function each_verse(v) {
    let verse_number = property_get(v, "verse_number");
    let text = property_get(v, "text");
    let p_verse = html_p(content);
    let top = html_div(p_verse);
    let bottom = html_div(p_verse);
    html_centered(bottom);
    let hidden = false;
    toggle();
    biblehub_button_open("interlinear/", verse_number, bottom, "Interlinear");
    biblehub_button_open("", verse_number, bottom, "Parallel");
    function lambda8() {}
    let text4 = html_button_copy_text();
    let component6 = html_button(bottom, text4, lambda8);
    let v3 = app_chapter_toggle_update(updates, component6, verse_numbers_chosen, verse_number, chapter_code, languages_verses, p_verse);
    let update = property_get(v3, "update");
    list_add(updates, update);
    function toggle() {
      hidden = not(hidden);
      html_display_none_or_block(hidden, bottom);
    }
    let verse_number_v_button = html_button(top, verse_number, toggle);
    let split = text_split_space(text);
    function lambda2(item) {
      html_span_space(top);
      let item_span = html_span_text(top, item);
      function lambda9() {
        let letters_only = text_letters_only(item);
        window_open("https://www.google.com/search?q=define:" + letters_only);
      }
      html_on_click(item_span, lambda9);
    }
    each(split, lambda2);
    let p = html_p(content);
    await lambda$a({
      p_verse,
      p,
      chapter_code,
      verse_number
    });
    return;
  }
  await each_async(verses, each_verse);
  list_add(languages_verses, {
    verses,
    books
  });
  function biblehub_button_open(folder, verse_number_v, bottom, button_text) {
    function lambda10() {
      let replaced = text_replace_space_underscore_lower(book_name);
      if (equal(replaced, "song")) {
        replaced = "songs";
      }
      window_open("https://biblehub.com/" + folder + replaced + "/" + chapter_name + "-" + verse_number_v + ".htm");
    }
    let component5 = html_button(bottom, button_text, lambda10);
  }
  function on_scroll() {
    let scroll_top = html_scroll_top_get(content);
    html_hash_object_property_set(scroll_top_key, scroll_top);
  }
  html_on_scroll(content, on_scroll);
  let exists = property_exists(hash, scroll_top_key);
  if (exists) {
    let value = property_get(hash, scroll_top_key);
    html_scroll_top_set(content, value);
  }
  let v4 = {
    bar
  };
  return v4;
}
function text_replace_space_underscore_lower(t) {
  let lower = text_lower_to(t);
  let rl = text_replace_space_underscore(lower);
  return rl;
}
function text_replace_space_underscore(name_old) {
  let replaced2 = text_replace(name_old, " ", "_");
  return replaced2;
}
function text_lower_to(s) {
  let lower = s.toLowerCase();
  return lower;
}
function app_bible_hash_key_scroll_top() {
  let v5 = "scroll_top";
  return v5;
}
function html_hash_object_property_set(scroll_top_key, scroll_top) {
  let hash2 = html_hash_object_get();
  property_set(hash2, scroll_top_key, scroll_top);
  html_hash_set_object(hash2);
}
function html_hash_set_object(hash) {
  let url = hash_to_url(hash);
  html_hash_set(url);
}
function html_hash_set(h) {
  history.replaceState(null, "", h);
  return;
  "if we need to update history, then perhaps make a new function";
  window.location.hash = h;
}
function hash_to_url(hash) {
  function lambda3(la) {
    function lambda(value, property) {
      let part = property + "=" + value;
      la(part);
    }
    each_object(hash, lambda);
  }
  let parts = list_adder(lambda3);
  let result2 = list_join_comma(parts);
  let h = html_hash_symbol();
  const url = h + result2;
  return url;
}
function html_hash_symbol() {
  let h = "#";
  return h;
}
function list_join_comma(list) {
  let result = list_join(list, ",");
  return result;
}
function html_hash_object_get() {
  function lambda3(oa) {
    let hash_url = html_hash_get();
    let prefix = html_hash_symbol();
    let n = text_includes_not(hash_url, prefix);
    if (n) {
      return;
    }
    let without = text_prefix_without(hash_url, prefix);
    let split = text_split_comma(without);
    function lambda(s) {
      let split2 = text_split_equal(s);
      let v = list_first_second(split2);
      let second = property_get(v, "second");
      let first = property_get(v, "first");
      oa(first, second);
    }
    each(split, lambda);
  }
  let hash = object_adder(lambda3);
  return hash;
}
function text_includes_not(item, part) {
  let v = text_includes(item, part);
  let n = not(v);
  return n;
}
function object_adder(lambda$oad) {
  let v = object_adder_generic(property_set_exists_not);
  let result = property_get(v, "result");
  let oa = property_get(v, "oa");
  lambda$oad(oa);
  return result;
}
function object_adder_generic(fn_set) {
  let result = {};
  let oa = function lambda(key, value) {
    fn_set(result, key, value);
  };
  let r = {
    oa,
    result
  };
  return r;
}
function list_first_second(list) {
  const property_name = "second";
  let value_get = list_second;
  let result = list_first_second_generic(list, value_get, property_name);
  return result;
}
function list_second(list) {
  const index = 1;
  const second = list_get(list, index);
  return second;
}
function text_split_equal(s) {
  let split3 = text_split(s, "=");
  return split3;
}
function text_split_comma(t) {
  let split = text_split(t, ",");
  return split;
}
function html_hash_get() {
  let h = window.location.hash;
  return h;
}
async function each_async(list, lambda$item) {
  for (let item of list) {
    if (await lambda$item(item) === true) {
      break;
    }
  }
}
function html_scroll_top_set(component, scroll_top) {
  let element2 = html_component_element_get(component);
  property_set(element2, "scrollTop", scroll_top);
}
function html_scroll_top_get(component) {
  let element = html_component_element_get(component);
  let scroll_top = property_get(element, "scrollTop");
  return scroll_top;
}
function html_button_copy_text() {
  let c = emoji_copy() + " Copy";
  return c;
}
function emoji_copy() {
  let v = "ðŸ“‹";
  return v;
}
function app_chapter_toggle_update(updates, component_clicked, verse_numbers_chosen, verse_number, chapter_code, languages_verses, component_highlighted) {
  async function choose() {
    log("message");
    toggle();
    invoke_multiple(updates);
    await copy();
  }
  html_on_click(component_clicked, choose);
  let toggle = function lambda5() {
    list_toggle(verse_numbers_chosen, verse_number);
    let max = app_chapter_chosen_max();
    list_size_max_skip_replace(verse_numbers_chosen, max);
  };
  let update = function lambda4() {
    let sliced = null;
    let m = list_multiple_is(verse_numbers_chosen);
    if (m) {
      let l = list_last(languages_verses);
      let verses = property_get(l, "verses");
      let verse_numbers = list_map_property(verses, "verse_number");
      let v = list_first_last_slice(verse_numbers_chosen, verse_numbers);
      sliced = property_get(v, "sliced");
    } else {
      sliced = verse_numbers_chosen;
    }
    html_style_background_color_set_or_remove_list(component_highlighted, sliced, verse_number);
  };
  let r = {
    toggle,
    update,
    copy
  };
  async function copy() {
    list_sort_number_mapper(verse_numbers_chosen, integer_to_try);
    function lambda3(bv) {
      log({
        languages_verses
      });
      let m = list_multiple_is(verse_numbers_chosen);
      let verse_numbers_chosen_normalized = null;
      if (m) {
        verse_numbers_chosen_normalized = verse_numbers_chosen;
      } else {
        let f = list_first(verse_numbers_chosen);
        verse_numbers_chosen_normalized = [f, f];
      }
      let verse_numbers_mapped = null;
      let books = property_get(bv, "books");
      let verses = property_get(bv, "verses");
      let verse_numbers = list_map_property(verses, "verse_number");
      let v = list_first_last_slice(verse_numbers_chosen_normalized, verse_numbers);
      let last = property_get(v, "last");
      let first = property_get(v, "first");
      let sliced = property_get(v, "sliced");
      verse_numbers_mapped = list_map_find_property(sliced, verses, "verse_number");
      let mapped3 = list_map_property(verse_numbers_mapped, "text");
      let reference = ebible_parts_chapter_code_to_reference(chapter_code, books, [first, last]);
      let concated2 = list_concat([reference], mapped3);
      return concated2;
    }
    let m = list_map(languages_verses, lambda3);
    let squashed = list_squash(m);
    let joined = await list_join_newline_2_copy(squashed);
  }
  return r;
}
function list_first_last_slice(list_rg, list) {
  let v = list_first_last(list_rg);
  let first = list_first(v);
  let last = list_last(v);
  let sliced = list_slice_from(list, first, last);
  let r = {
    sliced,
    first,
    last
  };
  return r;
}
function list_slice_from(list, item_from, item_to) {
  function lambda(item) {
    let index = list_index_of(list, item);
    return index;
  }
  let mapped = list_map([item_from, item_to], lambda);
  let v2 = list_slice_from_indices(list, mapped);
  return v2;
}
function list_slice_from_indices(list, indices) {
  list_sort_number(indices);
  let v = list_first_last(indices);
  let first = list_first(v);
  let last = list_last(v);
  let sliced = list_slice_include(list, first, last);
  return sliced;
}
function list_slice_include(list, a, b) {
  let sliced = list_slice(list, a, b + 1);
  return sliced;
}
function list_first_last(list) {
  list_multiple_is_assert(list);
  let first = list_first(list);
  let last = list_last(list);
  let fl = [first, last];
  return fl;
}
function list_multiple_is_assert(list) {
  let m = list_multiple_is(list);
  assert(m);
}
function list_sort_number(list) {
  list_sort_number_mapper(list, identity);
}
function list_sort_number_mapper(list, lambda$item) {
  function lambda(a, b) {
    const va = lambda$item(a);
    const vb = lambda$item(b);
    if (va < vb) return -1;
    if (va > vb) return 1;
    return 0;
  }
  list.sort(lambda);
}
function list_size_max_skip_replace(verse_numbers_chosen, max) {
  let copy = list_size_max_skip_copy(verse_numbers_chosen, max);
  list_replace_all(verse_numbers_chosen, copy);
}
function list_replace_all(list, list_new) {
  list_empty(list);
  list_add_multiple(list, list_new);
}
function list_size_max_skip_copy(verse_numbers_chosen, max) {
  let copy = list_copy(verse_numbers_chosen);
  list_size_max_skip(copy, max);
  return copy;
}
function list_size_max_skip(list, max) {
  let size = list_size(list);
  if (greater_than(size, max)) {
    const s = size - max;
    list_remove_start(list, s);
  }
  return list;
}
function list_remove_start(list, delete_count) {
  list.splice(0, delete_count);
}
function greater_than(a, b) {
  let g = a > b;
  return g;
}
async function list_join_newline_2_copy(concated) {
  let joined = list_join_newline_2(concated);
  await clipboard_copy(joined);
  return joined;
}
async function clipboard_copy(text) {
  let b = browser_is();
  if (b) {
    await navigator.clipboard.writeText(text);
    return;
  }
  const clipboard = await import("clipboardy");
  await clipboard.default.write(text);
}
function list_join_newline_2(list) {
  let separator = newline();
  let joined = list_join(list, separator + separator);
  return joined;
}
function list_concat(a, b) {
  let l = list_is(a);
  assert(l);
  let concated = a.concat(b);
  return concated;
}
function ebible_parts_chapter_code_to_reference(chapter_code, books, verse_numbers) {
  let {book_code, chapter_name} = ebible_chapter_code_parse(chapter_code);
  const reference = ebible_parts_to_reference(books, book_code, verse_numbers, chapter_name);
  return reference;
}
function ebible_parts_to_reference(books, book_code, verse_numbers, chapter_name) {
  let book_name = ebible_book_code_to_name(books, book_code);
  let verse_numbers_s = null;
  let unique = list_unique(verse_numbers);
  let s1 = list_size_1(unique);
  let first = list_first(unique);
  if (s1) {
    verse_numbers_s = first;
  } else {
    let last = list_last(unique);
    verse_numbers_s = first + "-" + last;
  }
  const reference = book_name + " " + chapter_name + ":" + verse_numbers_s;
  return reference;
}
function ebible_book_code_to_name(books, book_code) {
  let book = list_find_property(books, "book_code", book_code);
  let book_name = property_get(book, "text");
  return book_name;
}
function ebible_chapter_code_parse(chapter_code) {
  let book_code = ebible_chapter_code_to_book(chapter_code);
  let chapter_name = ebible_chapter_code_to_name(chapter_code);
  let v = {
    book_code,
    chapter_name
  };
  return v;
}
function ebible_chapter_code_to_name(chapter_code) {
  let s = ebible_chapter_code_to_name_code(chapter_code);
  let i = integer_to_try(s);
  let chapter_name = text_to(i);
  return chapter_name;
}
function ebible_chapter_code_to_name_code(chapter_code) {
  let count = ebible_book_code_size();
  let name_code = text_skip(chapter_code, count);
  return name_code;
}
function ebible_book_code_size() {
  let v = 3;
  return v;
}
function text_to(input) {
  const s = input.toString();
  return s;
}
function integer_to_try(input) {
  let i = parseInt(input, 10);
  if (Number.isNaN(i)) {
    let v = null;
    return v;
  }
  return i;
}
function ebible_chapter_code_to_book(chapter_code) {
  let count = ebible_book_code_size();
  let book_code = text_take(chapter_code, count);
  return book_code;
}
function list_map_find_property(list, list_other, property) {
  function lambda4(item) {
    let r = list_find_property(list_other, property, item);
    return r;
  }
  let founds = list_map(list, lambda4);
  return founds;
}
function html_style_background_color_set_or_remove_list(component, list, item) {
  let chosen = list_includes(list, item);
  html_style_background_color_set_or_remove(chosen, component, "lightgreen");
}
function html_style_background_color_set_or_remove(chosen, component, color) {
  if (chosen) {
    html_style_background_color_set(component, color);
  } else {
    html_style_remove(component, "background-color");
  }
}
function html_style_remove(b, style_key) {
  let b_element = html_component_element_get(b);
  b_element.style.removeProperty(style_key);
}
function html_style_background_color_set(component, background) {
  html_style_assign(component, {
    "background-color": background
  });
}
function app_chapter_chosen_max() {
  let v3 = 2;
  return v3;
}
function list_toggle(chosen, item) {
  let includes2 = list_includes(chosen, item);
  if (includes2) {
    list_remove(chosen, item);
  } else {
    list_add(chosen, item);
  }
}
function invoke_multiple(list_fns) {
  let mapped = list_map(list_fns, invoke);
  return mapped;
}
function html_clear_context(context) {
  let root = property_get(context, "root");
  html_clear(root);
  return root;
}
function html_display_none_or_block(hidden, item) {
  if (hidden) {
    html_display_none(item);
  } else {
    html_display_block(item);
  }
}
function html_display_block(element) {
  html_style_set(element, "display", "block");
}
function html_display_none(element) {
  html_style_set(element, "display", "none");
}
function window_open(url) {
  window.open(url, "_blank");
}
function text_letters_only(str) {
  let v = regex_letters_not();
  let letters = str.replace(v, "");
  return letters;
}
function regex_letters_not() {
  let v = /[^a-zA-Z]/g;
  return v;
}
function html_span_space(parent) {
  html_span_text(parent, " ");
}
function text_split_space(s) {
  let split = text_split(s, " ");
  return split;
}
function html_p(root) {
  let p = html_element(root, "p");
  return p;
}
async function app_bible_chapters(context) {
  let root = html_clear_context(context);
  let e = ebible_folder_english();
  let hash = html_hash_object_get();
  let chapter_code = property_get(hash, "c");
  let book_code = ebible_chapter_code_to_book(chapter_code);
  let chapter_codes = await ebible_book_code_to_chapter_codes(e, book_code);
  let mapped = list_map_prefix_without(chapter_codes, book_code);
  let chapter_numbers = list_map(mapped, integer_to_try);
  let books = await ebible_version_books(e);
  let book_name = ebible_book_code_to_name(books, book_code);
  html_div_text_centered(root, book_name);
  let div = html_div(root);
  html_centered(div);
  function lambda(chapter_code) {
    let chapter_name = ebible_chapter_code_to_name(chapter_code);
    function lambda3() {
      app_bible_chapter_open(context, hash, chapter_code);
    }
    let component = html_button(div, chapter_name, lambda3);
  }
  each(chapter_codes, lambda);
  log({
    mapped2: chapter_numbers
  });
}
async function ebible_book_code_to_chapter_codes(bible_folder, book_code) {
  let chapter_codes_all = await ebible_chapter_codes(bible_folder);
  let chapter_codes = list_filter_starts_with(chapter_codes_all, book_code);
  return chapter_codes;
}
async function ebible_chapter_codes(bible_folder) {
  assert_arguments(arguments, 1);
  let b = browser_is();
  if (b) {
    let file_name = ebible_chapter_codes_upload_name();
    let value = await firebase_storage_download_ebible_cache(ebible_chapter_codes, bible_folder, file_name);
    return value;
  }
  let books = await ebible_version_books(bible_folder);
  let chapter_codes = await ebible_books_to_chapter_codes(books, bible_folder);
  return chapter_codes;
}
function ebible_chapter_codes_upload_name() {
  let v = "chapter_codes";
  return v;
}
async function firebase_storage_download_ebible_cache(fn, bible_folder, file_name) {
  async function get() {
    let v = await firebase_storage_download_ebible(bible_folder, file_name);
    return v;
  }
  let value = await global_function_property_initialize_async(fn, bible_folder, get);
  return value;
}
async function firebase_storage_download_ebible(en, file_name) {
  let destination = ebible_firebase_upload_path(en, file_name);
  let o = await firebase_storage_download_json(destination);
  return o;
}
function ebible_firebase_upload_path(bible_folder, file_name) {
  let file_name_with_extension = ebible_firebase_upload_path_name(file_name);
  let joined = list_join_slash_forward(["bible", bible_folder]);
  let destination = list_join_slash_forward([joined, file_name_with_extension]);
  return destination;
}
function ebible_firebase_upload_path_name(file_name) {
  let file_name2 = file_name_json(file_name);
  return file_name2;
}
async function ebible_books_to_chapter_codes(books, bible_folder) {
  async function lambda2(la) {
    await each_async(books, lambda);
    async function lambda(book) {
      let book_code = property_get(book, "book_code");
      let chapters = await ebible_chapters(bible_folder, book_code);
      la(chapters);
    }
  }
  let list = await list_adder_multiple_async(lambda2);
  return list;
}
async function list_adder_multiple_async(lambda$la) {
  let fn = list_add_multiple;
  let list = await list_adder_generic_async(lambda$la, fn);
  return list;
}
async function list_adder_generic_async(lambda, fn) {
  let list = [];
  function list_adder_inner(item) {
    fn(list, item);
  }
  await lambda(list_adder_inner);
  return list;
}
async function ebible_chapters(bible_folder, book_code) {
  let joined = ebible_version_download_path_combine(bible_folder, book_code);
  let {d, root} = await html_parse_read(joined);
  let filtered = html_parse_find_a_href_starts_with(root, d, book_code);
  function lambda(item) {
    let combined = book_code + item + ".";
    return combined;
  }
  let prefixes = list_map(["00", "000"], lambda);
  let chapters = list_filter_starts_with_not_multiple(filtered, prefixes);
  function lambda2(item2) {
    let without = text_suffix_without(item2, ".htm");
    return without;
  }
  let mapped = list_map(chapters, lambda2);
  return mapped;
}
function ebible_version_download_path_combine(bible_folder, book_code) {
  let chapters_name = book_code + ".htm";
  let file_path = ebible_version_download_path(bible_folder);
  let joined = path_join([file_path, chapters_name]);
  return joined;
}
function ebible_version_download_path(bible_folder) {
  let joined2 = local_function_path(ebible_version_download, bible_folder);
  return joined2;
}
async function ebible_version_download(bible_folder) {
  let url = ebible_version_download_url_html(bible_folder);
  let buffer = await http_local(url);
  let file_path = ebible_version_download_path(bible_folder);
  await unzip(file_path, buffer);
  return file_path;
}
function ebible_version_download_url_html(bible_folder) {
  let v = ebible_version_download_url(bible_folder, "html");
  return v;
}
function ebible_version_download_url(bible_folder, name) {
  let v = "https://ebible.org/Scriptures/" + bible_folder + "_" + name + ".zip";
  return v;
}
async function unzip(file_path, buffer) {
  const AdmZip = (await import_install("adm-zip")).default;
  const zip = new AdmZip(buffer);
  zip.extractAllTo(file_path, true);
}
async function http_local(url) {
  let key_get = function lambda() {
    let joined = http_local_file_name(url);
    return joined;
  };
  let cached_exists = file_exists;
  let cached_get = file_read_buffer;
  let value_get = async function lambda2() {
    let v = await http_firebase(url);
    return v;
  };
  let cache_save = file_write_buffer;
  let result = await cache_generic(key_get, cached_exists, cached_get, value_get, cache_save);
  return result;
}
async function file_write_buffer(f_path, contents) {
  await file_write_generic(f_path, file_overwrite_buffer, contents);
}
async function file_overwrite_buffer(file_path, contents) {
  let fs = await import("fs");
  await file_parent_exists_ensure(file_path);
  await fs.promises.writeFile(file_path, contents);
}
async function file_read_buffer(file_path) {
  let fs = await import("fs");
  let v = await fs.promises.readFile(file_path);
  return v;
}
function http_local_file_name(url) {
  let file_name = http_firebase_file_name(url);
  let fn = http_local;
  let joined = local_function_path(fn, file_name);
  return joined;
}
function local_function_path(fn, file_name) {
  let joined2 = path_join(["D:\\user\\storage\\function", fn.name, file_name]);
  return joined2;
}
function http_firebase_file_name(url) {
  let safe = text_base64_to(url);
  return safe;
}
function text_base64_to(s) {
  let b = browser_is();
  if (b) {
    const b64 = btoa(s);
    return b64;
  }
  const b64node = Buffer.from(s, "utf-8").toString("base64");
  return b64node;
}
async function http_firebase(url) {
  let key_get = function lambda() {
    let joined = http_firebase_file_path(url);
    return joined;
  };
  let cached_exists = firebase_storage_exists;
  let cached_get = firebase_storage_download;
  let value_get = async function lambda2() {
    let v = await http(url);
    return v;
  };
  async function cache_save(key, value) {
    await firebase_upload_buffer(value, key);
  }
  let result = await cache_generic(key_get, cached_exists, cached_get, value_get, cache_save);
  return result;
}
async function firebase_upload_buffer(content, destination) {
  let buffer = Buffer.from(content);
  const settings = {
    contentType: "application/octet-stream",
    resumable: false
  };
  await firebase_upload_generic(destination, settings, buffer);
  return destination;
}
async function firebase_upload_generic(destination, settings, buffer) {
  let bucket = null;
  let file = null;
  ({bucket, file, destination} = await firebase_bucket_file_get(destination));
  let merged = object_merge({
    metadata: {
      cacheControl: "no-cache"
    }
  }, settings);
  await retry_standard(lambda);
  log_keep(`Uploaded data to ${destination}`);
  const url = `https://storage.googleapis.com/${bucket.name}/${file.name}`;
  log_keep("Accessible at:" + url);
  async function lambda() {
    await file.save(buffer, merged);
  }
}
async function firebase_bucket_file_get(destination) {
  destination = firebase_path_fix(destination);
  const bucket = await firebase_bucket();
  const file = bucket.file(destination);
  let v = {
    bucket,
    file,
    destination
  };
  return v;
}
async function retry_standard(lambda) {
  await retry(5, lambda);
}
async function retry(count, lambda) {
  let wait = 1000;
  let result = null;
  let success = false;
  async function lambda3(la) {
    async function lambda2() {
      try {
        result = await lambda();
        success = true;
        return success;
      } catch (e) {
        log_keep({
          e
        });
        la(e);
        await sleep(wait);
        wait *= 2;
      }
    }
    await each_range_async(count, lambda2);
  }
  let errors = await list_adder_async(lambda3);
  if (success) {
    return result;
  }
  error_json({
    errors
  });
}
async function each_range_async(count, lambda) {
  let r = range(count);
  await each_async(r, lambda);
}
function range(count) {
  let r = [];
  for (let i = 0; i < count; i++) {
    list_add(r, i);
  }
  return r;
}
async function cache_generic(key_get, cached_exists, cached_get, value_get, cache_save) {
  let key = await key_get();
  let e = await cached_exists(key);
  let result = null;
  if (e) {
    result = await cached_get(key);
  } else {
    let value = await value_get();
    await cache_save(key, value);
    result = await cached_get(key);
  }
  return result;
}
function http_firebase_file_path(url) {
  let file_name = http_firebase_file_name(url);
  let joined = path_join(["http", file_name]);
  joined = firebase_path_fix(joined);
  return joined;
}
async function firebase_storage_exists(path) {
  path = firebase_path_fix(path);
  const bucket = await firebase_bucket();
  const file = bucket.file(path);
  let exists = null;
  try {
    const [e] = await file.exists();
    exists = e;
  } catch (err) {
    error(err);
    exists = false;
  }
  return exists;
}
function html_parse_find_a_href_starts_with(root, d, prefix) {
  let mapped = html_parse_find_a_href_text(root, d);
  let mapped2 = list_map_property(mapped, "href");
  let filtered2 = list_filter(mapped2, text_is);
  let filtered = list_filter_starts_with(filtered2, prefix);
  return filtered;
}
function html_parse_find_a_href_text(root, d) {
  let list = html_parse_find_a_list_to(root);
  let mapped = html_parse_href_text_map(d, list);
  return mapped;
}
function html_parse_href_text_map(d, list) {
  function lambda(item) {
    let both = html_parse_href_text(d, item);
    return both;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function html_parse_href_text(d, item) {
  let text = html_parse_text(d, item);
  let href = html_parse_href(d, item);
  let both = {
    text,
    href
  };
  return both;
}
function html_parse_href(d, item) {
  const name = "href";
  let href = html_parse_attr(d, item, name);
  href = text_is_if_or_null(href);
  return href;
}
function text_is_if_or_null(href) {
  let n = text_not_is(href);
  if (n) {
    href = null;
  }
  return href;
}
function text_not_is(href) {
  let ti = text_is(href);
  let n = not(ti);
  return n;
}
function html_parse_attr(d, item, name) {
  let v = d(item).attr(name);
  return v;
}
function html_parse_text(d, item) {
  let text = d(item).text();
  return text;
}
function html_parse_find_a_list_to(root) {
  let list = html_parse_find_list_to(root, "a");
  return list;
}
function html_parse_find_list_to(bl, selector) {
  let query = html_parse_find(bl, selector);
  let list = html_parse_list_to(query);
  return list;
}
function html_parse_list_to(query) {
  let v = query.get();
  return v;
}
function html_parse_find(root, selector) {
  let result = root.find(selector);
  return result;
}
function list_filter_starts_with_not_multiple(mapped, prefixes) {
  function lambda(item) {
    function lambda2(prefix) {
      let sw = text_starts_with_not(item, prefix);
      return sw;
    }
    let v = list_all(prefixes, lambda2);
    return v;
  }
  let filtered = list_filter(mapped, lambda);
  return filtered;
}
async function html_parse_read(file_path) {
  let contents = await file_read(file_path);
  let parsed = await html_parse(contents);
  return parsed;
}
async function html_parse(contents) {
  let cheerio = await import_install("cheerio");
  let d = cheerio.load(contents);
  let root = d("html");
  let result = {
    d,
    root
  };
  return result;
}
async function ebible_version_books(bible_folder) {
  let right = ebible_language_original_code();
  if (equal(bible_folder, right)) {
    let bible_folder2 = ebible_folder_english();
    let r = await ebible_version_books(bible_folder2);
    return r;
  }
  let b = browser_is();
  if (b) {
    let file_name = ebible_version_books_upload_name();
    let v = await firebase_storage_download_ebible_cache(ebible_version_books, bible_folder, file_name);
    let books = property_get(v, "books");
    return books;
  }
  const n = ebible_class_new();
  let o = ebible_class_old();
  let a = ebible_class_apocrypha();
  let classes = list_join_comma_space([o, a, n]);
  let books = await ebible_version_books_testament(bible_folder, classes);
  return books;
}
function ebible_folder_english() {
  let e = "engbsb";
  return e;
}
function ebible_language_original_code() {
  let v2 = "original";
  return v2;
}
function ebible_version_books_upload_name() {
  let v = "books";
  return v;
}
function ebible_class_apocrypha() {
  let v = ".aa";
  return v;
}
async function ebible_version_books_testament(bible_folder, selector) {
  let file_path = await ebible_version_download(bible_folder);
  let joined = path_join([file_path, "index.htm"]);
  let {d, root} = await html_parse_read(joined);
  let bl = html_parse_find(root, ".bookList");
  let mapped = html_parse_find_list_href_text(bl, selector, d);
  function lambda(item) {
    let href = property_get(item, "href");
    let taken = ebible_chapter_code_to_book(href);
    let to = object_merge({
      book_code: taken
    }, item);
    return to;
  }
  let mapped2 = list_map(mapped, lambda);
  return mapped2;
}
function html_parse_find_list_href_text(bl, selector, d) {
  let list = html_parse_find_list_to(bl, selector);
  let mapped = html_parse_href_text_map(d, list);
  return mapped;
}
function ebible_class_old() {
  let v = ".oo";
  return v;
}
function ebible_class_new() {
  let v = ".nn";
  return v;
}
function app_bible_chapter_open(context, hash, chapter_code) {
  app_bible_chapter_set(hash, chapter_code);
  const scroll_top_key = app_bible_hash_key_scroll_top();
  html_hash_object_property_set(scroll_top_key, 0);
  let screen_home = property_get(context, "screen_home");
  app_shared_screen_set(context, screen_home);
}
function app_shared_screen_set(context, fn) {
  let fn_name = property_get(fn, "name");
  app_shared_refresh_screen(context, fn_name);
}
function app_shared_refresh_screen(context, without) {
  storage_local_set_context(context, "screen", without);
  app_shared_refresh(context);
}
function storage_local_set_context(context, key, value) {
  let {app_fn} = context;
  storage_local_set(app_fn, key, value);
}
function app_bible_chapter_set(hash, chapter_code) {
  property_set(hash, "c", chapter_code);
  html_hash_set_object(hash);
}
function html_div_text_centered(root, text) {
  let div = html_div_text(root, text);
  html_centered(div);
  return div;
}
async function app_bible_books(context) {
  let root = html_clear_context(context);
  let e = ebible_folder_english();
  let books = await ebible_version_books(e);
  let hash = html_hash_object_get();
  function lambda(item) {
    let book_code = property_get(item, "book_code");
    let text = property_get(item, "text");
    function lambda3() {
      let chapter_code = ebible_chapter_code_pad(book_code, "1");
      app_bible_chapter_set(hash, chapter_code);
      app_shared_screen_set(context, app_bible_chapters);
    }
    let component = html_button(root, text, lambda3);
  }
  each(books, lambda);
  log({
    books
  });
}
function ebible_chapter_code_pad(book_code, chapter_name) {
  let pad_count = 2;
  if (equal(book_code, "PSA")) {
    pad_count = 3;
  }
  let chapter_padded = number_pad(chapter_name, pad_count);
  let chapter_code = book_code + chapter_padded;
  return chapter_code;
}
function number_pad(num, count) {
  let v = String(num).padStart(count, "0");
  return v;
}
function list_previous_wrap(list, item) {
  let previous = null;
  let li = list_first_is(list, item);
  let result = null;
  if (li) {
    result = list_last(list);
  } else {
    result = list_previous(list, item);
  }
  previous = result;
  return previous;
}
function list_previous(list, item) {
  let index_previous = list_index_of_previous(list, item);
  let previous = list_get(list, index_previous);
  return previous;
}
function list_index_of_previous(list, item) {
  const delta = -1;
  const index_previous = list_index_of_delta(list, item, delta);
  return index_previous;
}
function list_index_of_delta(list, item, delta) {
  let index_next = list_index_of_delta_outside(list, item, delta);
  let ii = list_index_is(list, index_next);
  if (not(ii)) {
    let v = null;
    return v;
  }
  return index_next;
}
function list_index_of_delta_outside(list, item, delta) {
  let index = list_index_of(list, item);
  let index_next = index + delta;
  return index_next;
}
function list_index_is(list, index) {
  assert_arguments(arguments, 2);
  let e = list_empty_is(list);
  let v = false;
  if (e) {
    return v;
  }
  if (index < 0) {
    return v;
  }
  let index_last = list_index_last(list);
  if (index > index_last) {
    return v;
  }
  let ii = true;
  return ii;
}
function list_first_is(list, item) {
  let f = list_first(list);
  let fi = f === item;
  return fi;
}
function emoji_arrow_left() {
  let v = "â¬…ï¸";
  return v;
}
function list_next_wrap(list, item) {
  let next = null;
  let li = list_last_is(list, item);
  let result = null;
  if (li) {
    result = list_first(list);
  } else {
    result = list_next(list, item);
  }
  next = result;
  return next;
}
function list_next(list, item) {
  let index_next = list_index_of_next(list, item);
  let next = list_get(list, index_next);
  return next;
}
function list_index_of_next(list, item) {
  const delta = 1;
  let index_next = list_index_of_delta(list, item, delta);
  return index_next;
}
function list_last_is(list, item) {
  let last = list_last(list);
  let li = last === item;
  return li;
}
function emoji_arrow_right() {
  let e = "âž¡ï¸";
  return e;
}
async function ebible_verses(bible_folder, chapter_code) {
  if (browser_is()) {
    let verses = await ebible_verses_browser(bible_folder, chapter_code);
    return verses;
  }
  let v2 = await ebible_chapter_text(bible_folder, chapter_code);
  let property = "text";
  let text = property_get(v2, property);
  let verse_numbers = property_get(v2, "verse_numbers");
  text = whitespace_normalize(text);
  text = urdu_allah_to_god(text);
  let split = text_split_space(text);
  let filtered = list_filter(split, text_empty_not_is);
  function lambda_list_adder(la) {
    function lambda_each_reverse(nn, nn_next) {
      let name = property_get(nn, "name");
      let number = property_get(nn, "number");
      let index = list_index_of_last(filtered, name);
      if (null_not_is(nn_next)) {
        let name_next = property_get(nn_next, "name");
        let filtered3 = list_take(filtered, index);
        let index_next = list_index_of_last(filtered3, name_next);
        let r = list_index_of_all(filtered, name);
        function lambda2(item2) {
          let g = greater_than(item2, index_next);
          return g;
        }
        let filtered4 = list_filter(r, lambda2);
        index = list_first(filtered4);
      }
      let skipped = list_skip(filtered, index + 1);
      const v = ebible_verse_new(skipped, number);
      la(v);
      filtered = list_take(filtered, index);
    }
    each_next_reverse(verse_numbers, lambda_each_reverse);
  }
  let verses_unfiltered = list_adder(lambda_list_adder);
  let ne = list_empty_not_is(filtered);
  if (ne) {
    let verse_number = ebible_verses_before();
    const v = ebible_verse_new(filtered, verse_number);
    list_add(verses_unfiltered, v);
  }
  list_reverse(verses_unfiltered);
  function lambda3(item) {
    let value = property_get(item, property);
    let replaced = text_replace(value, "[]", "");
    let n = text_empty_not_is(replaced);
    return n;
  }
  let verses = list_filter(verses_unfiltered, lambda3);
  return verses;
}
function each_next_reverse(list, lambda$item$next) {
  let reversed = list_copy_reverse(list);
  let v = each_next(reversed, lambda$item$next);
  return v;
}
function list_copy_reverse(previous) {
  let copy = list_copy(previous);
  list_reverse(copy);
  return copy;
}
function list_reverse(list) {
  list.reverse();
}
function list_index_of_all(list, search) {
  function lambda(value, item, index) {
    if (item === search) {
      list_add(value, index);
    }
    return value;
  }
  let indices = list_reduce_index(list, lambda, []);
  return indices;
}
function list_reduce_index(list, lambda$value$item$index, inital) {
  let value = inital;
  function lambda2(item, index) {
    value = lambda$value$item$index(value, item, index);
  }
  each_index(list, lambda2);
  return value;
}
function list_index_of_last(list, item) {
  let index = list_index_of_last_try(list, item);
  if (index <= -1) {
    error_json({
      list,
      item,
      index
    });
  }
  return index;
}
function list_index_of_last_try(list, item) {
  let v = list.lastIndexOf(item);
  return v;
}
function ebible_verses_before() {
  let v3 = "0";
  return v3;
}
async function ebible_verses_browser(bible_folder, chapter_code) {
  async function get() {
    let destination = ebible_firebase_upload_path(bible_folder, chapter_code);
    let c = await firebase_storage_download_json_decompress(destination);
    let verses = property_get(c, "verses");
    return verses;
  }
  let value = await global_function_call_cache_async(ebible_verses_browser, arguments, get);
  return value;
}
async function global_function_call_cache_async(fn, args, lambda) {
  let args_list = list_to(args);
  let json = json_to(args_list);
  let value = await global_function_property_initialize_async(fn, json, lambda);
  return value;
}
function urdu_allah_to_god(text) {
  let v = text.replace(/Ø§\s*Ù„\s*Ù„[\u0651\u0670]*[ÛÙ‡]|Ø§Ù„Ù„Ù‡/g, "Ø®Ø¯Ø§");
  return v;
}
function ebible_verse_new(tokens, verse_number) {
  let joined = list_join_space(tokens);
  const v = ebible_verse_new_text(joined, verse_number);
  return v;
}
function ebible_verse_new_text(text, verse_number) {
  let v2 = {
    verse_number,
    text
  };
  return v2;
}
function list_join_space(list) {
  let joined = list_join(list, " ");
  return joined;
}
function list_take(list, count) {
  let taken = list_slice(list, 0, count);
  return taken;
}
function whitespace_normalize(s) {
  let n = s.replace(/\s+/g, " ").trim();
  return n;
}
async function ebible_chapter_text(bible_folder, chapter_code) {
  let chapter_path = ebible_version_download_path_combine(bible_folder, chapter_code);
  let v2 = await html_parse_read(chapter_path);
  let root = property_get(v2, "root");
  let d = property_get(v2, "d");
  let main = html_parse_find(root, ".main");
  let list = html_parse_find_list_to(main, ".verse");
  let verse_numbers = list_map(list, lambda2);
  function lambda2(item2) {
    let t = html_parse_text(d, item2);
    const name = "id";
    let id = html_parse_attr(d, item2, name);
    let without = text_prefix_without(id, "V");
    let i = roman_to_integer(without);
    let n = whitespace_normalize(t);
    let v4 = {
      number: i,
      name: n
    };
    return v4;
  }
  let classes = html_parse_descendants_classes(main, d);
  let include = ebible_verses_include();
  let exclude = ebible_verses_exclude();
  list_intersect_empty_is_assert(include, exclude);
  let list2 = list_difference(classes, include);
  let extra = list_difference(list2, exclude);
  let dictionary = html_parse_classes_preview(main, d, extra);
  list_empty_is_assert_json(extra, {
    extra,
    dictionary
  });
  function lambda(item) {
    let selector2 = css_class_prefix_combine(item);
    html_parse_find_remove(main, selector2);
  }
  each(exclude, lambda);
  let text = html_parse_text(d, main);
  let result = {
    verse_numbers,
    text
  };
  return result;
}
function roman_to_integer(input) {
  function unicodeToAscii(roman) {
    const map = {
      â… : "I",
      â…¡: "II",
      â…¢: "III",
      â…£: "IV",
      â…¤: "V",
      â…¥: "VI",
      â…¦: "VII",
      â…§: "VIII",
      â…¨: "IX",
      â…©: "X",
      â…ª: "XI",
      â…«: "XII",
      â…¬: "L",
      â…­: "C",
      â…®: "D",
      â…¯: "M"
    };
    function lambda(ch) {
      let v = map[ch] ?? ch;
      return v;
    }
    let v3 = roman.split("").map(lambda).join("");
    return v3;
  }
  function romanToInt(roman) {
    const values = {
      I: 1,
      V: 5,
      X: 10,
      L: 50,
      C: 100,
      D: 500,
      M: 1000
    };
    let total = 0;
    for (let i = 0; i < roman.length; i++) {
      const v1 = values[roman[i]];
      const v2 = values[roman[i + 1]] || 0;
      total += v1 < v2 ? -v1 : v1;
    }
    return total;
  }
  function parseRomanOrInteger(input) {
    const match = input.match(/^([â… â…¡â…¢â…£â…¤â…¥â…¦â…§â…¨â…©â…ªâ…«â…¬â…­â…®â…¯IVXLCDM]+)([a-zA-Z]*)$/);
    if (not(match)) {
      return input;
    }
    const romanPart = match[1];
    const suffix = match[2] || "";
    const asciiRoman = unicodeToAscii(romanPart);
    let v5 = romanToInt(asciiRoman) + suffix;
    return v5;
  }
  let v6 = parseRomanOrInteger(input);
  return v6;
}
function html_parse_find_remove(main, selector) {
  let result = html_parse_find(main, selector);
  result.remove();
}
function css_class_prefix_combine(item) {
  let v = "." + item;
  return v;
}
function list_empty_is_assert_json(list, json) {
  let e = list_empty_is(list);
  assert_json(e, {
    list,
    json
  });
}
function html_parse_classes_preview(main, d, classes) {
  function lambda(c) {
    let e = html_parse_find(main, "." + c);
    let text = html_parse_text(d, e);
    return text;
  }
  let dictionary = list_to_dictionary_value(classes, lambda);
  return dictionary;
}
function list_intersect_empty_is_assert(include, exclude) {
  let i = list_intersect(include, exclude);
  list_empty_is_assert_json(i, {
    include,
    exclude
  });
}
function ebible_verses_exclude() {
  let v = ["b", "bdit", "cd", "chapterlabel", "copyright", "f", "fq", "fqa", "fr", "footnote", "fl", "fm", "ft", "fv", "ie", "iex", "ili", "im", "imi", "imt", "io", "ior", "iot", "io2", "ip", "ipi", "is", "k", "mt", "mt3", "mt4", "mr", "ms", "ms2", "mt2", "no", "notebackref", "notemark", "ord", "popup", "qa", "qac", "r", "rq", "s", "s2", "s3", "s4", "sig", "sp", "sr", "sup", "tl", "tnav", "x", "xo", "xt"];
  return v;
}
function ebible_verses_include() {
  let v = ["add", "bd", "bk", "char", "d", "em", "fk", "it", "lf", "lh", "li", "li2", "li3", "li4", "lim", "m", "mi", "nb", "nd", "p", "pi", "pi2", "pi3", "pc", "pm", "pmc", "pmo", "pmr", "pn", "po", "pr", "sc", "sls", "q", "q2", "q3", "q4", "qc", "qd", "qm", "qm2", "qr", "qs", "qt", "verse", "wj"];
  return v;
}
function html_parse_descendants_classes(item, d) {
  let descendants = html_parse_find_list_to(item, "*");
  function lambda2(la) {
    function lambda(item) {
      let c = html_parse_attr(d, item, "class");
      if (text_is(c)) {
        let split = text_split(c, " ");
        each(split, la);
      }
    }
    each(descendants, lambda);
  }
  let list = list_adder(lambda2);
  let classes = list_unique(list);
  list_sort_text(classes);
  return classes;
}
function html_bar_content_padded(root) {
  let bc = html_bar_content(root);
  let content = property_get(bc, "content");
  html_bar_content_padding(content);
  return bc;
}
function html_bar_content(root) {
  let shell = html_div(root);
  html_style_assign(shell, {
    display: "flex",
    "flex-direction": "column",
    height: "100dvh",
    "box-sizing": "border-box"
  });
  let bar = html_div(shell);
  html_style_assign(bar, {
    flex: "0 0 auto"
  });
  let content = html_div(shell);
  html_style_assign(content, {
    flex: "1 1 auto",
    "min-height": "0",
    position: "relative",
    "overflow-y": "scroll",
    "overflow-x": "auto"
  });
  let v = {
    bar,
    content
  };
  return v;
}
function html_bar_content_padding(content) {
  html_style_padding_x(content, "5dvw");
}
function html_style_padding_x(component, value) {
  html_style_assign(component, {
    "padding-left": value,
    "padding-right": value
  });
}
function html_on_scroll(container, update) {
  html_on(container, "scroll", update);
}
function list_max(list) {
  function lambda(a, b) {
    let v = a > b ? a : b;
    return v;
  }
  const max = list.reduce(lambda, -Infinity);
  return max;
}
function reduce(start, list, lambda$before$current) {
  let reduced = start;
  function lambda(current) {
    reduced = lambda$before$current(reduced, current);
  }
  each(list, lambda);
  return reduced;
}
function app_original_bible_screens() {
  let screens = [app_original_bible_home, app_bible_books, app_bible_chapters, app_bible_languages];
  return screens;
}
function app_bible_languages(context) {
  let root = html_clear_context(context);
  let languages = ebible_languages();
  let key = "languages_chosen";
  let n = storage_local_exists_not_context(context, key);
  if (n) {
    let en_l = ebible_language_en();
    let languages_chosen_default = [en_l];
    storage_local_set_context(context, key, languages_chosen_default);
  }
  let languages_chosen = storage_local_get_context(context, key);
  function lambda() {
    storage_local_set_context(context, key, languages_chosen);
  }
  app_reply_buttons_languages_on_toggle(languages_chosen, lambda, root, languages);
}
function app_reply_buttons_languages_on_toggle(languages_chosen, on_toggle, root, languages) {
  function lambda(language) {
    let name = property_get(language, "name");
    let component = null;
    function on_click() {
      list_toggle(languages_chosen, language);
      html_style_background_color_set_or_remove_list(component, languages_chosen, language);
      on_toggle();
    }
    component = html_button(root, name, on_click);
    html_style_background_color_set_or_remove_list(component, languages_chosen, language);
  }
  each(languages, lambda);
}
function storage_local_get_context(context, key) {
  let app_fn = property_get(context, "app_fn");
  let value = storage_local_get(app_fn, key);
  return value;
}
function ebible_language_en() {
  let v2 = {
    name: ebible_language_en_name(),
    bible_folder: ebible_folder_english(),
    language_code: ebible_language_en_code()
  };
  return v2;
}
function ebible_language_en_code() {
  let v = "en";
  return v;
}
function ebible_language_en_name() {
  let v2 = "English";
  return v2;
}
function storage_local_exists_not_context(context, key) {
  let app_fn = property_get(context, "app_fn");
  let exists = storage_local_exists_not(app_fn, key);
  return exists;
}
function storage_local_exists_not(app_fn, key) {
  let exists = storage_local_exists(app_fn, key);
  return exists;
}
function ebible_languages() {
  "to add an entry, run: " + fn_name("ebible_languages_add");
  let en = ebible_language_en();
  let o = ebible_language_original();
  let languages = [o, en, {
    name: "Urdu",
    bible_folder: ebible_folder_urdu(),
    language_code: "ur"
  }, {
    name: "Swahili",
    bible_folder: ebible_folder_swahili(),
    language_code: "swh"
  }, {
    name: "Luganda",
    bible_folder: "lug",
    language_code: "lug"
  }, {
    name: "Bengali",
    bible_folder: "benirv",
    language_code: "ben"
  }, {
    name: "Telugu",
    bible_folder: "tel2017",
    language_code: "tel"
  }, {
    name: "Hindi",
    bible_folder: "hin2017",
    language_code: "hin"
  }, {
    name: "Arabic",
    bible_folder: "arbnav",
    language_code: "arb"
  }, {
    name: "Ekegusii",
    bible_folder: "guz",
    language_code: "guz"
  }, {
    name: "Cebuano",
    bible_folder: ebible_folder_cebuano(),
    language_code: "ceb"
  }, {
    name: "Tagalog",
    bible_folder: "tglulb",
    language_code: "tgl"
  }, {
    name: "Spanish",
    bible_folder: "spablm",
    language_code: "es"
  }, {
    name: "French",
    bible_folder: "frasbl",
    language_code: "fr"
  }, {
    name: "Amharic",
    bible_folder: "amh",
    language_code: "am"
  }, {
    name: "Chinese (Simplified)",
    bible_folder: "cmn-cu89s",
    language_code: "zh"
  }, {
    name: "Dutch",
    bible_folder: "nldnbg",
    language_code: "nl"
  }, {
    name: "Igbo",
    bible_folder: "ibo",
    language_code: "ig"
  }, {
    name: "Hausa",
    bible_folder: "hausa",
    language_code: "ha"
  }, {
    name: "Yoruba",
    bible_folder: "yor",
    language_code: "yor"
  }, {
    name: "Punjabi",
    bible_folder: "pan",
    language_code: "pa"
  }, {
    name: "Chichewa",
    bible_folder: "nya",
    language_code: "ny"
  }, {
    name: "Portuguese",
    bible_folder: "porbrbsl",
    language_code: "pt"
  }, {
    name: "Wolof",
    bible_folder: "wolmbs",
    language_code: "wo"
  }, {
    name: "Gujarati",
    bible_folder: "guj2017",
    language_code: "gu"
  }, {
    name: "Afaan Oromoo",
    bible_folder: "gaz",
    language_code: "om"
  }, {
    name: "Persian",
    bible_folder: "pesopcb",
    language_code: "fas"
  }, {
    name: "Turkish",
    bible_folder: "turytc",
    language_code: "tr"
  }, {
    name: "Oriya",
    bible_folder: "ory",
    language_code: "or"
  }, {
    name: "Marathi",
    bible_folder: "mar",
    language_code: "mr"
  }, {
    name: "Kannada",
    bible_folder: "kanirv",
    language_code: "kn"
  }];
  "if you modify the above list, then run:";
  ebible_languages_chapters_cache_refresh.name;
  list_sort_text_property(languages, "name");
  return languages;
}
function ebible_folder_cebuano() {
  let c = "cebulb";
  return c;
}
function list_sort_text_property(languages, property_name) {
  let f = property_get_curried_right(property_name);
  list_sort_text_mapper(languages, f);
}
function ebible_language_original() {
  let v = {
    name: ebible_language_original_name(),
    bible_folder: bible_interlinear_verses_upload_folder(),
    language_code: ebible_language_original_code()
  };
  return v;
}
function bible_interlinear_verses_upload_folder() {
  let v = "original";
  return v;
}
function ebible_language_original_name() {
  let v = "Original";
  return v;
}
function ebible_folder_swahili() {
  let v = "swhonen";
  return v;
}
async function ebible_languages_chapters_cache_refresh() {
  await ebible_languages_chapters_cache_remove();
  let r = await ebible_languages_chapters_cache();
  return r;
}
async function ebible_languages_chapters_cache() {
  let v = await invoke_cache_file(ebible_languages_chapters, []);
  return v;
}
async function ebible_languages_chapters() {
  async function lambda(la) {
    await ebible_languages_english_each(chapters_get_add);
    async function chapters_get_add(bible_folder) {
      let chapters = await ebible_version_chapters_cache(bible_folder);
      la({
        bible_folder,
        chapters
      });
    }
    let i = await bible_interlinear_verses_cache();
    la(i);
  }
  let all = await list_adder_async(lambda);
  return all;
}
async function ebible_languages_english_each(lambda$bible_folder) {
  await ebible_languages_without_original_english_bible_folders_each(lambda$bible_folder);
  lambda$bible_folder("engbsb");
  return;
  await ebible_versions_english_choices_each(lambda$bible_folder);
}
async function ebible_languages_without_original_english_bible_folders_each(lambda$bible_folder) {
  let languages = ebible_languages_without_original_english();
  let index_next = null;
  if (false) {
    "this is used to start at a folder and keep going to resume after interruption";
    const property = "bible_folder";
    const including_and_onward = "porbrbsl";
    index_next = list_index_of_property(languages, property, including_and_onward);
  }
  async function lambda2(language, i) {
    if (i < index_next) {
      return;
    }
    let bible_folder = property_get(language, "bible_folder");
    await lambda$bible_folder(bible_folder);
  }
  await each_index_async(languages, lambda2);
}
function list_index_of_property(list, property, value) {
  let item = list_find_property(list, property, value);
  let index_next = list_index_of(list, item);
  return index_next;
}
async function each_index_async(list, lambda$item$index) {
  let index = 0;
  async function lambda2(item) {
    await lambda$item$index(item, index);
    index++;
  }
  await each_async(list, lambda2);
}
function ebible_languages_without_original_english() {
  let languages = ebible_languages_without_original();
  let e = ebible_language_en_code();
  list_remove_property(languages, "language_code", e);
  return languages;
}
function list_remove_property(languages, property_name, en) {
  let found = list_find_property(languages, property_name, en);
  list_remove(languages, found);
}
function ebible_languages_without_original() {
  let languages = ebible_languages();
  let original = bible_interlinear_verses_upload_folder();
  list_remove_property(languages, "language_code", original);
  return languages;
}
async function ebible_versions_english_choices_each(lambda$bible_folder) {
  let english_choices = await ebible_versions_english_choices();
  let index = list_index_of(english_choices, "eng-t4t");
  let skipped = list_skip(english_choices, index);
  skipped = english_choices;
  await each_async(skipped, lambda$bible_folder);
}
async function ebible_versions_english_choices() {
  if (browser_is()) {
    async function lambda() {
      let destination = ebible_versions_english_choices_upload_path();
      let choices = await firebase_storage_download_json(destination);
      return choices;
    }
    let english_choices = await global_function_initialize_lambda_async(ebible_versions_english_choices, lambda);
    return english_choices;
  }
  let object = await ebible_versions_english_full();
  let properties = properties_get(object);
  let excluded_prefixes = ["engweb", "eng-web"];
  let filter = function lambda4(property) {
    let any = list_any_starts_with_not(property, excluded_prefixes);
    return any;
  };
  let english_choices = list_filter(properties, filter);
  return english_choices;
}
function ebible_versions_english_choices_upload_path() {
  let file_name = "choices";
  let file_name_with_extension = file_name_json(file_name);
  let destination = list_join_slash_forward(["bibles", "en", file_name_with_extension]);
  return destination;
}
function list_any_starts_with_not(item, prefixes) {
  let b = list_any_starts_with(item, prefixes);
  let any = not(b);
  return any;
}
function list_any_starts_with(item, prefixes) {
  function lambda2(item2) {
    let sw = text_starts_with(item, item2);
    return sw;
  }
  let any = list_any(prefixes, lambda2);
  return any;
}
async function ebible_versions_english_full() {
  "full meaning all books of the bible, as oppose to versions that are missing books";
  let object = await ebible_versions_english_books_count_cache();
  const c = isaiah_chapters_count();
  let filter = function lambda3(value, key) {
    let v2 = value >= c;
    return v2;
  };
  function lambda(oad) {
    function lambda2(value, key) {
      if (filter(value, key)) {
        oad(key, value);
      }
    }
    each_object(object, lambda2);
  }
  let result = object_adder(lambda);
  return result;
}
function isaiah_chapters_count() {
  let v5 = 66;
  return v5;
}
async function ebible_versions_english_books_count_cache() {
  let v = await invoke_cache_file(ebible_versions_english_books_count, []);
  return v;
}
async function ebible_versions_english_books_count() {
  let downloadable = await ebible_versions_english_downloadable();
  let dictionary = await list_to_dictionary_unordered_async(downloadable, ebible_version_books_count);
  return dictionary;
}
async function ebible_version_books_count(bible_folder) {
  let list = await ebible_version_books(bible_folder);
  let size = list_size(list);
  return size;
}
async function ebible_versions_english_downloadable() {
  let bible_folders = await ebible_versions_english();
  let downloadable = await ebible_versions_downloadable_filter(bible_folders);
  return downloadable;
}
async function ebible_versions_downloadable_filter(bible_folders) {
  let v = await list_filter_try_async(bible_folders, ebible_version_download);
  return v;
}
async function list_filter_try_async(bible_folders, lambda) {
  async function lambda2(la) {
    async function lambda3(bible_folder) {
      try {
        await lambda(bible_folder);
        la(bible_folder);
      } catch (e) {}
    }
    await each_async(bible_folders, lambda3);
  }
  let list = await list_adder_async(lambda2);
  return list;
}
async function ebible_versions_english() {
  let v = await ebible_versions();
  let filtered = list_filter_starts_with(v, "eng");
  return filtered;
}
async function ebible_versions() {
  let url = ebible_url() + "download.php";
  let r = await http_local_html_parse(url);
  let root = property_get(r, "root");
  let d = property_get(r, "d");
  let prefix = ebible_url_details();
  let unique = html_parse_find_a_href_starts_with_without_unique(root, d, prefix);
  return unique;
}
function html_parse_find_a_href_starts_with_without_unique(root, d, prefix) {
  let list = html_parse_find_a_href_starts_with(root, d, prefix);
  let mapped = list_map_prefix_without(list, prefix);
  let unique = list_unique(mapped);
  list_sort_text(unique);
  return unique;
}
function ebible_url() {
  let r2 = "https://ebible.org/";
  return r2;
}
function ebible_url_details() {
  let r2 = "details.php?id=";
  return r2;
}
async function http_local_html_parse(url) {
  let text = await http_local_text(url);
  let r = await html_parse(text);
  return r;
}
async function http_local_text(url) {
  let buffer = await http_local(url);
  const text = buffer_text_to(buffer);
  return text;
}
async function list_to_dictionary_unordered_async(list, lambda$item) {
  let v = list_to_dictionary_generic_async(lambda$item);
  let dictionary = property_get(v, "dictionary");
  let lambda = property_get(v, "lambda");
  await list_map_unordered_async(list, lambda);
  return dictionary;
}
function list_to_dictionary_generic_async(lambda$item) {
  let dictionary = {};
  let lambda = async function lambda2(item) {
    let value = await lambda$item(item);
    property_set(dictionary, item, value);
  };
  let v = {
    lambda,
    dictionary
  };
  return v;
}
async function invoke_cache_file(fn, args) {
  let key_get = invoke_cache_file_key_get(fn, args);
  let value_get = invoke_cache_value_get(fn, args);
  let cached_exists = file_exists;
  let cached_get = async function lambda2(key) {
    let data = await file_read_json(key);
    let r = property_get(data, "result");
    return r;
  };
  let cache_save = async function lambda4(key, result) {
    await file_overwrite_json(key, {
      result
    });
  };
  let v = await cache_generic(key_get, cached_exists, cached_get, value_get, cache_save);
  return v;
}
function invoke_cache_file_key_get(fn, args) {
  let g = async function lambda() {
    let json = invoke_cache_key(fn, args);
    let tl = file_path_too_long(json);
    if (tl) {
      json = await text_to_uuid_cache(json);
    }
    log({
      json,
      tl
    });
    let safe = file_path_safe_to(json);
    let file_name = file_name_json(safe);
    let f_path = folder_user_storage_function_path(fn);
    let joined = path_join([f_path, file_name]);
    return joined;
  };
  return g;
}
async function text_to_uuid_cache(text) {
  let key_get = lambda_get(text);
  let value_get = null_get();
  let cached_exists = text_to_uuid_save_exists;
  let cached_get = text_to_uuid_save_get;
  let cache_save = async function lambda4(text, n) {
    await text_to_uuid_save(text);
  };
  let r = await cache_generic(key_get, cached_exists, cached_get, value_get, cache_save);
  return r;
}
async function text_to_uuid_save_get(text) {
  let get = await text_to_uuid_read_save();
  let id = property_get(get, text);
  return id;
}
async function text_to_uuid_read_save() {
  let data = await text_to_uuid_read();
  let save = text_to_uuid_save_initialize(data);
  return save;
}
function text_to_uuid_save_initialize(data) {
  let value = property_initialize(data, "save", {});
  return value;
}
async function text_to_uuid_read() {
  let joined = text_to_uuid_path();
  let initial = text_to_uuid_initial();
  let data = await file_read_json_initialize(joined, initial);
  return data;
}
async function file_read_json_initialize(f_path, initial) {
  await file_write_json_if_exists_not(f_path, initial);
  let data = await file_read_json(f_path);
  return data;
}
async function file_write_json_if_exists_not(f_path, initial) {
  let exists = await file_exists(f_path);
  if (not(exists)) {
    await file_write_json(f_path, initial);
  }
}
async function file_write_json(file_path, object) {
  let json = json_format_to_truncated(object);
  await file_write(file_path, json);
}
function text_to_uuid_initial() {
  let r = {};
  return r;
}
function text_to_uuid_path() {
  let file_name = file_name_json("data");
  let f_path = folder_user_storage_function_path(text_to_uuid_save);
  let joined = path_join([f_path, file_name]);
  return joined;
}
async function text_to_uuid_save(text) {
  let joined = text_to_uuid_path();
  let initial = text_to_uuid_initial();
  await file_json_transform_initialize(joined, initial, lambda);
  async function lambda(data) {
    let set = text_to_uuid_save_initialize(data);
    property_exists_not_assert(set, text);
    let get = text_to_uuid_ids_initialize(data);
    let u = await uuid();
    property_set(set, text, u);
    property_set(get, u, text);
  }
}
function text_to_uuid_ids_initialize(data) {
  let value = property_initialize(data, "ids", {});
  return value;
}
async function uuid() {
  if (browser_is()) {
    let v = crypto.randomUUID();
    return v;
  }
  const {v4: uuidv4} = await import_install("uuid");
  let u = uuidv4();
  return u;
}
async function file_json_transform_initialize(f_path, initial, lambda$data) {
  await file_write_json_if_exists_not(f_path, initial);
  await file_json_transform(f_path, lambda$data);
}
async function file_json_transform(f_path, lambda$data) {
  let data = await file_read_json(f_path);
  lambda$data(data);
  await file_overwrite_json(f_path, data);
}
function folder_user_storage_function_path(fn) {
  let p = folder_user_storage_function_path_function();
  let joined = path_join([p, fn.name]);
  return joined;
}
function folder_user_storage_function_path_function() {
  let p = folder_user_storage_path("function\\");
  return p;
}
function folder_user_storage_path(path) {
  const folder = "storage";
  let joined = folder_user_combine(folder, path);
  return joined;
}
function folder_user_combine(folder, file_path) {
  let result = folder_user(folder);
  let joined = path_join([result, file_path]);
  return joined;
}
function folder_user(folder) {
  let f = path_join(["D:\\user", folder]);
  return f;
}
async function text_to_uuid_save_exists(text) {
  let set = await text_to_uuid_read_save();
  let e = property_exists(set, text);
  return e;
}
function null_get() {
  let r = lambda_get(null);
  return r;
}
function file_path_too_long(path) {
  let tl = Buffer.byteLength(path, "utf8") > 240;
  return tl;
}
function file_path_safe_to(fp) {
  let safe = encodeURIComponent(fp);
  return safe;
}
function invoke_cache_key(fn, args) {
  let name = property_get(fn, "name");
  let j = json_to([name, args]);
  return j;
}
function invoke_cache_value_get(fn, args) {
  let v3 = async function lambda() {
    let v = await fn(...args);
    return v;
  };
  return v3;
}
async function bible_interlinear_verses_cache() {
  let v = await invoke_cache_file(bible_interlinear_verses, []);
  return v;
}
async function bible_interlinear_verses() {
  let chapters_i = await bible_interlinear_chapters();
  let bible_folder = bible_interlinear_verses_upload_folder();
  async function lambda(la) {
    async function lambda6(verses, chapter_code) {
      la({
        chapter_code,
        verses
      });
    }
    await object_map_async(chapters_i, lambda6);
  }
  let chapters = await list_adder_async(lambda);
  let v = {
    bible_folder,
    chapters
  };
  return v;
}
async function object_map_async(object, lambda$value$key) {
  let each_lambda = each_async;
  await object_map_generic_async(object, lambda$value$key, each_lambda);
}
async function object_map_generic_async(object, lambda, mapper_lambda) {
  async function lambda2(property) {
    let value = property_get(object, property);
    await lambda(value, property);
  }
  let properties = properties_get(object);
  let mapped = await mapper_lambda(properties, lambda2);
  return mapped;
}
async function bible_interlinear_chapters() {
  let bible_folder = bible_interlinear_verses_upload_folder();
  let books = await ebible_version_books("engbsb");
  let path_output = bible_interlinear_json_path();
  let words = await file_read_json(path_output);
  const vid_property = "Verse";
  let verses = list_to_lookup(words, vid_property);
  let sorts = ["Heb Sort", "Greek Sort"];
  let chapters = {};
  async function lambda(verse_words, v_number) {
    let first = list_first(verse_words);
    let vid = property_get(first, "VerseId");
    function lambda3(sort) {
      function lambda2(item) {
        let value = property_get(item, sort);
        return value;
      }
      list_sort_number_mapper(verse_words, lambda2);
    }
    each(sorts, lambda3);
    let original_property = "WLC / Nestle Base TR RP WH NE NA SBL";
    function lambda4(item2) {
      let exists = property_exists(item2, original_property);
      return exists;
    }
    let filtered = list_filter(verse_words, lambda4);
    let mapped = list_map_property(filtered, original_property);
    let text = list_join_space(mapped);
    let v = ebible_references_names(books, [vid]);
    let chapter_verses_list = property_get(v, "chapter_verses_list");
    let book_names = property_get(v, "book_names");
    let bn = list_single(book_names);
    let cv = list_single(chapter_verses_list);
    let v2 = ebible_reference_parts(books, bn, cv);
    let verse_end = property_get(v2, "verse_end");
    let verse_start = property_get(v2, "verse_start");
    let chapter_code = property_get(v2, "chapter_code");
    let index = property_get(v2, "index");
    equal_assert(verse_start, verse_end);
    let verse = {
      verse_number: verse_start,
      text
    };
    let chapter_verses = property_initialize_list(chapters, chapter_code);
    list_add(chapter_verses, verse);
  }
  each_object(verses, lambda);
  return chapters;
}
function ebible_reference_parts(books, book_name, chapter_verses) {
  let book = list_find_property(books, "text", book_name);
  let book_code = property_get(book, "book_code");
  let split2 = text_split_colon(chapter_verses);
  let v2 = list_first_second(split2);
  let second = property_get(v2, "second");
  let chapter_name = property_get(v2, "first");
  let chapter_code = ebible_chapter_code_pad(book_code, chapter_name);
  let verse_range = text_split_dash(second);
  let verse_start = list_first(verse_range);
  let verse_end = null;
  let m = list_multiple_is(verse_range);
  let result = null;
  if (m) {
    result = list_second(verse_range);
  } else {
    result = verse_start;
  }
  verse_end = result;
  let index = list_index_of(books, book);
  let v = {
    index,
    chapter_code,
    verse_start,
    verse_end
  };
  return v;
}
function text_split_dash(second) {
  let split4 = text_split(second, "-");
  return split4;
}
function text_split_colon(chapter_verses) {
  let split3 = text_split(chapter_verses, ":");
  return split3;
}
function ebible_references_names(books, lines) {
  function lambda(item) {
    let replacements = {
      Psalms: ["Psalm"],
      Song: ["Song of Solomon"]
    };
    function lambda2(froms, to) {
      function lambda3(from) {
        item = text_replace_if_starts_with(item, from + " ", to + " ");
      }
      each(froms, lambda3);
    }
    each_object(replacements, lambda2);
    return item;
  }
  let mapped = list_map(lines, lambda);
  let books_names = list_map_property(books, "text");
  let verse_references = list_filter_starts_with_any(mapped, books_names);
  let book_names = list_map_prefix_any(verse_references, books_names);
  let mapped2 = list_map_prefix_without_any(verse_references, books_names);
  let mapped3 = list_map_split_space(mapped2);
  let mapped4 = list_map_filter_text_empty_not_is(mapped3);
  let chapter_verses_list = list_map_first(mapped4);
  let v = {
    chapter_verses_list,
    book_names
  };
  return v;
}
function text_replace_if_starts_with(item, prefix, replacement) {
  let sw = text_starts_with(item, prefix);
  if (sw) {
    item = text_replace(item, prefix, replacement);
  }
  return item;
}
function list_map_first(mapped4) {
  let mapped = list_map(mapped4, list_first);
  return mapped;
}
function list_map_filter_text_empty_not_is(list) {
  let mapped4 = list_map(list, list_filter_empty_not_is);
  return mapped4;
}
function list_filter_empty_not_is(item) {
  let filtered = list_filter(item, text_empty_not_is);
  return filtered;
}
function list_map_split_space(mapped2) {
  function lambda(item) {
    let split2 = text_split_space(item);
    return split2;
  }
  let mapped3 = list_map(mapped2, lambda);
  return mapped3;
}
function list_map_prefix_without_any(list, prefixes) {
  function lambda(item) {
    let prefix = list_find_starts_with_prefixes(prefixes, item);
    let result = text_prefix_without(item, prefix);
    return result;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function list_find_starts_with_prefixes(prefixes, item) {
  function lambda2(item2) {
    let sw = text_starts_with(item, item2);
    return sw;
  }
  let any = list_find(prefixes, lambda2);
  return any;
}
function list_map_prefix_any(list, prefixes) {
  function lambda(item) {
    let prefix = list_find_starts_with_prefixes(prefixes, item);
    return prefix;
  }
  let mapped = list_map(list, lambda);
  return mapped;
}
function list_filter_starts_with_any(list, prefixes) {
  function lambda(item) {
    let any = list_any_starts_with(item, prefixes);
    return any;
  }
  let verse_references = list_filter(list, lambda);
  return verse_references;
}
function bible_interlinear_json_path() {
  let path_input2 = bible_interlinear_excel_path();
  let path_output = file_name_json(path_input2);
  return path_output;
}
function bible_interlinear_excel_path() {
  let joined = folder_user_combine("downloads", "bsb_tables.xlsx");
  return joined;
}
async function ebible_version_chapters_cache(bible_folder) {
  let v = await invoke_cache_file(ebible_version_chapters, [bible_folder]);
  return v;
}
async function ebible_version_chapters(bible_folder) {
  log({
    t: ebible_version_chapters,
    bible_folder
  });
  await ebible_version_download(bible_folder);
  async function lambda(la) {
    await ebible_chapters_each_verses(bible_folder, each_chapter);
    async function each_chapter(chapter_code, verses) {
      la({
        chapter_code,
        verses
      });
    }
  }
  let list = await list_adder_async(lambda);
  return list;
}
async function ebible_chapters_each_verses(bible_folder, lambda$chapter_code$verses) {
  let chapter_codes = await ebible_chapter_codes(bible_folder);
  await ebible_chapters_each_verses_list(chapter_codes, bible_folder, lambda$chapter_code$verses);
}
async function ebible_chapters_each_verses_list(chapter_codes, bible_folder, each_chapter) {
  let books = await ebible_version_books_testament_apocrypha(bible_folder);
  let mapped = list_map_property(books, "book_code");
  await each_async(chapter_codes, lambda);
  async function lambda(chapter_code) {
    if (bible_folder === "hausa" && chapter_code === "DAN14") {
      return;
    }
    if (bible_folder === "englxxup" && chapter_code === "PRO30") {
      return;
    }
    if (bible_folder === "engnna" && chapter_code === "GEN05") {
      return;
    }
    if (bible_folder === "engojb" && chapter_code === "MAL04") {
      return;
    }
    log_keep({
      bible_folder,
      chapter_code
    });
    let any = list_any_starts_with(chapter_code, mapped);
    let ebible_verses_get = null;
    ebible_verses_get = ternary(any, ebible_verses, ebible_verses_readaloud);
    "ebible website says canon only, but seems apocrypha included?";
    ebible_verses_get = ebible_verses_readaloud;
    let verses = await ebible_verses_get(bible_folder, chapter_code);
    await each_chapter(chapter_code, verses);
  }
}
async function ebible_version_books_testament_apocrypha(bible_folder) {
  let selector = ebible_class_apocrypha();
  let books = await ebible_version_books_testament(bible_folder, selector);
  return books;
}
async function ebible_verses_readaloud(bible_folder, chapter_code) {
  if (browser_is()) {
    let verses = await ebible_verses_browser(bible_folder, chapter_code);
    return verses;
  }
  let verse_numbers = await ebible_verses_numbers(bible_folder, chapter_code);
  let verse_number = ebible_verses_before();
  list_remove_if_exists(verse_numbers, verse_number);
  let file_path = ebible_version_readaloud_download_path(bible_folder);
  let files = await folder_read_paths_async(file_path);
  let book_code = ebible_chapter_code_to_book(chapter_code);
  let name_code = ebible_chapter_code_to_name_code(chapter_code);
  let search = "_" + book_code + "_" + name_code + "_";
  let only = list_find_includes(files, search);
  let contents = await file_read(only);
  let lines = text_split_newline(contents);
  let skipped = list_skip(lines, 2);
  let mapped = list_map(skipped, text_trim);
  let filtered = list_filter_empty_not_is(mapped);
  let list = list_map_pairs(filtered, verse_numbers, ebible_verse_new_text);
  return list;
}
function list_remove_if_exists(list, item) {
  let includes = list_includes(list, item);
  if (includes) {
    list_remove(list, item);
  }
}
async function ebible_verses_numbers(bible_folder, chapter_code) {
  let verses = await ebible_verses(bible_folder, chapter_code);
  let verse_numbers = list_map_property(verses, "verse_number");
  return verse_numbers;
}
function list_map_pairs(list_a, list_b, mapper) {
  function lambda_list_adder(la) {
    function lambda_each_pair(a, b) {
      const m = mapper(a, b);
      la(m);
    }
    each_pair(list_a, list_b, lambda_each_pair);
  }
  let mapped = list_adder(lambda_list_adder);
  return mapped;
}
function each_pair(list_a, list_b, lambda$a$b) {
  let each_fn = each_multiple;
  each_pair_generic(list_a, list_b, each_fn, lambda$a$b);
}
function each_pair_generic(list_a, list_b, each_fn, lambda$a$b) {
  let lists = [list_a, list_b];
  each_fn(lists, lambda);
  function lambda(items) {
    let [a, b] = items;
    lambda$a$b(a, b);
  }
}
function each_multiple(lists, lambda) {
  let getter = lists_get;
  each_multiple_generic(lists, getter, lambda);
}
function lists_get(lists, index) {
  let getter = list_get;
  const items = lists_get_generic(getter, index, lists);
  return items;
}
function lists_get_generic(getter, index, lists) {
  function lambda(list) {
    let item = getter(list, index);
    return item;
  }
  const items = list_map(lists, lambda);
  return items;
}
function each_multiple_generic(lists, getter, lambda) {
  let max = lists_size_max(lists);
  function lambda_each_range(index) {
    let items = getter(lists, index);
    lambda(items);
  }
  each_range(max, lambda_each_range);
}
function lists_size_max(lists) {
  let mapped = list_map(lists, list_size);
  let max = list_max(mapped);
  return max;
}
function each_range(count, lambda$i) {
  let list = range(count);
  each(list, lambda$i);
}
function text_trim(message) {
  let trimmed = message.trim();
  return trimmed;
}
function text_split_newline(s) {
  let separator = newline();
  let lines = text_split(s, separator);
  return lines;
}
async function folder_read_paths_async(path) {
  let file_names = await folder_read_async(path);
  let combineds = list_map_path_join_left(file_names, path);
  return combineds;
}
async function folder_read_async(path_folder) {
  const fs = await import("fs/promises");
  const path = await import("path");
  const entries = await fs.readdir(path_folder, {
    withFileTypes: true
  });
  function lambda(entry) {
    let v = entry.isFile();
    return v;
  }
  function lambda2(entry) {
    let v2 = entry.name;
    return v2;
  }
  const files = entries.filter(lambda).map(lambda2);
  return files;
}
function ebible_version_readaloud_download_path(bible_folder) {
  let joined2 = local_function_path(ebible_version_readaloud_download, bible_folder);
  return joined2;
}
async function ebible_version_readaloud_download(bible_folder) {
  let url = ebible_version_download_url(bible_folder, "readaloud");
  let buffer = await http_local(url);
  let file_path = ebible_version_readaloud_download_path(bible_folder);
  await unzip(file_path, buffer);
  return file_path;
}
function list_find_includes(list, object) {
  let filtered = list_filter_includes(list, object);
  let only = list_single(filtered);
  return only;
}
function list_filter_includes(mapped, part) {
  function lambda(item) {
    let n = text_includes(item, part);
    return n;
  }
  let filtered = list_filter(mapped, lambda);
  return filtered;
}
async function ebible_languages_chapters_cache_remove() {
  await invoke_cache_file_remove(ebible_languages_chapters, []);
}
async function invoke_cache_file_remove(fn, args) {
  let key_get = invoke_cache_file_key_get(fn, args);
  let cached_exists = file_exists;
  let cache_remove = file_delete;
  await cache_remove_generic(key_get, cached_exists, cache_remove);
}
async function cache_remove_generic(key_get, cached_exists, cache_remove) {
  let key = await key_get();
  let e = await cached_exists(key);
  true_is_assert(e);
  await cache_remove(key);
}
function true_is_assert(enabled) {
  let ti2 = true_is(enabled);
  assert(ti2);
}
async function file_delete(file_path) {
  if (browser_is()) {
    await file_overwrite(file_path, "");
    return;
  }
  let fs = await import("fs");
  await fs.promises.unlink(file_path);
}
function ebible_folder_urdu() {
  let v2 = "urdoucv";
  return v2;
}
async function app_original_bible() {
  await app_main_production("app_original_bible_main", "jared-grace");
}
app_context_initialize( app_original_bible_main );
  </script>
</body>
</html>