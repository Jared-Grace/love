<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>g</title>
</head>
<body>
  <script type="module"> 
    let global = {};
    app_g_latest(  );
    async function app_g_latest() {
  await app_main_latest("app_g_main", "jared-grace");
}
async function app_main_latest(f_name, firebase_name_value) {
  marker("1");
  let v = await app_main(f_name, firebase_name_value, firebase_deploy_function_destination_latest);
  return v;
}
function firebase_deploy_function_destination_latest(f_name) {
  marker("1");
  let destination2 = firebase_deploy_function_destination("version_latest", f_name);
  return destination2;
}
function marker(marker_name) {
  noop();
}
function noop() {}
function firebase_deploy_function_destination(name, f_name) {
  let file_name = file_name_json(name);
  const list = ["function", f_name, file_name];
  let destination = list_join_slash_forward(list);
  return destination;
}
function list_join_slash_forward(list) {
  let joined = list_join(list, "/");
  return joined;
}
function list_join(list, separator) {
  let joined = list.join(separator);
  return joined;
}
function file_name_json(name) {
  let file_name = name + ".json";
  return file_name;
}
async function app_main(f_name, firebase_name_value, version_get) {
  marker("1");
  global_function_initialize(firebase_name, firebase_name_value);
  await firebase_storage_function_run(f_name, version_get);
}
function global_function_initialize(fn, initial) {
  assert_arguments(arguments, 2);
  let global = global_get();
  let value = object_property_initialize(global, fn.name, initial);
  return value;
}
function assert_arguments(args, count) {
  let length = object_property_get(args, "length");
  equal_assert(length, count);
}
function equal_assert(left, right) {
  marker("1");
  let eq = equal(left, right);
  assert(eq);
}
function assert(b) {
  if (not(b)) {
    error();
  }
}
function not(b) {
  let n = !b;
  return n;
}
function error(message) {
  throw new Error(message);
}
function equal(left, right) {
  let eq = left === right;
  return eq;
}
function object_property_get(object, property_name) {
  let value = object[property_name];
  undefined_not_is_assert_lambda(value, object_get);
  function object_get() {
    let v = {
      object,
      property_name
    };
    return v;
  }
  return value;
}
function undefined_not_is_assert_lambda(value, lambda) {
  if (undefined_is(value)) {
    const object = lambda();
    let message = json_to(object);
    error(message);
  }
}
function json_to(object) {
  let json = JSON.stringify(object);
  return json;
}
function undefined_is(value) {
  let v = typeof value === "undefined";
  return v;
}
function object_property_initialize(object, property_name, value_initial) {
  const exists = object_property_exists(object, property_name);
  if (not(exists)) {
    object_property_set(object, property_name, value_initial);
  }
  let value = object_property_get(object, property_name);
  return value;
}
function object_property_set(object, property_name, value) {
  object[property_name] = value;
}
function object_property_exists(object, property_name) {
  const exists = object && Object.hasOwn(object, property_name);
  return exists;
}
function global_get() {
  marker("1");
  return global;
}
async function firebase_storage_function_run(f_name, version_get) {
  marker("1");
  let destination_version = version_get(f_name);
  let destination = await firebase_storage_download_property(destination_version, "destination");
  let code = await firebase_storage_download_property(destination, "code");
  let call = js_code_call_statement(f_name);
  let global_init = js_code_global_init();
  let joined = list_join_newline([global_init, call, code]);
  if (browser_is()) {
    let body = html_document_body();
    let component = html_element(body, "script");
    html_attribute_set(component, "type", "module");
    html_text_set(component, joined);
    return;
  }
  eval(joined);
}
function js_code_global_init() {
  let right = js_code_braces_empty();
  let code_assign = js_code_let_assign("global", right);
  return code_assign;
}
function js_code_let_assign(left, right) {
  let code_assign = js_keyword_let() + " " + js_code_assign(left, right) + ";";
  return code_assign;
}
function js_code_assign(left, right) {
  const code = left + " = " + right;
  return code;
}
function js_keyword_let() {
  let v = "let";
  return v;
}
function js_code_braces_empty() {
  let v = js_code_wrap_braces("");
  return v;
}
function js_code_wrap_braces(inside) {
  let v = "{" + inside + "}";
  return v;
}
function html_text_set(component, text) {
  let element = html_component_element_get(component);
  element.innerHTML = text;
}
function html_component_element_get(component) {
  let element = object_property_get(component, "element");
  return element;
}
function html_attribute_set(component, key, value) {
  let element = html_component_element_get(component);
  element.setAttribute(key, value);
}
function html_element(parent, tag_name) {
  let parent_element = html_component_element_get(parent);
  const e = document.createElement(tag_name);
  parent_element.appendChild(e);
  let component = html_component_wrap(e);
  html_style_set(component, "box-sizing", "border-box");
  return component;
}
function html_style_set(b, style_key, style_value) {
  let b_element = html_component_element_get(b);
  b_element.style[style_key] = style_value;
}
function html_component_wrap(element) {
  let v = {
    element
  };
  return v;
}
function html_document_body() {
  marker("1");
  let body_element = document.body;
  let body = html_component_wrap(body_element);
  return body;
}
function browser_is() {
  let b = typeof window !== "undefined" && typeof window.document !== "undefined";
  return b;
}
function list_join_newline(list) {
  let separator = newline();
  let joined = list_join(list, separator);
  return joined;
}
function newline() {
  let v = "\n";
  return v;
}
function js_code_call_statement(f_name) {
  let code = js_code_call(f_name);
  let result = js_code_statement(code);
  return result;
}
function js_code_call(fn_name) {
  let args = [];
  let result = js_code_call_args(fn_name, args);
  return result;
}
function js_code_call_args(fn_name, args) {
  let joined = list_join_comma_space(args);
  let code = fn_name + js_code_wrap_parenthesis(joined);
  return code;
}
function js_code_wrap_parenthesis(inside) {
  let v = "( " + inside + " )";
  return v;
}
function list_join_comma_space(args) {
  let v = list_join(args, ", ");
  return v;
}
function js_code_statement(code) {
  let v = code + ";";
  return v;
}
async function firebase_storage_download_property(storage_path, property_name) {
  let buffer = await firebase_storage_download(storage_path);
  const json = buffer_string_to(buffer);
  let o = json_from(json);
  let value = object_property_get(o, property_name);
  return value;
}
function json_from(json) {
  let v = JSON.parse(json);
  return v;
}
function buffer_string_to(buffer) {
  let s = null;
  let b = browser_is();
  if (b) {
    if (buffer instanceof ArrayBuffer) {
      s = new TextDecoder("utf-8").decode(new Uint8Array(buffer));
    } else if (buffer instanceof Uint8Array) {
      s = new TextDecoder("utf-8").decode(buffer);
    } else {
      throw new Error("Unsupported buffer type");
    }
  } else {
    s = buffer.toString("utf8");
  }
  return s;
}
async function firebase_storage_download(destination) {
  marker("1");
  destination = firebase_path_fix(destination);
  let b = browser_is();
  if (b) {
    let url = await firebase_storage_url(destination);
    let buffer = await http(url);
    return buffer;
  }
  const bucket = await firebase_bucket();
  let [buffer] = await bucket.file(destination).download();
  return buffer;
}
async function http(url) {
  let b = browser_is();
  if (b) {
    async function lambda3() {
      const response = await fetch(url);
      if (not(response.ok)) {
        error("Failed to fetch file");
      }
      const buf = await response.arrayBuffer();
      return buf;
    }
    let v = await html_loading(lambda3);
    return v;
  }
  await http_sleep();
  let h = null;
  let sw = string_starts_with(url, "https://");
  if (sw) {
    h = await import("https");
  }
  let buffer = await promise_wrap(lambda);
  function lambda(resolve, reject) {
    function lambda2(res) {
      const chunks = [];
      function on_data(chunk) {
        let v2 = chunks.push(chunk);
        return v2;
      }
      let result = catch_call(reject, on_data);
      res.on("data", result);
      function on_end() {
        const {statusCode} = res;
        const d = statusCode / 100;
        const rounded = round(d);
        assert_json(rounded === 2, {
          url
        });
        let v3 = Buffer.concat(chunks);
        resolve(v3);
      }
      let result2 = catch_call(reject, on_end);
      res.on("end", result2);
    }
    h.get(url, lambda2).on("error", reject);
  }
  return buffer;
}
async function http_sleep() {
  await sleep(integer_random(5, 8) * 1000);
}
function integer_random(min, max) {
  let r = floor(random() * (max - min + 1)) + min;
  return r;
}
function random() {
  let v = Math.random();
  return v;
}
function floor(p) {
  let floored = Math.floor(p);
  return floored;
}
async function sleep(ms) {
  await new Promise(function lambda5(resolve) {
    let v = setTimeout(resolve, ms);
    return v;
  });
}
async function html_loading(lambda) {
  marker("1");
  let body = html_document_body();
  let div = html_div(body);
  let s = {
    position: "fixed",
    top: "0",
    left: "0",
    width: "100vw",
    height: "100vh",
    background: "rgba(0, 0, 0, 0.6)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    zIndex: "1000"
  };
  html_style_assign(div, s);
  let result = await lambda();
  html_remove(div);
  return result;
}
function html_remove(component) {
  marker("1");
  let element = html_component_element_get(component);
  element.remove();
}
function html_style_assign(b, s) {
  marker("1");
  let b_element = html_component_element_get(b);
  object_assign(b_element.style, s);
}
function object_assign(to, from) {
  marker("1");
  let a = Object.assign(to, from);
  return a;
}
function html_div(root) {
  let div = html_element(root, "div");
  return div;
}
function catch_call(reject, lambda) {
  let i = function inner() {
    let result = null;
    try {
      result = lambda(...arguments);
    } catch (e) {
      reject(e);
    }
    marker("1");
    return result;
  };
  return i;
}
function promise_wrap(lambda) {
  let v = new Promise(function lambda4(resolve, reject) {
    try {
      lambda(resolve, reject);
    } catch (e) {
      reject(e);
    }
  });
  return v;
}
function round(n) {
  let rounded = Math.round(n);
  return rounded;
}
function string_starts_with(s, prefix) {
  let sw = s.startsWith(prefix);
  return sw;
}
function assert_json(b, o) {
  let message = json_to(o);
  assert_message(b, message);
}
function assert_message(b, message) {
  if (not(b)) {
    error(message);
  }
}
async function firebase_bucket() {
  const admin = await firebase_admin();
  const bucket = admin.storage().bucket();
  return bucket;
}
async function firebase_admin() {
  let admin = await global_function_async(firebase_admin, firebase_admin_get);
  return admin;
}
async function global_function_async(fn, lambda) {
  let global = global_get();
  marker("1");
  let value = object_property_lambda(global, fn.name, lambda);
  let awaited = await value;
  return awaited;
}
function object_property_lambda(object, property_name, lambda) {
  marker("1");
  const exists = object_property_exists(object, property_name);
  if (not(exists)) {
    let value_set = lambda();
    object_property_set(object, property_name, value_set);
  }
  let value = object_property_get(object, property_name);
  return value;
}
async function firebase_admin_get() {
  const admin = (await import("firebase-admin")).default;
  marker("1");
  let service_account = await firebase_service_account();
  const sb = await firebase_storage_url_project();
  admin.initializeApp({
    credential: admin.credential.cert(service_account),
    storageBucket: sb
  });
  return admin;
}
async function firebase_storage_url_project() {
  marker("1");
  const prefix = await firebase_name();
  let url = prefix + ".firebasestorage.app";
  return url;
}
async function firebase_name() {
  if (browser_is()) {
    let value = global_function_get(firebase_name);
    return value;
  }
  let repo_name = await user_repo_get();
  let default2 = await firebase_name_repo(repo_name);
  return default2;
}
async function firebase_name_repo(repo_name) {
  const f_path = ".firebaserc";
  let combined = repo_path_combine(repo_name, f_path);
  let f = await file_read_json(combined);
  let projects = object_property_get(f, "projects");
  let default2 = object_property_get(projects, "default");
  return default2;
}
async function file_read_json(file_path) {
  let json = await file_read(file_path);
  let data = json_from(json);
  return data;
}
async function file_read(file_path) {
  let fs = await import("fs");
  let contents = await fs.promises.readFile(file_path, "utf-8");
  return contents;
}
function repo_path_combine(repo_name, f_path) {
  let folder_name = repo_path(repo_name);
  let combined = path_join([folder_name, f_path]);
  return combined;
}
function path_join(segments) {
  assert_arguments(arguments, 1);
  let parts = [];
  for (let seg of segments) {
    if (not(seg)) {
      continue;
    }
    let split = seg.split(/[\\/]+/);
    for (let s of split) {
      if (s === "" || s === ".") {
        continue;
      }
      if (s === folder_previous()) {
        if (parts.length > 0 && parts[parts.length - 1] !== folder_previous()) {
          parts.pop();
        } else {
          let previous = folder_previous();
          parts.push(previous);
        }
      } else {
        parts.push(s);
      }
    }
  }
  let joined = parts.join("/");
  return joined;
}
function folder_previous() {
  let previous = "..";
  return previous;
}
function repo_path(repo_name) {
  marker("1");
  let previous = repos_folder();
  let r_path = path_join([previous, repo_name]);
  return r_path;
}
function repos_folder() {
  let previous = folder_previous();
  return previous;
}
function global_function_get(fn) {
  let global = global_get();
  let value = object_property_get(global, fn.name);
  return value;
}
async function user_repo_get() {
  marker("1");
  let f_path = user_repo_path();
  let {value: repo_name} = await data_get("repo_current", null, f_path);
  await repo_exists_assert(repo_name);
  return repo_name;
}
async function repo_exists_assert(repo_name) {
  let all = await repos_names();
  list_includes_assert(all, repo_name);
}
function list_includes_assert(all, repo_name) {
  let includes = list_includes(all, repo_name);
  assert(includes);
}
function list_includes(list, item) {
  const includes = list.includes(item);
  return includes;
}
async function repos_names() {
  marker("1");
  let path_folder = repos_folder();
  let rns = await folder_read(path_folder);
  return rns;
}
async function folder_read(path_folder) {
  marker("1");
  let fs = await import("fs");
  const all = await fs.promises.readdir(path_folder);
  return all;
}
async function data_get(property_name, value_initial, d_path) {
  marker("1");
  var {data, file_path} = await data_all(d_path);
  let value = object_property_initialize(data, property_name, value_initial);
  let v = {
    value,
    file_path,
    data
  };
  return v;
}
async function data_all(file_path) {
  marker("1");
  let data = {};
  let d_path = data_path();
  if (equal(file_path, d_path)) {
    await data_generate(data);
    if (false) {
      async function lambda2() {
        await data_generate(data);
        return data;
      }
      data = await global_function_property_async(data_all, d_path, lambda2);
    }
  } else {
    let exists = await file_exists(file_path);
    if (not(exists)) {
      let contents = json_format_to({});
      await file_write(file_path, contents);
    }
    data = await file_read_json(file_path);
  }
  let v = {
    data,
    file_path
  };
  return v;
}
async function data_generate(data) {
  let f_paths = await functions_paths();
  let parseds = await list_map_unordered_async(f_paths, file_js_parse);
  async function lambda(parsed) {
    data_file_update_inner(parsed, data);
  }
  each(parseds, lambda);
}
function each(list, lambda$item) {
  marker("1");
  for (let item of list) {
    if (lambda$item(item) === true) {
      return;
    }
  }
}
function data_file_update_inner(parsed, data) {
  let {f_path} = parsed;
  let f_name = function_path_to_name(f_path);
  let {ast} = parsed;
  let f_identifiers_new = js_identifiers_names(ast);
  const property_name = "identifiers";
  let identifiers = object_property_initialize(data, property_name, {});
  function lambda2(i_name) {
    let list = object_property_initialize(identifiers, i_name, []);
    list_add_if_not_includes(list, f_name);
  }
  each(f_identifiers_new, lambda2);
  let functions = object_property_initialize(data, "functions", {});
  let f_this = object_property_initialize(functions, f_name, {});
  let declaration = js_declaration_single(ast);
  let async_is = object_property_get(declaration, "async");
  object_property_set(f_this, "async", async_is);
  let f_identifiers_old = object_property_initialize(f_this, property_name, []);
  let removals = list_difference(f_identifiers_old, f_identifiers_new);
  function lambda(item) {
    let list = object_property_initialize(identifiers, item, []);
    list_remove_all(list, f_name);
    let e = list_empty_is(list);
    if (e) {
      object_property_delete(identifiers, item);
    }
  }
  each(removals, lambda);
  object_property_set(f_this, property_name, f_identifiers_new);
}
function js_declaration_single(ast) {
  function lambda2(la) {
    function lambda(v) {
      let {node} = v;
      la(node);
    }
    js_visit_type(ast, "ExportNamedDeclaration", lambda);
  }
  let nameds = list_adder(lambda2);
  let {declaration} = list_single(nameds);
  return declaration;
}
function list_adder(lambda$la) {
  let fn = list_add;
  let list = list_adder_generic(lambda$la, fn);
  return list;
}
function list_adder_generic(lambda, fn) {
  let list = [];
  function list_adder_inner(item) {
    fn(list, item);
  }
  lambda(list_adder_inner);
  return list;
}
function list_add(list, item) {
  list.push(item);
}
function list_single(list) {
  list_size_1_assert(list);
  let only = list_first(list);
  return only;
}
function list_size_1_assert(list) {
  let message = list_size(list);
  let message2 = string_to(message);
  list_size_1_assert_message(list, message2);
}
function list_size_1_assert_message(list, message) {
  let a = list_size_1(list);
  if (not(a)) {
    error(message);
  }
}
function list_size_1(list) {
  const s1 = list_size(list) === 1;
  return s1;
}
function list_size(list) {
  list_is_assert(list);
  let size = list.length;
  return size;
}
function list_is_assert(list) {
  function lambda() {
    let v = {
      list
    };
    return v;
  }
  list_is_assert_json(list, lambda);
}
function list_is_assert_json(list, lambda) {
  let result = list_is(list);
  assert_json_get(result, lambda);
}
function assert_json_get(b, lambda) {
  marker("1");
  function lambda2() {
    let object = lambda();
    let json = json_to(object);
    return json;
  }
  let v = assert_message_get(b, lambda2);
  return v;
}
function assert_message_get(b, lambda) {
  marker("1");
  if (not(b)) {
    let message = lambda();
    error(message);
  }
}
function list_is(value) {
  const l = Array.isArray(value);
  return l;
}
function string_to(input) {
  const s = input.toString();
  return s;
}
function list_first(list) {
  const index = 0;
  const first = list_get(list, index);
  return first;
}
function list_get(list, index) {
  integer_is_assert(index);
  let item = list[index];
  undefined_not_is_assert_lambda(item, object_get);
  function object_get() {
    let v = {
      list,
      index
    };
    return v;
  }
  return item;
}
function integer_is_assert(index) {
  let ii = integer_is(index);
  assert_json(ii, {
    index
  });
}
function integer_is(value) {
  marker("1");
  let ii = Number.isInteger(value);
  return ii;
}
function js_visit_type(ast, type, lambda$v) {
  js_visit_types(ast, [type], lambda$v);
}
function js_visit_types(ast, types, lambda$v) {
  marker("1");
  function lambda(v) {
    let {node} = v;
    if (js_node_is(node) && js_node_types_is(node, types)) {
      lambda$v(v);
    }
  }
  js_visit(ast, lambda);
}
function js_node_types_is(item, types) {
  function lambda2(type) {
    let type_is = js_node_type_is(item, type);
    return type_is;
  }
  const match = list_any(types, lambda2);
  return match;
}
function list_any(list, lambda$item) {
  marker("1");
  let filtered = list_filter(list, lambda$item);
  let any = list_empty_not_is(filtered);
  return any;
}
function list_empty_not_is(list) {
  let a = list_empty_is(list);
  const ne = not(a);
  return ne;
}
function list_empty_is(list) {
  const e = list_size(list) === 0;
  return e;
}
function list_filter(list, lambda$item) {
  list_is_assert(list);
  function lambda(item) {
    let match = lambda$item(item);
    return match;
  }
  let filtered = list.filter(lambda);
  return filtered;
}
function js_node_type_is(node, type) {
  const type_is = js_node_is(node) && js_node_type(node) === type;
  return type_is;
}
function js_node_is(n) {
  const ni = object_property_exists(n, "type");
  return ni;
}
function js_node_type(n) {
  const nt = object_property_get(n, "type");
  return nt;
}
function js_visit(ast, lambda$v) {
  let a = promise_not_is(ast);
  if (not(a)) {
    error();
  }
  visit_filter(ast, js_visit_children_get, js_visit_filter, lambda$v);
}
function promise_not_is(ast) {
  let a = promise_is(ast);
  let n = not(a);
  return n;
}
function promise_is(value) {
  let v = value !== null && typeof value === "object" && typeof value.then === "function" && typeof value.catch === "function";
  return v;
}
function visit_filter(node, children_get, filter, on_each) {
  visit_filter_recursive(node, children_get, filter, on_each, []);
}
function visit_filter_recursive(node, children_get, filter, on_each, stack) {
  let a = filter(node);
  if (not(a)) {
    return;
  }
  list_add(stack, node);
  let children = children_get(node);
  function lambda(c) {
    visit_filter_recursive(c, children_get, filter, on_each, stack);
  }
  each(children, lambda);
  let copy = list_copy(stack);
  on_each({
    node,
    stack: copy
  });
  let removed = list_pop(stack);
  if (removed !== node) {
    error();
  }
}
function list_pop(list) {
  let popped = list.pop();
  return popped;
}
function list_copy(original) {
  const copy = [...original];
  return copy;
}
function js_visit_children_get(n) {
  if (list_is(n)) {
    return n;
  }
  if (string_is(n)) {
    let v = [];
    return v;
  }
  function lambda(p) {
    let value = object_property_get(n, p);
    return value;
  }
  let list = object_properties(n);
  let mapped = list_map(list, lambda);
  return mapped;
}
function object_properties(obj) {
  const properties = Object.getOwnPropertyNames(obj);
  return properties;
}
function string_is(value) {
  let si = typeof value === "string";
  return si;
}
function list_map(list, lambda$item) {
  list_is_assert(list);
  let mapped = list.map(lambda$item);
  return mapped;
}
function js_visit_filter(n) {
  let v = js_node_is(n) || list_is(n);
  return v;
}
function object_property_delete(object, property_name) {
  object_property_exists_assert(object, property_name);
  delete object[property_name];
}
function object_property_exists_assert(object, property_name) {
  let result = object_property_exists(object, property_name);
  function lambda() {
    let v = {
      object,
      property_name
    };
    return v;
  }
  assert_json_get(result, lambda);
}
function list_remove_all(list, item) {
  while (list_includes(list, item)) {
    list_remove(list, item);
  }
}
function list_remove(list, item) {
  const index = list_index_of(list, item);
  list_remove_at(list, index);
}
function list_remove_at(list, index) {
  list.splice(index, 1);
}
function list_index_of(list, item) {
  let index = list.indexOf(item);
  if (index <= -1) {
    error_json({
      list,
      item,
      index
    });
  }
  return index;
}
function error_json(o) {
  let message = json_format_to(o);
  error(message);
}
function json_format_to(object) {
  let v = JSON.stringify(object, null, 1);
  return v;
}
function list_difference(list, other) {
  function lambda2(la) {
    function lambda(l) {
      let a = list_includes(other, l);
      if (not(a)) {
        la(l);
      }
    }
    each(list, lambda);
  }
  let difference = list_adder(lambda2);
  return difference;
}
function list_add_if_not_includes(list, item) {
  "rename includes to exists todo";
  let exists = list_includes(list, item);
  if (not(exists)) {
    list_add(list, item);
  }
}
function js_identifiers_names(ast) {
  function lambda2(la) {
    function lambda(v) {
      let {node} = v;
      let value = object_property_get(node, "name");
      la(value);
    }
    js_visit_type(ast, "Identifier", lambda);
  }
  const names = list_adder_unique(lambda2);
  return names;
}
function list_adder_unique(lambda) {
  let items = list_adder(lambda);
  let unique = list_unique(items);
  return unique;
}
function list_unique(list) {
  let unique = [];
  function lambda(item) {
    let a = list_includes(unique, item);
    if (not(a)) {
      list_add(unique, item);
    }
  }
  each(list, lambda);
  return unique;
}
function function_path_to_name(f_path) {
  let f_name = path_name(f_path);
  return f_name;
}
function path_name(file_path) {
  const parts = file_path.split(/[/\\]/);
  const filename = parts.pop();
  let v = filename.lastIndexOf(".");
  const name = filename.includes(".") ? filename.slice(0, v) : filename;
  return name;
}
async function file_js_parse(f_path) {
  let code = await file_read(f_path);
  const ast = await js_parse_async(code);
  const parsed = {
    ast,
    code,
    f_path
  };
  return parsed;
}
async function js_parse_async(code) {
  const acorn = await import("acorn");
  marker("1");
  let v = js_parse_generic(acorn, code);
  return v;
}
function js_parse_generic(acorn, code) {
  let ast = null;
  try {
    ast = acorn.parse(code, {
      ecmaVersion: 2020,
      sourceType: "module"
    });
  } catch (e) {
    log_keep(code);
    throw e;
  }
  return ast;
}
function log_keep(message) {
  console.log(message);
}
function log(message) {
  log_keep(message);
  let a = 1;
}
async function list_map_unordered_async(list, lambda$item) {
  let mapped = list_map(list, lambda$item);
  let waited = await list_wait(mapped);
  return waited;
}
async function list_wait(list) {
  let v = await Promise.all(list);
  return v;
}
async function functions_paths() {
  marker("1");
  async function mapper(folder) {
    let f_names = await functions_names_from_path(folder);
    function lambda2(f_name) {
      let v = function_name_folder_to_path(f_name, folder);
      return v;
    }
    let mapped = list_map(f_names, lambda2);
    return mapped;
  }
  let squashed = await repos_paths_map_unordered_combine_squash(mapper);
  return squashed;
}
async function repos_paths_map_unordered_combine_squash(mapper) {
  let path = functions_path();
  let result = await repos_paths_map_unordered_combine(path, mapper);
  let squashed = list_squash(result);
  return squashed;
}
function list_squash(list) {
  function lambda2(la) {
    list_process(list);
    function list_process(list) {
      function lambda(item) {
        let l = list_is(item);
        let fn = null;
        if (l) {
          fn = list_process;
        } else {
          fn = la;
        }
        fn(item);
      }
      each(list, lambda);
    }
  }
  let squashed = list_adder(lambda2);
  return squashed;
}
async function repos_paths_map_unordered_combine(path, mapper) {
  let result = await repos_paths_map_unordered(each_folder);
  async function each_folder(folder) {
    let joined = path_join([folder, path]);
    let f_names = mapper(joined);
    return f_names;
  }
  return result;
}
async function repos_paths_map_unordered(lambda$folder) {
  marker("1");
  let all = await repos_names();
  async function lambda(repo_name) {
    let folder = repo_path(repo_name);
    let mapped = await lambda$folder(folder);
    return mapped;
  }
  let result = await list_map_unordered_async(all, lambda);
  return result;
}
function functions_path() {
  const second = folder_src();
  let joined = folder_public_combine(second);
  return joined;
}
function folder_src() {
  let src = "src";
  return src;
}
function folder_public_combine(f_path) {
  let result = folder_public();
  let combined = path_join([result, f_path]);
  return combined;
}
function folder_public() {
  let v = "public";
  return v;
}
async function functions_names_from_path(path) {
  let paths = await folder_read_files(path);
  function lambda(p) {
    let suffix = function_name_extension();
    let without = string_suffix_without(p, suffix);
    return without;
  }
  let f_names = list_map(paths, lambda);
  return f_names;
}
function string_suffix_without(s, suffix) {
  let a = string_ends_with(s, suffix);
  if (not(a)) {
    error();
  }
  const without = string_slice(s, 0, string_size(s) - string_size(suffix));
  return without;
}
function string_ends_with(s, suffix) {
  const ew = s.endsWith(suffix);
  return ew;
}
function string_slice(s, a, b) {
  let sliced = s.slice(a, b);
  return sliced;
}
function string_size(s) {
  let size = s.length;
  return size;
}
function function_name_extension() {
  const ext = ".mjs";
  return ext;
}
async function folder_read_files(path_folder) {
  let fs = await import("fs");
  marker("1");
  function lambda(file) {
    let result = path_join([path_folder, file]);
    let v = fs.statSync(result).isFile();
    return v;
  }
  const all = fs.readdirSync(path_folder);
  let files = all.filter(lambda);
  list_sort_string(files);
  return files;
}
function list_sort_string(list) {
  function lambda(a, b) {
    const [na, ia] = a.split(/[_\.]/);
    const [nb, ib] = b.split(/[_\.]/);
    let v = na.localeCompare(nb) || Number(ia) - Number(ib);
    return v;
  }
  list.sort(lambda);
}
function function_name_folder_to_path(f_name, folder) {
  let base = function_name_to_base(f_name);
  let second = [folder, base];
  let joined = path_join(second);
  return joined;
}
function function_name_to_base(f_name) {
  let f_name_ext = f_name + function_name_extension();
  return f_name_ext;
}
async function global_function_property_async(fn, property_name, lambda) {
  let global = global_get();
  marker("1");
  let fn_object = object_property_initialize(global, fn.name, {});
  let value = await object_property_lambda_async(fn_object, property_name, lambda);
  return value;
}
async function object_property_lambda_async(object, property_name, lambda) {
  marker("1");
  const exists = object_property_exists(object, property_name);
  if (not(exists)) {
    let value_set = await lambda();
    object_property_set(object, property_name, value_set);
  }
  let value = object_property_get(object, property_name);
  return value;
}
async function file_write(f_path, contents) {
  let overwrite = file_overwrite;
  await file_write_generic(f_path, overwrite, contents);
}
async function file_write_generic(f_path, overwrite, contents) {
  await assert_file_exists_not(f_path);
  await overwrite(f_path, contents);
}
async function assert_file_exists_not(file_path_new) {
  if (await file_exists(file_path_new)) {
    error(file_path_new);
  }
}
async function file_exists(file_path) {
  marker("1");
  if (promise_is(file_path)) {
    error();
  }
  let fs = await import("fs");
  let {access} = fs.promises;
  let {constants} = fs;
  let exists = await throws_not_async(lambda);
  async function lambda() {
    await access(file_path, constants.F_OK);
  }
  return exists;
}
async function throws_not_async(lambda) {
  let success = null;
  try {
    await lambda();
    success = true;
  } catch (e) {
    success = false;
  }
  return success;
}
async function file_overwrite(file_path, contents) {
  await file_parent_exists_ensure(file_path);
  let fs = await import("fs");
  await fs.promises.writeFile(file_path, contents, "utf-8");
  return;
}
async function file_root_exists_assert(file_path) {
  let {exists, root} = await file_root_exists(file_path);
  assert_json(exists, {
    file_path,
    root,
    message: "root does not exist"
  });
}
async function file_root_exists(file_path) {
  let path = await import("path");
  let parsed = path.parse(file_path);
  let root = object_property_get(parsed, "root");
  let en = string_empty_not_is(root);
  let exists = true;
  if (en) {
    async function lambda2() {
      let fs = await import("fs");
      await fs.promises.access(root);
    }
    exists = await throws_not_async(lambda2);
  }
  let v = {
    exists,
    root
  };
  return v;
}
function string_empty_not_is(name) {
  let a = string_empty_is(name);
  const ne = not(a);
  return ne;
}
function string_empty_is(s) {
  const e = s === "";
  return e;
}
async function file_parent_exists_ensure(file_path) {
  await file_root_exists_assert(file_path);
  let fs = await import("fs");
  let path = await import("path");
  const dir = path.dirname(file_path);
  await fs.promises.mkdir(dir, {
    recursive: true
  });
  return;
}
function data_path() {
  let inner = "";
  let f_path = data_path_generic(inner, "data");
  return f_path;
}
function data_path_generic(suffix, f_name_unsuffixed) {
  marker("1");
  const f_name = f_name_unsuffixed + suffix;
  const folder = "data";
  let f_path = file_name_json_folder(folder, f_name);
  return f_path;
}
function file_name_json_folder(folder, f_name) {
  let joined = path_join([folder, f_name]);
  let f_path = file_name_json(joined);
  return f_path;
}
function user_repo_path() {
  const name = "user";
  let f_path = file_name_json_folder_gitignore(name);
  return f_path;
}
function file_name_json_folder_gitignore(name) {
  let f_path2 = file_name_json_folder("gitignore", name);
  return f_path2;
}
async function firebase_service_account() {
  let f_name = await user_repo_firebase_service_account_get();
  let file_path = await function_run(f_name, []);
  let service_account = await file_read_json(file_path);
  return service_account;
}
async function function_run(f_name, args) {
  const fn = await function_import(f_name);
  const result = await fn(...args);
  return result;
}
async function function_import(f_name) {
  let {unaliased} = await function_name_unalias(f_name);
  let {f_path: f} = await function_name_to_path_search(unaliased);
  let f_path = await path_resolve(f);
  const imported = await import(`file://${f_path}`);
  const imported_fn = imported[unaliased];
  if (typeof imported_fn !== "function") {
    throw new Error(`âŒ The module "${unaliased}" does not export a default function.`);
  }
  return imported_fn;
}
async function path_resolve(paths) {
  let path = await import("path");
  let v = path.resolve(paths);
  return v;
}
async function function_name_unalias(f_name) {
  assert_arguments(arguments, 1);
  marker("1");
  var {exists, unaliased: unaliased_actual} = await function_alias_add_generic(f_name);
  let {expanded, expandeds} = await function_acronym_to_name(f_name);
  const unaliased = exists ? unaliased_actual : expanded !== null ? expanded : f_name;
  let v = {
    unaliased,
    expandeds
  };
  return v;
}
async function function_acronym_to_name(alias) {
  let expanded = null;
  let expandeds = null;
  let acronyms = await function_names_to_acronyms();
  const exists2 = object_property_exists(acronyms, alias);
  if (exists2) {
    expandeds = object_property_get(acronyms, alias);
    let s1 = list_size_1(expandeds);
    if (s1) {
      expanded = list_single(expandeds);
    }
  }
  let v = {
    expanded,
    expandeds
  };
  return v;
}
async function function_names_to_acronyms() {
  let f_names = await functions_names();
  let dictionary = list_to_dictionary(f_names, function_name_to_acronym);
  let acronyms = object_invert(dictionary);
  return acronyms;
}
function object_invert(object) {
  let inverted = {};
  function lambda(value, key) {
    undefined_not_is_assert(value);
    let list = object_property_initialize(inverted, value, []);
    list_add(list, key);
  }
  each_object(object, lambda);
  return inverted;
}
function undefined_not_is_assert(value) {
  marker("1");
  function lambda2() {
    let v2 = {};
    return v2;
  }
  undefined_not_is_assert_lambda(value, lambda2);
}
function each_object(object, lambda$value$property) {
  function lambda2(property) {
    let value = object_property_get(object, property);
    lambda$value$property(value, property);
  }
  let properties = object_properties(object);
  each(properties, lambda2);
}
function function_name_to_acronym(f_name) {
  let parts = function_name_to_parts(f_name);
  let letters = null;
  try {
    letters = list_map(parts, list_first);
  } catch (e) {
    "if this error, then maybe string empty, __ instead of _ or ends with _";
    error_json({
      e,
      f_name
    });
  }
  let acronym = list_join_empty(letters);
  return acronym;
}
function list_join_empty(letters) {
  const e = string_empty();
  let joined = list_join(letters, e);
  return joined;
}
function string_empty() {
  let v = "";
  return v;
}
function function_name_to_parts(f_name) {
  let separator = function_name_separator();
  let parts = string_split(f_name, separator);
  return parts;
}
function string_split(s, separator) {
  const split = s.split(separator);
  return split;
}
function function_name_separator() {
  const separator = "_";
  return separator;
}
function list_to_dictionary(list, lambda$item) {
  let dictionary = {};
  function lambda(item) {
    let value = lambda$item(item);
    object_property_set(dictionary, item, value);
  }
  each(list, lambda);
  return dictionary;
}
async function functions_names() {
  marker("1");
  let f_names = await repos_paths_map_unordered_combine_squash(mapper);
  async function mapper(joined) {
    let f_names = await functions_names_from_path(joined);
    return f_names;
  }
  return f_names;
}
async function function_alias_add_generic(alias) {
  let unaliased = null;
  let d_path = data_aliases_path();
  var {value: aliases, file_path, data} = await data_get("aliases", {}, d_path);
  const exists = object_property_exists(aliases, alias);
  if (exists) {
    unaliased = object_property_get(aliases, alias);
  }
  let v = {
    exists,
    aliases,
    file_path,
    data,
    unaliased
  };
  return v;
}
function data_aliases_path() {
  marker("1");
  let f_path = data_path_generic("", "aliases");
  return f_path;
}
async function function_name_to_path_search(unaliased) {
  let f_path = function_name_to_path(unaliased);
  async function lambda(joined) {
    let exists = await file_exists(joined);
    let v = {
      exists,
      f_path: joined
    };
    return v;
  }
  let mapped = await repos_paths_names_map_unordered_combine(f_path, lambda);
  function lambda2(m) {
    let mapped = object_property_get(m, "mapped");
    let exists2 = object_property_get(mapped, "exists");
    let ti2 = true_is(exists2);
    return ti2;
  }
  let filtered = list_filter(mapped, lambda2);
  let multiple = list_multiple_is(filtered);
  let exists = list_size_1(filtered);
  let search = {
    exists,
    multiple
  };
  if (exists) {
    let only = list_single(filtered);
    let mapped = object_property_get(only, "mapped");
    object_property_from(search, "f_path", mapped);
    object_property_from(search, "repo_name", only);
  }
  return search;
}
function object_property_from(to, property_name, from) {
  let value = object_property_get(from, property_name);
  object_property_set(to, property_name, value);
}
async function repos_paths_names_map_unordered_combine(path, mapper) {
  marker("1");
  let result = await repos_paths_names_map_unordered(each_folder);
  async function each_folder(repo_name, r_path) {
    let joined = path_join([r_path, path]);
    let mapped = await mapper(joined);
    let v = {
      mapped,
      repo_name
    };
    return v;
  }
  return result;
}
async function repos_paths_names_map_unordered(lambda$name$path) {
  marker("1");
  let all = await repos_names();
  async function lambda(repo_name) {
    let path = repo_path(repo_name);
    let mapped = await lambda$name$path(repo_name, path);
    return mapped;
  }
  let result = await list_map_unordered_async(all, lambda);
  return result;
}
function list_multiple_is(list) {
  let v = list_size(list) >= 2;
  return v;
}
function true_is(value) {
  let ti = equal(value, true);
  return ti;
}
function function_name_to_path(f_name) {
  if (string_includes(f_name, ".")) {
    error_json({
      f_name
    });
  }
  let folder = functions_path();
  let v = function_name_folder_to_path(f_name, folder);
  return v;
}
function string_includes(input, part) {
  const o = {
    input,
    part
  };
  string_is_assert_json(input, o);
  string_is_assert_json(part, o);
  let i = input.includes(part);
  return i;
}
function string_is_assert_json(value, o) {
  let message = json_to(o);
  string_is_assert_message(value, message);
}
function string_is_assert_message(value, message) {
  marker("1");
  let b = string_is(value);
  let v = assert_message(b, message);
  return v;
}
async function user_repo_firebase_service_account_get() {
  marker("1");
  let repo_name = await user_repo_get();
  let v = await repo_firebase_service_account_get(repo_name);
  return v;
}
async function repo_firebase_service_account_get(repo_name) {
  const key = "firebase_service_account";
  let v = await repo_about_get(repo_name, key);
  return v;
}
async function repo_about_get(repo, key) {
  let a_path = path_repo_about(repo);
  let {value} = await data_get(key, null, a_path);
  let v = value;
  return v;
}
function path_repo_about(repo) {
  let f_path = data_path_generic("", "about");
  let a_path = path_repo_combine(repo, f_path);
  return a_path;
}
function path_repo_combine(repo, f_path) {
  let r_path = repo_path(repo);
  let joined = path_join([r_path, f_path]);
  return joined;
}
function firebase_path_fix(path) {
  let replaced = string_replace(path, "\\", "/");
  return replaced;
}
function string_replace(s, from, to) {
  marker("1");
  let split = string_split(s, from);
  let replaced = list_join(split, to);
  return replaced;
}
async function firebase_storage_url(storage_path) {
  let replaced = string_replace(storage_path, "/", "%2F");
  let url = "https://firebasestorage.googleapis.com/v0/b/" + await firebase_storage_url_project() + "/o/" + replaced + "?alt=media";
  return url;
}
  </script>
</body>
</html>